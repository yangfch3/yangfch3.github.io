<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FuChee&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangfch3.com/"/>
  <updated>2018-04-23T01:03:29.778Z</updated>
  <id>http://yangfch3.com/</id>
  
  <author>
    <name>FuChee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pm2 与 log4js 混用指南</title>
    <link href="http://yangfch3.com/2018/04/22/log4js-with-pm2/"/>
    <id>http://yangfch3.com/2018/04/22/log4js-with-pm2/</id>
    <published>2018-04-22T08:44:11.000Z</published>
    <updated>2018-04-23T01:03:29.778Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你是在使用 <code>pm2</code> 和 <code>log4js</code> 中踩到了坑才会搜素到这篇文章，我便假定你已经对二者都有了基本的了解，遂不再赘述二者的介绍。</p><p><code>pm2</code> 在使用 <code>cluster</code> 模式部署应用时，服务都通过 <code>worker</code> 进程提供，<code>pm2</code> 做为 <code>master</code> 进行监控管理。</p><img src="/2018/04/22/log4js-with-pm2/pm2.png" alt="pm2" title="pm2"><p>由于存在多个 <code>worker</code> 进程，那么我们在使用 <code>log4js</code> 进行日志记录时会有下列疑问：</p><ol><li>多个 <code>worker</code> 进程能否正常写入同一个日志文件</li><li>要实现 1，<code>pm2</code> 需要作何处理，<code>log4js</code> 需要作何处理</li></ol><a id="more"></a><h2 id="退而求其次：多进程分日志？">退而求其次：多进程分日志？</h2><p>首先来尝试“逃避”上面的两个问题。</p><p>要“逃避”上面疑问最简易的方案就是：每个进程写入自己的日志文件（例如：<code>robotService-worker&lt;id&gt;.log</code>）。只需要对 <code>log4js</code> 做一下简易的设置即可实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    disableClustering: <span class="literal">true</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方案带来了<strong>日志分散、查阅与处理不方便</strong>的问题，一般情况下不采用。此方案较为经典的使用场景是 <code>pomelo</code> 的多进程游戏日志采集（但 <code>pomelo</code> 不是使用 <code>cluster</code> 来搭建集群）。</p><h2 id="log4js-与-pm2-相关源码">log4js 与 pm2 相关源码</h2><p><code>lib/log4js</code> 下的 <code>getLogger</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Get a logger instance.</span></div><div class="line"><span class="comment"> * <span class="doctag">@static</span></span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> loggerCategoryName</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;Logger&#125; instance of logger for the category</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLogger</span><span class="params">(category)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) &#123;</div><div class="line">    configure(process.env.LOG4JS_CONFIG || defaultConfig);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> cat = category || <span class="string">'default'</span>;</div><div class="line">  debug(`creating logger <span class="keyword">as</span> $&#123;isMaster() ? <span class="string">'master'</span> : <span class="string">'worker'</span>&#125;`);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Logger((isMaster() ? sendLogEventToAppender : workerDispatch), cat);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说明 <code>log4js</code> 在 <code>cluster</code> 集群模式下与单进程模式（<strong><code>isMaster</code> 方法来区分</strong>）下获取 <code>logger</code> 的存在差异。我们关注到 <code>log4js</code> 在 <code>worker</code> 进程下执行的是 <strong><code>workerDispatch</code></strong>。</p><p>下面是 <code>isMaster</code> 的源码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPM2Master</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.pm2 &amp;&amp; process.env[<span class="built_in">config</span>.pm2InstanceVar] === <span class="string">'0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMaster</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.disableClustering || cluster.isMaster || isPM2Master();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说明 <code>log4js</code> 对普通的 <code>cluster</code> 模式和 <code>pm2</code> 的 <code>cluster</code> 模式又做了区分。我们留意到有两个可配置项：<code>pm2</code> <code>pm2InstanceVar</code>，可以查看 <code>log4js</code> 的<a href="https://log4js-node.github.io/log4js-node/api.html" target="_blank" rel="external">文档</a>了解这两个配置项。</p><p>继续看 <code>workerDispatch</code> 的源码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">function</span> <span class="selector-tag">workerDispatch</span>(logEvent) &#123;</div><div class="line">  <span class="selector-tag">debug</span>(<span class="built_in">`sending message to master from worker $&#123;process.pid&#125;`</span>);</div><div class="line">  <span class="selector-tag">process</span><span class="selector-class">.send</span>(&#123; <span class="attribute">topic</span>: <span class="string">'log4js:message'</span>, <span class="attribute">data</span>: serialise(logEvent) &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以得知：<strong>在 pm2 cluster 模式下，<code>log4js</code> 不在 worker 进程直接记录日志，而是将需要记录日志的消息发送给 <code>master</code> 进程。</strong></p><p><code>log4js</code> 既然有发送消息的代码，那肯定有接收消息的代码，下面是接收消息的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">configurationFileOrObject</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> configObject = configurationFileOrObject;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> configObject === <span class="string">'string'</span>) &#123;</div><div class="line">    configObject = loadConfigurationFile(configurationFileOrObject);</div><div class="line">  &#125;</div><div class="line">  debug(<span class="string">`Configuration is <span class="subst">$&#123;configObject&#125;</span>`</span>);</div><div class="line">  config = <span class="keyword">new</span> Configuration(configObject);</div><div class="line">  <span class="built_in">module</span>.exports.levels = config.levels;</div><div class="line">  <span class="keyword">const</span> loggerModule = logger(config.levels, levelForCategory, setLevelForCategory);</div><div class="line">  Logger = loggerModule.Logger;</div><div class="line">  LoggingEvent = loggerModule.LoggingEvent;</div><div class="line">  <span class="built_in">module</span>.exports.connectLogger = connectModule(config.levels).connectLogger;</div><div class="line"></div><div class="line">  <span class="comment">// just in case configure is called after shutdown</span></div><div class="line">  process.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  <span class="keyword">if</span> (cluster) &#123;</div><div class="line">    cluster.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (config.disableClustering) &#123;</div><div class="line">    debug(<span class="string">'Not listening for cluster messages, because clustering disabled.'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPM2Master()) &#123;</div><div class="line">    <span class="comment">// PM2 cluster support</span></div><div class="line">    <span class="comment">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></div><div class="line">    <span class="comment">// we only want one of the app instances to write logs</span></div><div class="line">    debug(<span class="string">'listening for PM2 broadcast messages'</span>);</div><div class="line">    process.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isMaster) &#123;</div><div class="line">    debug(<span class="string">'listening for cluster messages'</span>);</div><div class="line">    cluster.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    debug(<span class="string">'not listening for messages, because we are not a master process'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  enabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> log4js;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// in a multi-process node environment, worker loggers will use</span></div><div class="line"><span class="comment">// process.send</span></div><div class="line"><span class="keyword">const</span> receiver = <span class="function">(<span class="params">worker, message</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// prior to node v6, the worker parameter was not passed (args were message, handle)</span></div><div class="line">  debug(<span class="string">'cluster message received from worker '</span>, worker, <span class="string">': '</span>, message);</div><div class="line">  <span class="keyword">if</span> (worker.topic &amp;&amp; worker.data) &#123;</div><div class="line">    message = worker;</div><div class="line">    worker = <span class="literal">undefined</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (message &amp;&amp; message.topic &amp;&amp; message.topic === <span class="string">'log4js:message'</span>) &#123;</div><div class="line">    debug(<span class="string">'received message: '</span>, message.data);</div><div class="line">    sendLogEventToAppender(deserialise(message.data));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendLogEventToAppender</span>(<span class="params">logEvent</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span>;</div><div class="line">  debug(<span class="string">'Received log event '</span>, logEvent);</div><div class="line">  <span class="keyword">const</span> appenders = appendersForCategory(logEvent.categoryName);</div><div class="line">  appenders.forEach(<span class="function">(<span class="params">appender</span>) =&gt;</span> &#123;</div><div class="line">    appender(logEvent);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是日志是由 <code>worker</code> --①–&gt; pm2 <code>master</code> --②–&gt; <code>worker</code> 进行的传递，其思路就是日志只由一个 <code>worker</code> 去记录。<strong>而 ② 处的转发以及选择哪一个 <code>worker</code> 去接收就需要 <code>pm2-intercom</code> 这个 pm2 的 module 来处理了。</strong></p><h2 id="结论">结论</h2><p>要解决前言中的两个疑问，可以这样做：</p><ol><li><code>pm2</code> 安装 <code>pm2 install pm2-intercom</code></li><li><code>log4js</code> 启用以下配置： <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    pm2: <span class="literal">true</span></div><div class="line">    <span class="string">//</span> <span class="string">...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="结束了？">结束了？</h2><p>没有。</p><p>在上面的代码中我们发现 <code>isPM2Master</code> 的判断中有这样一句代码：<code>process.env[config.pm2InstanceVar] === '0'</code>。</p><p>我们查阅 <code>pm2</code> 的<a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="external">文档</a>发现，<code>pm2</code> 的进程都是有编号的，默认使用 <code>NODE_APP_INSTANCE</code> 环境变量（<strong>可以自己配置指定</strong>）上标识是 <code>master</code>（=== ‘0’） 还是 <code>worker</code>。<code>log4js</code> 也是根据这个特征来实现 <code>isPM2Master</code> 检测。</p><p>但是 <code>pm2</code> 不一定使用默认的 <code>NODE_APP_INSTANCE</code> 环境变量来编号，可能会变化——可能是用户自己定义了其他名称（例如<code>node-config</code> 将这个环境变量字段占用了，<code>pm2</code> 只能改用其他的），所以当 <code>pm2</code> 改变了字段名时，<code>log4js</code> 要做相应的配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attribute">pm2InstanceVar</span>: <span class="string">'INSTANCE_ID'</span>; <span class="comment">// 默认 NODE_APP_INSTANCE，与 pm2 的配置保持一致即可</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="附赠：单机多-pm2-实例">附赠：单机多 pm2 实例</h2><p>一台机器上可以部署多个 pm2 实例，这在我们需要再一台机器上部署多个不同的服务时可以用到，例如我们可能同时在一台机器上部署 <code>web-server</code> 和 <code>api-server</code>（因为机器紧张等原因）。</p><p>当我们第一次调用 <code>pm2</code> 时，我们会发现 <code>$HOME/.pm2</code> 目录被创建，里面存储着**（该）<code>pm2</code> 实例**的运行信息和日志输出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm2 start app<span class="selector-class">.js</span> -<span class="selector-tag">i</span> <span class="number">3</span> --name=web-server</div></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># pwd</span></div><div class="line">/home/admin/.pm2</div><div class="line"></div><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># ls -a -l</span></div><div class="line">total 72</div><div class="line">drwxrwxr-x  <span class="number"> 5 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:19 .</div><div class="line">drwx------.<span class="number"> 12 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 11 </span>09:53 ..</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:20 logs</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin  <span class="number"> 127 </span>Mar<span class="number"> 28 </span>20:58 module_conf.json</div><div class="line">drwxrwxr-x  <span class="number"> 3 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 28 </span>20:55 modules</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 16 </span>15:24 pids</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin<span class="number"> 34054 </span>Apr<span class="number"> 16 </span>15:24 pm2.log</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin    <span class="number"> 4 </span>Mar<span class="number"> 29 </span>17:19 pm2.pid</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 pub.sock</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 rpc.sock</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin   <span class="number"> 13 </span>Mar<span class="number"> 24 </span>15:12 touch</div></pre></td></tr></table></figure><p>所以要创建多个 <code>pm2</code> 实例就需要每个实例使用不同的目录来存储运行信息。<code>pm2</code> 使用 <code>PM2_HOME</code> 环境变量来识别存储运行信息的目录：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 start app.js -i --name=web-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 web-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 list</div></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 start app.js -i --name=api-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 api-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 list</div></pre></td></tr></table></figure><p>为特定的 <code>pm2</code> 实例安装模块：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 install pm2-intercom</div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 install pm2-intercom</div></pre></td></tr></table></figure><p>Tip：pm2 模块的安装可以不使用线上下载安装的方式（例如不方便执行 <code>pm2 install</code> 操作时），你只需要将模块放到 <code>modules</code> 目录下，然后修改 <code>module_conf.json</code> 注册模块即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dump.pm2</div><div class="line">├── dump<span class="selector-class">.pm2</span><span class="selector-class">.bak</span></div><div class="line">├── logs</div><div class="line">├── module_conf.json</div><div class="line">├── modules</div><div class="line">│   └── pm2-intercom</div><div class="line">│       ├── etc</div><div class="line">│       ├── node_modules</div><div class="line">│       └── package-lock.json</div><div class="line">├── pids</div><div class="line">├── pm2.log</div><div class="line">├── pm2.pid</div><div class="line">├── pub.sock</div><div class="line">├── rpc.sock</div><div class="line">└── touch</div></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// module_conf.json</div><div class="line">&#123;</div><div class="line">    <span class="string">"pm2-intercom"</span>: &#123;</div><div class="line">        <span class="string">"default-strategy"</span>: <span class="string">"broadcast"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"module-db-v2"</span>: &#123;</div><div class="line">        <span class="string">"pm2-intercom"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信你是在使用 &lt;code&gt;pm2&lt;/code&gt; 和 &lt;code&gt;log4js&lt;/code&gt; 中踩到了坑才会搜素到这篇文章，我便假定你已经对二者都有了基本的了解，遂不再赘述二者的介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pm2&lt;/code&gt; 在使用 &lt;code&gt;cluster&lt;/code&gt; 模式部署应用时，服务都通过 &lt;code&gt;worker&lt;/code&gt; 进程提供，&lt;code&gt;pm2&lt;/code&gt; 做为 &lt;code&gt;master&lt;/code&gt; 进行监控管理。&lt;/p&gt;
&lt;img src=&quot;/2018/04/22/log4js-with-pm2/pm2.png&quot; alt=&quot;pm2&quot; title=&quot;pm2&quot;&gt;
&lt;p&gt;由于存在多个 &lt;code&gt;worker&lt;/code&gt; 进程，那么我们在使用 &lt;code&gt;log4js&lt;/code&gt; 进行日志记录时会有下列疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个 &lt;code&gt;worker&lt;/code&gt; 进程能否正常写入同一个日志文件&lt;/li&gt;
&lt;li&gt;要实现 1，&lt;code&gt;pm2&lt;/code&gt; 需要作何处理，&lt;code&gt;log4js&lt;/code&gt; 需要作何处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="库与工具" scheme="http://yangfch3.com/categories/%E5%BA%93%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pm2" scheme="http://yangfch3.com/tags/pm2/"/>
    
      <category term="log4js" scheme="http://yangfch3.com/tags/log4js/"/>
    
  </entry>
  
  <entry>
    <title>细说 S.O.L.I.D</title>
    <link href="http://yangfch3.com/2017/11/05/SOLID/"/>
    <id>http://yangfch3.com/2017/11/05/SOLID/</id>
    <published>2017-11-05T10:18:01.000Z</published>
    <updated>2017-11-05T10:27:57.772Z</updated>
    
    <content type="html"><![CDATA[<p><code>S.O.L.I.D</code> 五原则（以下简称五原则）：</p><ul><li><strong>单一功能原则</strong></li><li><strong>开放封闭原则</strong></li><li><strong>里氏替换原则</strong></li><li><strong>接口隔离原则</strong></li><li><strong>依赖反转原则</strong>。</li></ul><a id="more"></a><p><img src="http://static.zybuluo.com/yangfch3/1vhmouqgjzw983ftbiuqlyoi/image_1bqcv642t1bj01a041g0udcae4l9.png" alt="image_1bqcv642t1bj01a041g0udcae4l9.png-40kB"></p><p><code>S.O.L.I.D</code> 做为面向对象编程和面向对象设计的五个基本原则，在面向对象的软件开发史上做为“最佳实践”指导着人们开发出代码清晰可读、容易维护和扩展的系统。</p><p><code>S.O.L.I.D</code> 由 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="external">Robert C. Martin (Uncle Bob)</a> 总结提出。</p><h2 id="code-rot">Code rot</h2><p><img src="http://static.zybuluo.com/yangfch3/1dl9j3ppshabajdnq3ujua8k/image_1bu3f0pemstn1htf3bl1v9l157719.png" alt="image_1bu3f0pemstn1htf3bl1v9l157719.png-257.2kB"><br>什么样的代码是烂代码呢？如何识别将来可能会演变成烂代码的代码呢？</p><ol><li><strong>刚性</strong>：小改变导致整个系统重写</li><li><strong>脆弱性</strong>：一个模块的改变导致其他不相关模块行为变得不当，想象一下一台汽车因为电台的变动影响到了车窗的使用</li><li><strong>不可迁移性</strong>：一个模块的内部组件不能提取到新环境使用，原因是组件间的耦合与强依赖。规避策略是将中央抽象与 low-level 细节分离</li><li><strong>粘性</strong>：当构建和测试难以进行，需要花费大量的时间执行（例如：在充值处做了小改动，也需要花费时间去测试游戏各个环节能否正常运行）</li></ol><p>人们主要能体会到软件中的两类价值：</p><ol><li>帮助人们更好地做某件事，提高生产力，降低时间与金钱支出</li><li><strong>软件的行为表现</strong>：满足现阶段的用户需求，同时能频繁地变动以满足用户的需求变更，且没有 Bug 与崩溃。</li></ol><p>第一类价值的保证靠的的团队的产品等角色的发挥，而第二类价值的保证则需要工程师的软件架构设计来保证了，而 S.O.L.I.D 是应用最为广泛也最为基础的设计指导原则。</p><hr><h2 id="单一功能原则-rsp">单一功能原则 - RSP</h2><h3 id="解释">解释</h3><p>一个类或类似的结构只做一件事，只因为一个原因而发生变动</p><h3 id="详细阐述">详细阐述</h3><p>类的一切数据与方法都应该与这个单一的职责有关，即凝聚力。但这并不意味着你的类只能包含一个方法或属性。</p><h3 id="优点">优点</h3><ol><li>降低类的复杂度</li><li>提高可维护性</li><li>提高可读性</li><li>降低需求变化带来的风险</li></ol><h3 id="示例">示例</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// <span class="type">Not</span> good, **<span class="number">3</span>** responsibility</div><div class="line">class <span class="type">Employee</span> &#123;</div><div class="line">    public <span class="type">Pay</span> calculatePay() <span class="meta">&#123;...&#125;</span> <span class="comment"># 1) calculation logic</span></div><div class="line">    public <span class="built_in">void</span> save() <span class="meta">&#123;...&#125;</span> <span class="comment"># 2) database logic</span></div><div class="line">    public <span class="type">String</span> describeEmployee() <span class="meta">&#123;...&#125;</span> <span class="comment"># 3) reporting logic</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Modem 类的设计改进：<br><img src="http://static.zybuluo.com/yangfch3/fhc0rg3c34qz6utayxdxgdsx/image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png" alt="image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png-9.4kB"> =&gt; <img src="http://static.zybuluo.com/yangfch3/op876brznpgc56yawj4dsu1f/image_1bu4tvpgf1nfi2giv6bqjd1apb23.png" alt="image_1bu4tvpgf1nfi2giv6bqjd1apb23.png-28.1kB"></p><hr><h2 id="开放封闭原则-ocp">开放封闭原则 - OCP</h2><h3 id="解释-v2">解释</h3><p>软件中的对象（类，模块，函数等等）对扩展开放，对修改封闭。</p><h3 id="详细阐述-v2">详细阐述</h3><p>现有代码应该只在下面三种情况进行 <strong>修改</strong>：</p><ol><li>现有代码里有 Bug 或错误</li><li>现有代码实现的需求发生了变动（例如之前确定的算法或逻辑发生了改变）</li></ol><p>下面情况不应该需要改变现有代码，而能通过<strong>继承</strong>、<strong>多态</strong>来进行 <strong>扩展</strong> 即可变更软件的行为：</p><ol><li>以前做过可预测的同类需求。例如在员工管理系统中需要新增一个员工类型，支付系统需要新增一种支付方式</li></ol><p>通常的实现方法：<strong>对抽象编程，而不对具体编程；使用抽象类或接口，而不是使用具体的类；新功能的的增加通过实现继承抽象类或实现接口，而非改变已有代码来完成。</strong></p><p><strong>只有在将会发生的变化是可预测的情况下，OCP 才会有所帮助，所以你应当只有在类似的变化已经发生过的情况下使用它。</strong></p><h3 id="优点-v2">优点</h3><ol><li>扩展新功能时不容易引入新 Bug</li><li>新的功能添加无需对全部代码进行代码审查、单元测试</li><li>代码稳定性</li><li>解耦，增加弹性</li></ol><h3 id="实例">实例</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 不难预料，将来可能支持除现金之外的收款方式</span></div><div class="line"><span class="comment"> * 这里直接写死成 acceptCash</span></div><div class="line"><span class="comment"> */</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将来需要新增一种收款方式，可能会被改成这样</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p;</div><div class="line">  <span class="keyword">if</span> (credit)</div><div class="line">    p = acceptCredit(<span class="keyword">total</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PaymentMethod</span> &#123;<span class="function"><span class="keyword">void</span> <span class="title">acceptPayment</span>(<span class="params">Money total</span>)</span>;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkOut</span>(<span class="params">Receipt receipt, PaymentMethod pm</span>) </span>&#123;</div><div class="line">  Money total = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    total += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = pm.acceptPayment(total);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="里氏替换原则-lsp">里氏替换原则 - LSP</h2><h3 id="解释-v3">解释</h3><p>任何基类可以出现的地方，子类一定可以出现。所有子类需要按照其基本类别的方式进行操作。子类可以扩展父类的功能，但不能改变父类原有的行为预期。</p><h3 id="详细阐述-v3">详细阐述</h3><p>Liskov 提出的关于继承的原则：<strong>继承必须确保超类中所拥有的属性与方法在子类中仍然拥有</strong>。</p><p>Robert C. Martin 提出了更抽象的简化：<strong>子类必须能够替换成他们的基类</strong>。这也是里氏替换原则的精髓。</p><p>LSP 是继承复用的基石，只有当子类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而子类也可以在基类的基础上增加新的行为。</p><p>一般来说，如果超类的子类型做了超类的客户端所不期望的事情，那么这违背了 LSP。设想一个派生类抛出一个异常，超类不抛出，或者如果一个派生类有一些意想不到的副作用。</p><p>更具有指导意义的详细规范：</p><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ol><h3 id="优点-v3">优点</h3><ol><li>里氏替换原则是实现开放封闭原则的具体规范</li><li>见开放封闭原则的优缺点</li></ol><h3 id="示例-v2">示例</h3><p>见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html" target="_blank" rel="external">链接</a></p><hr><h2 id="接口隔离原则-isp">接口隔离原则 - ISP</h2><h3 id="解释-v4">解释</h3><p>一个类不应该被强制依赖它不需要的接口成员。多个小的、特定的、具有内聚性的客户端接口要好于单个宽泛用途的、内聚性差的接口。</p><h3 id="详细阐述-v4">详细阐述</h3><p>与单一职责原则的不同点：</p><ol><li>单一职责原则注重的是对象的职责；而接口隔离原则注重对接口依赖的隔离</li><li>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</li></ol><p>接口的粒度需要我们自己去把控，接口的粒度过小会造成接口数量过多，设计复杂化；接口粒度过大，就很容易违背接口隔离原则。</p><p>另见下方示例</p><h3 id="优点-v4">优点</h3><ol><li>灵活性</li><li>避免接口臃肿</li></ol><h3 id="示例-v3">示例</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">Messenger</span> &#123;</div><div class="line">  <span class="selector-tag">askForCard</span>();</div><div class="line">  <span class="selector-tag">tellInvalidCard</span>();</div><div class="line">  <span class="selector-tag">askForPin</span>();</div><div class="line">  <span class="selector-tag">tellInvalidPin</span>();</div><div class="line">  <span class="selector-tag">tellCardWasSiezed</span>();</div><div class="line">  <span class="selector-tag">askForAccount</span>();</div><div class="line">  <span class="selector-tag">tellNotEnoughMoneyInAccount</span>();</div><div class="line">  <span class="selector-tag">tellAmountDeposited</span>();</div><div class="line">  <span class="selector-tag">tellBalance</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginMessenger</span> </span>&#123;</div><div class="line">  askForCard();</div><div class="line">  tellInvalidCard();</div><div class="line">  askForPin();</div><div class="line">  tellInvalidPin();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  tellNotEnoughMoneyInAccount();</div><div class="line">  askForFeeConfirmation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">publc <span class="class"><span class="keyword">class</span> <span class="title">EnglishMessenger</span> <span class="keyword">implements</span> <span class="title">LoginMessenger</span>, <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="依赖反转原则-dip">依赖反转原则 - DIP</h2><h3 id="解释-v5">解释</h3><ol><li>高层模块不应该依赖低层模块，所有模块都应该依赖抽象</li><li>抽象不应该依赖细节/具体</li><li>细节/具体应该依赖抽象</li></ol><h3 id="详细阐述-v5">详细阐述</h3><p>什么是依赖？</p><blockquote><p>不是我自身的，却是我需要的，都是我所依赖的。<br>我若依赖你，我就不能离开你。</p></blockquote><p>什么是高层模块？什么是低层模块？</p><blockquote><p>类 A 直接依赖于类 B，假如要将类 A 修改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑。类 B 和 C 是底层模块，负责基本的原子操作。</p></blockquote><p>什么是抽象？什么是细节？</p><blockquote><p>抽象：抽象类或接口<br>细节：具体的实现类或实现方法</p></blockquote><p>这里的依赖是什么？反转后的依赖变成了什么？</p><blockquote><p>这里的依赖原本指高层模块对低层模块的依赖，倒置的依赖演变成实现类对接口或抽象类的依赖</p></blockquote><p>反转怎么理解？</p><blockquote><p>由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。</p></blockquote><p><img src="http://static.zybuluo.com/yangfch3/dmo4sdqgvlw6uaa0a1eljgjm/image_1bu57m1gtbj8122q11etnn75gm2g.png" alt=""></p><h3 id="优点-v5">优点</h3><ol><li>松散耦合</li><li>多人开发，提取模块的抽象，可以进行多人并行开发</li><li>违背了依赖反转原则，那么开放封闭原则也就无法实行</li></ol><h3 id="示例-v4">示例</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块 A</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> &#123;</span> <span class="keyword">char</span> getchar(); &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> &#123;</span> <span class="keyword">void</span> putchar(<span class="keyword">char</span> c)&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharCopier</span> &#123;</span></div><div class="line">  <span class="keyword">void</span> copy(Reader reader, Writer writer) &#123;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">while</span> ((c = reader.getchar()) != EOF) &#123;</div><div class="line">      writer.putchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模块 B</span></div><div class="line"><span class="keyword">public</span> Keyboard <span class="keyword">implements</span> Reader &#123;...&#125;</div><div class="line"><span class="keyword">public</span> Printer <span class="keyword">implements</span> Writer &#123;…&#125;</div><div class="line"></div><div class="line"><span class="comment">// 应用</span></div><div class="line">...</div><div class="line"><span class="keyword">new</span> CharCopier(<span class="keyword">new</span> Keyboard(), <span class="keyword">new</span> Writer());</div></pre></td></tr></table></figure><p>或见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html" target="_blank" rel="external">链接</a></p><h3 id="说明">说明</h3><p>依赖倒置原则的核心就是 <strong>面向接口编程的思想</strong>，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。但是这个原则也是 5 个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p><p>依赖倒置原则或者说面向接口编程的思想催生了许多经典的设计模式，欲细究可自行深入研究面向接口编程。</p><hr><p>参考资料：<br><a href="https://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/" target="_blank" rel="external">Object-oriented design principles and the 5 ways of creating SOLID applications</a><br><a href="http://www.cnblogs.com/hellojava/category/431379.html" target="_blank" rel="external">http://www.cnblogs.com/hellojava/category/431379.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;S.O.L.I.D&lt;/code&gt; 五原则（以下简称五原则）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单一功能原则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放封闭原则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖反转原则&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://yangfch3.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Design Patterns" scheme="http://yangfch3.com/tags/Design-Patterns/"/>
    
      <category term="OOP" scheme="http://yangfch3.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Web 缓存及策略制定</title>
    <link href="http://yangfch3.com/2017/10/19/HTTP-Cache/"/>
    <id>http://yangfch3.com/2017/10/19/HTTP-Cache/</id>
    <published>2017-10-19T01:32:19.000Z</published>
    <updated>2018-04-23T01:03:29.777Z</updated>
    
    <content type="html"><![CDATA[<p>我们常常会注意到静态资源后面都跟着一串指纹码：<br><img src="http://static.zybuluo.com/yangfch3/8m3e3wnqpmxwhztq755quy1w/image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png" alt="image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png-20.6kB"><br><img src="http://static.zybuluo.com/yangfch3/kp4cmtg8o50i34lh501vlhf3/image_1b1c9gujm10snq8f947iv5t49.png" alt="image_1b1c9gujm10snq8f947iv5t49.png-28.4kB"><br><img src="http://static.zybuluo.com/yangfch3/s3aubu6l1ylr6igytpuv18y6/image_1b1c9jtvr1aogmd0seg1o0714lu13.png" alt="image_1b1c9jtvr1aogmd0seg1o0714lu13.png-15.8kB"><br><img src="http://static.zybuluo.com/yangfch3/44bhvo0c8c89lggd60uyyhqn/image_1b1c9of7qf6b1abfvmp1er12801g.png" alt="image_1b1c9of7qf6b1abfvmp1er12801g.png-17.2kB"></p><p>同时我们在进行网络请求分析时会遇到 Cache-Control、Last-Modified 等这些 Header 字段。</p><p>在冥冥中，我们知道这些肯定与缓存有着重大的关系。缓存机制中有哪些关键的东西在起作用，如何制定最优的 <strong>缓存-更新</strong> 机制就是本文需要研究的问题。</p><a id="more"></a><h2 id="前言">前言</h2><p>首先让我们来看一次经典的 <strong>请求-响应</strong> 过程，以 <a href="https://zhihu.com" target="_blank" rel="external">zhihu.com</a> 登录页的某个 JavaScript 资源为例：<br><img src="http://static.zybuluo.com/yangfch3/0gotv3wpms8o77advh2x4jqn/image_1b1cacu1n1b4019s61jo816fj5ud1t.png" alt="image_1b1cacu1n1b4019s61jo816fj5ud1t.png-586.8kB"></p><p>我们从这次连接中看到以下与缓存相关的 HTTP(s) 请求头/响应头：</p><ul><li>Request Header<ol><li>Cache-Control</li><li>If-Modified-Since</li><li>If-None-Match</li></ol></li><li>Response Header<ol><li>Cache-Control（图上没有体现）</li><li>Last-Modified</li><li>ETag</li></ol></li></ul><p>一般，我们请求的缓存就是由上述 HTTP Header 进行<strong>校验</strong>与<strong>控制</strong>。是否需要缓存？缓存层级？缓存多久？缓存到期后如何处理？这些问题就是接下来的文章需要解决的。</p><h2 id="etag-if-none-match">ETag &amp; If-None-Match</h2><p>ETag 我们可以很形象地称之为<strong>验证令牌</strong>，这个令牌在<strong>缓存不符合我们的 Cache-Control 指定的规则</strong> 时起作用。</p><p>ETag 由服务器生成，由 Response Header 携带传送给客户端进行保存，客户端请求 Request Header 通过 If-None-Match 携带缓存的 ETag 值给服务器进行校验。</p><blockquote><p>ETag 是 Response Header 的字段，If-None-Match 是 Request Header 的字段，因为二者功能协作且字段值一致，下面统一用 ETag 代替。</p></blockquote><p>假如我们有如下静态资源，请求细节如下：<br><img src="http://static.zybuluo.com/yangfch3/95pdeafw683dqhtwj8ymhnpp/image_1b1cbv67c17de1kdb16rce9mtk2a.png" alt="image_1b1cbv67c17de1kdb16rce9mtk2a.png-18.4kB"></p><p>现在过了 120 秒，浏览器又对该资源发起了请求。</p><p>首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应缓存的文件现在已经“过期”，不能直接使用。此时，浏览器可以直接发出新请求，获取新的完整响应，<strong>但是这样做效率较低，因为如果本地缓存已过期，但服务器上资源在此期间未被更改过，我们就没有理由再去下载一遍</strong>。</p><p>这就是 ETag 头中指定的验证令牌所要解决的<em>问题</em><sup>1</sup>：服务器会生成并返回一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码（具体实现细节由服务器决定）。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其（通过 If-None-Match 携带）发送给服务器：如果指纹码仍然一致，说明资源未被修改，我们就可以跳过下载，继续延长 Cache-Control（120s）。</p><blockquote><p>1：如果资源未被更改过，我们就没有理由再去下载与客户端缓存中已有的完全相同的资源。</p></blockquote><p>总结以上内容就是：</p><ol><li>ETag 在缓存过期（过了 Cache-Control 指定期限）之后起作用的</li><li>ETag 在缓存过期后判定是对缓存<strong>续命</strong>还是<strong>更新</strong></li></ol><h2 id="last-modified-if-modified-since">Last-Modified &amp; If-Modified-Since</h2><p>其实在 ETag 出现之前，就有了 Last-Modified/If-Modified-Since 验证机制。使用资源的最近一次更新时间（Last-Modified）进行校验是最符合我们日常认知的，也是最容易想到的一种方式。</p><blockquote><p>Last-Modified 是 Response Header 的字段<br>If-Modified-Since 是 Request Header 的字段</p></blockquote><p>ETag 的出现是对 Last-Modified 机制的补充与严谨化。</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存（而 ETag 是依据文件内容特征生成的指纹，能更精确地表示文件有无变化）</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul><p>Last-Modified 与 ETag 一起使用时，服务器会<strong>优先验证 ETag</strong>，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p><h2 id="cache-control">Cache-Control</h2><p><code>Cache-Control</code> 有一个比较特殊的点：Request Header 有此字段，Response Header 也有这个字段。</p><h3 id="max-age-num">max-age=[num]</h3><p>服务器返回头 Cache-Control 的 max-age 告诉客户端：<strong>此资源在客户端缓存时间为多久</strong>。</p><p>而比较特殊的 max-age=0 则相当于告知客户端：<strong>此资源刻意缓存在客户端，但每次重新请求都应该向服务器请求校验</strong>。</p><ol><li>服务器首次返回一个 max-age=0 的静态资源，客户端缓存到本地</li><li>客户端需要重新请求此静态资源时，发现本地有缓存，但是缓存已过期（因为 max-age=0）</li><li>客户端重新发送请求，携带 If-None-Match 头以及 max-age=0</li><li>服务端将收到的 If-None-Match 与文件的 ETag 比对</li><li>如果比对不一致，则下发静态资源，同时返回 Cache-Control 头和新的 ETag，客户端比对本地的 ETag 与返回的 ETag 后使用新的资源，并回到步骤 1</li><li>如果比对一致，则不下发返回静态资源，同时返回 Cache-Control 头和没变的 ETag，客户端比对本地的 ETag 与返回的 ETag 后直接使用缓存</li></ol><h3 id="no-cache">no-cache</h3><p>Response Header 的 no-cache 和 max-age=0 作用你可以将其等同起来。</p><p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#no-cacheno-store" target="_blank" rel="external">链接1</a><br><a href="https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">链接2</a></p><ol><li>no-cache 不代表禁止客户端缓存</li><li>no-cache 不是不缓存，而是不直接使用缓存（需要验证）</li></ol><blockquote><p>I believe max-age=0 simply tells caches (and user agents) the response is stale from the get-go and so they SHOULD revalidate the response (eg. with the If-Not-Modified header) before using a cached copy, whereas, no-cache tells them they MUST revalidate before using a cached copy.</p></blockquote><p><code>Cache-Control: max-age=0</code> 与 <code>Cache-Control: no-cache</code> 可能存在的不同点是：可能在点击浏览器的前进后退按钮时会存在差异。<code>Cache-Control: max-age=0</code> 可以直接使用，而 <code>Cache-Control: no-cache</code> 则会验证。</p><p>还有一个问题时，在某些版本的浏览器下，客户端对 no-cache 与 no-store 的处理是一样的：都是直接不缓存。</p><p>no-cache 在 Request Header 的作用则比较简单：告诉服务器，本地没有缓存或不使用缓存，你需要给我最新的文件。Chrome 下的强制刷新以及 Disable Cache 采取的就是在 Request Header 使用 no-cache。</p><h3 id="no-store">no-store</h3><p><code>Cache-Control: no-store</code> 直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</p><h3 id="public-private">public &amp; private</h3><p>服务器返回的 Cache-Control Header 如果有 public 字段，则表示可以多级缓存（用户代理、CDN、服务提供商）。</p><p>private 则表示单用户缓存，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是中间服务商不能缓存。</p><h2 id="实例：express-req-fresh-的判定机制">实例：Express req.fresh 的判定机制</h2><p>Express 中 req.fresh 用于判定客户端的请求是否是“新鲜”的请求（而不是对已缓存资源的请求），只有当请求头的 <code>cache-control</code> 不等于 <code>no-cache</code> 并且满足以下任意一条才表示客户端的请求是“新鲜”的（即服务器需要提供新资源）：</p><blockquote><ul><li>指定了 <code>if-modified-since</code> 请求头并且 <code>last-modified</code> 请求头等于或时间上早于 <code>modified</code> 响应头</li><li><code>if-none-match</code> 请求头是 <code>*</code></li><li><code>if-none-match</code> 请求头无法匹配响应头的 <code>etag</code></li></ul></blockquote><h2 id="http-caching-最佳实践">HTTP Caching 最佳实践</h2><p><img src="http://static.zybuluo.com/yangfch3/jwinkxrha3w4bkgq59kgr89f/image_1b1ciceslctp1ho2ib1rvf1evj2n.png" alt="image_1b1ciceslctp1ho2ib1rvf1evj2n.png-47.8kB"></p><h2 id="缓存与频繁更新的矛盾">缓存与频繁更新的矛盾</h2><p>有些资源是需要频繁更新的，但是我们又确实希望客户端对其进行缓存。此时我们就需要<strong>针对我们资源的特性制定不同的缓存策略与缓存级别</strong>，并使用<strong>资源指纹 URL</strong>搭配实现资源的随意更新。</p><p>于是我们可以看回本文开始部分介绍的几个典型网站静态资源的指纹URL案例：</p><ol><li>index.xxxxxxx.js</li><li>index$xxxxxx.js</li><li>index-xxxxxxx.js</li><li>/index.js?x.x.x</li></ol><p>上面的 <code>x</code> 即为指纹区，选择何种指纹视项目与团队规范而定。</p><p><strong>指纹 URL + Cache-Control</strong> 实现缓存与更新的精细控制案例：<br><img src="http://static.zybuluo.com/yangfch3/0achbqbncuy3hdfar6l5thm7/image_1b1cj198v4itmue1ishdsecbj34.png" alt="image_1b1cj198v4itmue1ishdsecbj34.png-29.7kB"></p><p>分析一下上面的例子：</p><ul><li>HTML 被标记成 <code>no-cache</code>（或 <code>max-age=0</code>），这意味着浏览器在每次请求时都会重新验证文档，如果内容更改，会获取最新版本。同时，在 HTML 标记中，我们<strong>在 CSS 和 JavaScript 资源的网址中嵌入指纹码</strong>：如果这些文件的内容更改，网页的 HTML 也会随之更改，并将下载 HTML 响应的新副本。</li><li>允许浏览器和中继缓存（例如 CDN）缓存 CSS，过期时间设置为 1 年。注意，我们可以放心地使用 1 年的“远期过期”，因为我们在文件名中嵌入了文件指纹码：如果 CSS 更新，网址也会随之更改。</li><li>JavaScript 过期时间也设置为 1 年，但是被标记为 private，<strong>也许是因为包含了 CDN 不应缓存的一些用户私人数据</strong>。</li><li>缓存图片时不包含版本或唯一指纹码（一般项目中也会包含指纹码），过期时间设置为 1 天。</li></ul><p>组合使用 <code>ETag</code>、<code>Cache-Control</code> 和唯一网址（指纹 URL），我们可以提供最佳的方案：<strong>较长的过期时间，控制可以缓存响应的位置，以及按需更新。</strong></p><h2 id="注意点">注意点</h2><ol><li><p>网址区分大小写</p></li><li><p>除了文中提到的这些 Header 字段，服务器还可以自己制定与实现一些辅助缓存机制的字段。如：<code>X-Cache</code> 这样。</p></li><li><p>如果在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保启用了 HTTP 缓存，并根据用途设置了合理的缓存大小，同时，确保缓存持久化。查看平台文档并确认您的设置！</p><blockquote><p>例如在微信内 Webview 的缓存就有一些比较特殊的地方，具体可阅读开发文档。</p></blockquote></li><li><p>在很多情况下我们还会在响应 Header 内遇到 Expires 字段，这是 HTTP 1.0 时的标准，主要是为了兼容较为老旧的浏览器。在 HTTP 1.1 中定义了 Cache-Control 代替 Expires。</p></li></ol><hr><p>参考资料：<br><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">Google: Web Fundamentals - HTTP Caching</a><br><a href="http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">What’s the difference between Cache-Control: max-age=0 and no-cache?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常常会注意到静态资源后面都跟着一串指纹码：&lt;br&gt;
&lt;img src=&quot;http://static.zybuluo.com/yangfch3/8m3e3wnqpmxwhztq755quy1w/image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png&quot; alt=&quot;image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png-20.6kB&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://static.zybuluo.com/yangfch3/kp4cmtg8o50i34lh501vlhf3/image_1b1c9gujm10snq8f947iv5t49.png&quot; alt=&quot;image_1b1c9gujm10snq8f947iv5t49.png-28.4kB&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://static.zybuluo.com/yangfch3/s3aubu6l1ylr6igytpuv18y6/image_1b1c9jtvr1aogmd0seg1o0714lu13.png&quot; alt=&quot;image_1b1c9jtvr1aogmd0seg1o0714lu13.png-15.8kB&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://static.zybuluo.com/yangfch3/44bhvo0c8c89lggd60uyyhqn/image_1b1c9of7qf6b1abfvmp1er12801g.png&quot; alt=&quot;image_1b1c9of7qf6b1abfvmp1er12801g.png-17.2kB&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时我们在进行网络请求分析时会遇到 Cache-Control、Last-Modified 等这些 Header 字段。&lt;/p&gt;
&lt;p&gt;在冥冥中，我们知道这些肯定与缓存有着重大的关系。缓存机制中有哪些关键的东西在起作用，如何制定最优的 &lt;strong&gt;缓存-更新&lt;/strong&gt; 机制就是本文需要研究的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="开发手册" scheme="http://yangfch3.com/categories/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="HTTP" scheme="http://yangfch3.com/tags/HTTP/"/>
    
      <category term="web cache" scheme="http://yangfch3.com/tags/web-cache/"/>
    
  </entry>
  
  <entry>
    <title>关于被删的旧文章</title>
    <link href="http://yangfch3.com/2017/09/21/new-beginning/"/>
    <id>http://yangfch3.com/2017/09/21/new-beginning/</id>
    <published>2017-09-21T06:09:09.000Z</published>
    <updated>2018-04-23T01:03:29.786Z</updated>
    
    <content type="html"><![CDATA[<p>受限于以前知识深度与广度，博客旧文章存在诸多谬误，在此为以前传播过错误的知识致歉。如果你是通过搜索引擎或其他文章的引用来到本站进入了 404 页面，而你又对已经删除的文章内容感兴趣，你可以与我联系（yangfch3#<a href="http://gmail.com" target="_blank" rel="external">gmail.com</a>）索要旧稿，我会修正旧稿错误后回复给你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;受限于以前知识深度与广度，博客旧文章存在诸多谬误，在此为以前传播过错误的知识致歉。如果你是通过搜索引擎或其他文章的引用来到本站进入了 404 页面，而你又对已经删除的文章内容感兴趣，你可以与我联系（yangfch3#&lt;a href=&quot;http://gmail.com&quot; ta
      
    
    </summary>
    
      <category term="其他" scheme="http://yangfch3.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://yangfch3.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
