<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>白鹭引擎游戏开发笔记</title>
      <link href="/2018/11/21/egret-dev-note1/"/>
      <url>/2018/11/21/egret-dev-note1/</url>
      <content type="html"><![CDATA[<p>在之前的文章 <a href="/2018/10/24/wx-minigame-dev-using-egret/" title="使用白鹭引擎开发微信小游戏的一些流程改进">使用白鹭引擎开发微信小游戏的一些流程改进</a> 中我介绍了基于白鹭引擎在开发微信小游戏中流程的一些改进方案，本文将介绍在开发 HTML5 游戏中遇到的一些切实的问题与解决方案。</p><a id="more"></a><h2 id="cacheasbitmap-的尺寸限制">cacheAsBitmap 的尺寸限制</h2><p>当我们对一个尺寸很大的显示对象使用 <code>cacheAsBitmap</code> 功能时，会发现在部分浏览器中（尤其是移动端浏览器中）可能会抛出错误：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebGL: INVALID_VALUE: texImage2D: <span class="literal">width</span> <span class="keyword">or</span> height <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span></span><br></pre></td></tr></table></figure><p>错误表示我们我们的 2D 位图宽度或高度超出了浏览器的限制。</p><p>据笔者测试，最新的 <code>Safari</code> —— iOS 12 —— 中<br><code>WebGL</code>/<code>Canvas</code> 能缓存的 2D 位图宽或高不能超过 <strong>4096</strong>。当我们的游戏是一个比较大的场景，我们又想对场景的不变部分做 <code>cacheAsBitmap</code> 时可能触发此问题。</p><p>要规避此问题，要么对大的场景做分块，要么不使用 <code>cacheAsBitmap</code></p><h2 id="利用事件机制解耦代码">利用事件机制解耦代码</h2><p>类与类或模块与模块之间的接口调用、状态传递在软件开发中时无法避免的，但是很多时候因为开发时间的限制或者自己的疏忽带来的模块之间的强耦合。</p><p>订阅-发布的设计模式较常用于模块间的解耦 —— 包括时间上（异步操作）的解耦与空间上的解耦，并且 <code>JavaScript</code> 本身其实也是一门基于事件驱动的语言。<code>egret.EventDispatcher</code> 是 egret 自带的事件派发器类，我们可以用它来实现模块间的解耦。尤其是当模块高度独立，模块有自身的生命周期（或特定时间/状态点），需要对外提供针这些时间/状态点的无侵入接口时最适合使用。</p><p>但是要注意下面这些问题：</p><ol><li>及时移除不再需要的事件监听函数，减轻内存负担</li><li>发布-订阅机制减少了模块/对象之间的联系，这也表示着我们在阅读代码/排查 Bug 时要摸清模块/对象之间的联系需要花费多一些功夫</li></ol><p>例如下图的例子：</p><img src="/2018/11/21/egret-dev-note1/coin-event-example.jpg" title="金币拉取与更新"><p>金币组件只需订阅金币变动的事件，金币数据在被 <code>set</code> 时派发金币变动的事件，这样我们便只需 <code>fetch</code> 到最新的金币数据然后更新金币数据即可，而无需再去调用方法变更金币视图。</p><p>此外，游戏中各种状态的切换（初始、准备、匹配、游戏中、游戏成功、游戏失败）通过事件的机制也能减少很多重复的代码，可以尝试使用。</p><h2 id="显示对象的层级">显示对象的层级</h2><p>显示对象就像一棵树，我们需要维护这棵树的枝叶，让这棵树正常的生长，否则仍由其狂乱生长，会成为长期开发与维护的噩梦。。</p><p>一般在游戏中都会有两种需要维护的显示对象：场景（<code>Scene</code>）与场景内的弹出层（<code>Layer</code>），场景之间的切换与恢复，弹出层之间的叠加与切换如果没有专门的管理代码会将你的游戏代码带向深渊。</p><p>下面是两个比较简单的 <code>Scene</code> 与 <code>Layer</code> 管理组件，能满足简单的游戏开发工作。</p><h3 id="scenemanager">SceneManager</h3><p>代码简单易懂，可以直接阅读代码：<a href="https://gist.github.com/yangfch3/30ba6b05e9f1f015a9c82aa10077dda0" target="_blank" rel="noopener">SceneManager</a></p><p>注意：上面的代码不包含场景间切换的资源管理，请自行实现</p><h3 id="layermanager">LayerManager</h3><p>弹出框管理：<a href="https://github.com/yangfch3/egret-LayerManager" target="_blank" rel="noopener">LayerManager</a></p><img src="/2018/11/21/egret-dev-note1/screenshot.gif" title="LayerManager"><h2 id="声音管理">声音管理</h2><p>白鹭通过持有音频播放后返回的 <code>SoundChannel</code> 对象来进行管理，其本身不提供对音频的集中式管理，例如：全局静音、全局音量调节等。</p><p><a href="https://gist.github.com/yangfch3/c00c3b14cd54937a878b5f5e0cdbc4f9" target="_blank" rel="noopener">SoundManager</a> 此组件包含了常用的音频管理功能，同时内置了缓存机制。</p><h2 id="图片跨域">图片跨域</h2><p>白鹭的 Canvas/WebGL 加载网络图片的原理都是使用 <code>Image</code> 对象，当使用的图片与当前域名不一致时会遇到跨域问题（浏览器出于内存安全的角度考虑）。白鹭的 <code>ImageLoader</code> 对象有一个 <code>crossOrigin</code> 属性，当 <code>imgLoader.crossOrigin = 'anonymous'</code> 来以匿名的方式访问时可以规避跨域问题，但是在使用 <code>texture.toDataURL</code> 时还会报跨域问题。</p><blockquote><p><code>imgLoader.crossOrigin = 'anonymous'</code> 表示对图片的请求不会携带 <code>cookies</code> 等用户信息，防止用户状态被不知情的情况下被使用；又由于纹理是存储在内存中的，WebGL 又是直接对内存的操作，所以为了防止内存的安全，跨域图片的 <code>texture.toDataURL</code> 不被允许。</p></blockquote><h2 id="微信小游戏场景下系列问题">微信小游戏场景下系列问题</h2><h3 id="重刷新机制">重刷新机制</h3><p>微信小游戏不能像在网页上一样刷新页面，在某些特定的情景下我们可能需要一个像网页刷新页面一样的刷新机制。所以我们需要提供一个刷新的接口，接口的主要工作是初始现有的软件状态、舞台上的显示对象，重新运行游戏的入口逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.ts</span></span><br><span class="line"><span class="comment">// 用于微信小游戏的刷新</span></span><br><span class="line"><span class="keyword">public</span> refresh() &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeChildren()</span><br><span class="line">    <span class="keyword">this</span>.runGame().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长连接的重连">长连接的重连</h3><blockquote><p>小程序进入后台运行后（非置顶聊天），如果 5s 内网络请求没有结束，会回调错误信息 <code>fail interrupted</code>；在回到前台之前，网络请求接口调用都会无法调用。</p></blockquote><p>所以一旦不在小程序界面超过 5s（包括停留在分享界面），长连接便会断开，即使长连接有自动重连机制，如果在重连期间没有回到小程序界面，长连接还是会失败。所以除了长连接的重连机制，可能还需要在回到小程序界面时或者用户操作前进行连接状态的检测与必要的重连。</p><p>如果你的小程序/小游戏后端服务器使用的是 <code>pomelo</code>，那么建议你使用我进行了扩展增强的 <code>pomelo</code> 微信客户端：<a href="https://github.com/yangfch3/pomelo-client-wx" target="_blank" rel="noopener">pomelo-client-wx</a>，支持重连和多个 <code>pomelo</code> 实例。但是你还是要实现上面所说的 <em>在回到小程序界面时或者用户操作前进行连接状态的检测与必要的重连</em>。</p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 微信小游戏 </tag>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】Node.js 中的错误处理</title>
      <link href="/2018/11/04/err-handling-in-nodejs-cn/"/>
      <url>/2018/11/04/err-handling-in-nodejs-cn/</url>
      <content type="html"><![CDATA[<p>错误处理是 <code>Node.js</code>/<code>JavaScript</code> 编程中我们常常忽视的一环，即使有错误处理的意识，也很容易因为没有指导原则的无绪错误处理导致我们的代码反而变得臃肿混乱。</p><p>原文 <a href="https://www.joyent.com/node-js/production/design/errors" target="_blank" rel="noopener">Error Handling in Node.js</a> 是笔者目前为止看过的对 Node.js 错误处理最系统、最详尽的叙述，下面是对这篇文章的翻译。</p><a id="more"></a><hr><p>错误处理是一个痛点，并且使用了 Node.js 很长时间仍旧没有正确处理错误的情况非常普遍。然而，搭建健壮的 Node.js 应用需要正确地处理错误，并且也不难学习。如果你非常不耐烦了，请跳到下文的 “总结” 部分。</p><p>本文将回答下列问题，也是 Node.js 新手程序员经常问的：</p><ul><li>在我编写的函数里，我应该什么时候 <code>throw</code> 一个错误，什么时候应当传给回调，什么时候又应当通过 <code>event emitter</code> 来触发，或者采用其他方式？</li><li>我的函数应当对它的参数做出哪些假设？我应当检测它们是否是正确的类型吗？我应该进行更多约束的检测，例如检测一个参数是否非 <code>null</code>，是否非负，是不是看起来像一个 IP 地址，等等</li><li>我应该如何处理哪些不符合函数预期的参数？我应当抛出一个异常，或是传递错误给回调函数吗？</li><li>从编程的角度，我应该如何区分不同类型的错误（例如一个 “Bad Request” 与一个 “Service Unavailable” 错误）？</li><li>我应该如何为我的错误提供尽可能详尽的细节以便调用者能得知如何处理他们？</li><li>我应当如何处理未预料的错误？我应该使用 <code>try/catch</code>, domains 还是其他的机制？</li></ul><p>本文分为以下几个相互联系的部分：</p><ul><li><strong>背景</strong>：你应当早已知悉的知识</li><li><strong>操作错误与程序员错误</strong>：介绍两种本质上不同的错误种类</li><li><strong>编写函数的模式</strong>：编写函数的一般标准，使得函数能产出有用的错误</li><li><strong>函数编写的具体建议</strong>：用于编写能产出有用错误的健壮函数的具体指南清单</li><li><strong>示例</strong>：为一个 <code>connect</code> 函数编写文档和前言</li><li><strong>总结</strong>：为上面的内容做一下总结</li><li><strong>附录</strong>：<code>Error</code> 对象的常规属性：用于以标准的方式提供额外信息的属性名称列表</li></ul><hr><h2 id="背景">背景</h2><p>本文假设：</p><ul><li>你熟悉 <code>JavaScript</code>, <code>Java</code>, <code>Python</code>, <code>C ++</code> 或任何类似语言中的异常的概念，并且您知道 <code>throw</code> 和 <code>catch</code> 它们意味着什么。</li><li>你熟悉 Node.js 编程，你能自如地使用异步操作以及异步操作完成后的 <code>callback(err, result)</code> 模式</li><li>你知道下面的模式为什么不能有效地处理错误：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myApiFunc</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This pattern does NOT work!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doSomeAsynchronousOperation(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* continue as normal */</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    callback(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>你也应当熟悉 Node.js 中四种主要的传递错误的方式：</p><ul><li><code>throw</code> 一个错误（使其成为一个 <em>异常</em>）</li><li>将错误传递给 <em>回调</em>，回调是专门为处理错误和异步操作的结果而提供的函数</li><li>传递错误给 Promise 对象的 <em>reject</em></li><li>在一个 EventEmitter 上触发 <code>&quot;error&quot;</code> 事件</li></ul><p>我们将在下面讨论每种模式在什么时候使用。本文不假设你了解 domains。</p><p>最后的一点，你应当知道在 JavaScript 中（特别的，在 Node.js 中），错误（error）和异常（exception）存在一个差别。一个错误（error）是 <code>Error</code> 类的一个实例，错误可以被构建，然后传递给另外的函数或被抛出。当你 <code>throw</code> 一个错误，它就变成了一个异常。将一个错误做为一个异常使用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'something bad happened'</span>);</span><br></pre></td></tr></table></figure><p>然而你可以单纯的创建一个 <code>Error</code> 而不是抛出它：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(<span class="name">new</span> Error('something bad happened'))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这种方式在 Node.js 中更加普遍因为大部分错误是异步的。如我们缩减，需要从同步函数中 <code>catch</code> 错误是非常罕见的。这与 <code>Java</code>, <code>C ++</code> 和其他大量使用异常的语言非常不同。</p><hr><h2 id="操作错误与程序员错误">操作错误与程序员错误</h2><p>将所有错误分为两大类是非常有帮助的：</p><ul><li><strong>操作错误</strong> 表示正确编写的程序遇到的运行时问题。这不是程序的 Bug。实际上，这些通常是其他一些问题：系统本身（例如：内存耗尽，打开过多文件），系统配置（例如：没有到远程主机的路由），网络（例如：<code>socket hang-up</code>）或远程服务（例如：500 错误，连接失败等等）。例子如下：<ul><li>连接服务器失败</li><li>解析域名失败</li><li>无效的用户输入</li><li>请求超时</li><li>服务器返回 500 响应</li><li>连接中止</li><li>系统内存耗尽</li></ul></li><li><strong>程序员错误</strong> 是程序的 Bug。这些总是能通过变更代码来避免。他们永远不能被正确的处理。<ul><li>尝试从 <code>undefined</code> 上读取属性</li><li>没有回调的情况下调用异步函数</li><li>在预期是一个对象的地方传入一个字符串</li><li>在预期是一个 IP 地址字符串的地方传入一个对象</li></ul></li></ul><p>人们使用术语 “errors” 来讨论操作错误和程序员错误，但它们真的完全不同。操作错误是所有正确程序必须处理的错误，只要它们被处理，那么他们就不一定会表现出 Bug 或严重问题。“File not found” 时一个操作错误，但是它不一定意味着这是错的。它只是表示程序必须在寻找文件前创建好这个文件。</p><p>反之，程序错误是 Bug。他们是你犯了错误的情况，可能是忘记验证用户输入，写错了变量名等等。根据定义，没有办法处理这些。假如有，那也只是你用错误处理代码代替导致错误的代码。</p><p>这个区别非常重要：<strong>操作错误时程序正常运行的一部分，程序员错误是 Bug</strong>。</p><p>有时，你会在一个根问题里同时遇到操作错误与程序员错误。如果一个 HTTP 服务器尝试使用一个未定义的变量，然后 crash，这是程序员错误。任何请求还在路上的客户端在 crash 的时候将会看到一个 <code>ECONNRESET</code> 错误，通常在 Node 中报告为  “socket hang-up”。对于客户端来说，这是一个单独的操作错误。这是因为正确的客户端必须处理服务器崩溃或网络不可用。</p><p>同样，<strong>未能处理操作错误本身就是程序员错误</strong>。例如，如果一个程序尝试连接服务器但是获得一个 <code>ECONNREFUSED</code> 错误，并且它没有为 socket 的 <code>'error'</code> 事件注册处理函数，那么程序将会 crash，那么就是程序员错误。连接失败是一个操作错误（因为任何正确的程序都可能会经历网络或其他组件发生故障），但是没有处理这个操作错误（这个行为）就时程序员错误了。</p><p>操作错误和程序员错误的区别是确定如何分发错误以及如何处理错误的基础。确保你在继续往下读之前已经懂了这些。</p><h3 id="处理操作错误">处理操作错误</h3><p>就像性能和安全一样，错误处理并不是可以突然凭空加到一个没有任何错误处理的程序中的。你没有办法在一个集中的地方处理所有的异常，就像你不能在一个集中的地方解决所有的性能问题。任何可能失败的代码（打开一个文件，连接到一个服务器，fork 一个子进程，等等）都必须考虑操作失败时导致的结果，包括为什么出错（失效模式），错误意味着什么。稍后会详细介绍，但这里想说的关键点就是<strong>错误处理有必要以细粒度的方式完成，因为哪里出错和为什么出错决定了影响大小和对策</strong>。</p><p>你最终可能在栈的多个层级处理相同的错误 —— 当低层级无法做任何有用的操作，除了向它的调用者上传错误，它的调用者又向上层的调用者传递错误…<strong>通常，只有顶层的调用者知道正确的错误应对是什么，是重试操作，向用户报告错误还是其他</strong>。但是，这<strong>不意味着你就应当把所有的错误全部丢给单一的顶层回调函数，因为这个回调自身无法知晓错误发生时的上下文，底层系列操作那些是成功完成的，那些操作是失败的。</strong></p><p>具体一点。对于任何一个指定的错误，你可以做这些事：</p><ul><li><p><strong>直接处理失败</strong>。有时，为了处理一个错误你应当做什么很清晰。如果你得到了尝试打开日志文件的一个 <code>ENOENT</code> 错误，也许这是这个程序第一次在这个系统运行，你只需要先创建一下这个日志文件。一个更有趣的例子，你维护一个与服务器（例如：数据库服务器）的持久连接，然后你得到了一个 “socket hang-up” 错误，这通常意味着远程的一端断开了连接或者网路出现了掉线，通常这种情况是短暂的，所以你通常通过 <strong>重连</strong>（reconnecting） 来应对这个错误。（与下文的 <strong>重试（retrying）</strong> 不同，因为在你得到这个错误的时候不一定有操作正在进行。）</p></li><li><p><strong>传递错误给客户端</strong>。如果你不知道如何处理错误，最简单的方式就是放弃你正在你正在尝试的操作，清理起始的数据和状态，发送一个错误给客户端（如何传递错误是另外一个问题，将在下面进行讨论）。这种方式适合错误短时间内无法解决的情形，比如，用户提交了不正确的JSON，你再解析一次是没什么帮助的。</p></li><li><p><strong>重试操作</strong>。对于网络与远程服务（例如 Web 服务）的错误，重试在有时候是有帮助的。例如，如果一个远程服务返回了一个 503（服务不可用错误），你可能想在几秒钟之后重试一下。<strong>如果你要重试，那你应该在文档中写明将会进行重试，要重试几次，每次重试之间的间隔</strong>。此外，<strong>不要假定每个操作都需要重试</strong>。如果你的操作在栈的较深层（例如：你的函数被一个客户端调用，而这个客户端又由一个由用户驱动的客户端调用），最好立即失败，让客户端自己去重试。如果，栈的每一层都认为自己需要在错误时重试，那么用户等待的时间可能比预期的要长，因为每一层没有意识到自己的下层也在重试</p></li><li><p><strong>直接崩溃</strong>。对于那些本不该发生的错误，或者由程序员失误导致的错误（例如：比如无法连接到一个本应该在相同程序中监听的本地套接字），最好记下错误信息然后 crash。其他的错误，如内存耗尽，无论如何都无法在像 JavaScript 这样的动态语言中被处理，所以程序崩溃是完全合理的。（也就是说，从 <code>child_process</code> 分离操作中得到 <code>ENOMEM</code> 错误，以及那些你能合理处理的错误时，你应该考虑这样做 —— 让子进程 crash）当你无计可施只能让负责人修复错误的时候，那么让程序直接崩溃吧。例如，文件描述符用尽，或者没有权限访问配置文件，那么你什么也做不了，只能让别人（例如系统运维工程师等）去修复。</p></li><li><p><strong>记下错误，其他什么也不做</strong>。有时候，你什么也做不了，没有什么可以让你重试或丢弃的东西，也没有理由让程序崩溃。例如你用 DNS 追踪一组远程服务（例如轮询 DNS 以检测域名是否解析正常），结果其中有一个服务失败无法 DNS 解析了。除了记下错误，继续处理剩下的服务之外你什么也无法做。但这种情况下至少你应当记录下一些信息。（但万事都有例外，如果这种错误每秒数以千计，你毫无办法应对，那么不太值得每次发生时都记录，但是可以定期记录）</p></li></ul><h3 id="不要-处理程序员错误">（不要）处理程序员错误</h3><p>你无法处理程序员错误。根据定义，这些代码预期中是破坏性的（例如有一个拼写错误的变量名），你无法用更多的代码来修复这个问题。假设你能，你也只是用错误处理代码代替了破坏性的代码。</p><p>有些人主张尝试从程序员错误中 <em>recover</em> —— 允许当前操作失败，但是继续处理请求。这是不推荐的，想一想程序员错误是你在编写代码时无法考虑到的（位置不确定性），你怎么确定这样做（继续处理）会不会影响其他请求？如果其他请求和当前发生程序员错误的代码共享任何状态（服务器、套接字、数据库连接池等），很可能其他请求将会做一些错误的事情。</p><p>一个经典的例子就是 REST 服务器（例如使用 <code>restify</code> 编写的），某一个请求处理抛出 <code>ReferenceError</code>（例如使用一个拼写错误的变量）。继续处理下去的话有很多种途径可以导致非常难以追查的严重 Bug，例如：</p><ol><li><p>请求见共享的某些状态可能会保留为 <code>null</code>, <code>undefined</code> 或其他无效值，于是当下一个请求尝试使用它们时，程序将再次崩溃</p></li><li><p>数据库（或其他）连接可能被泄露（内存泄露），从而降低你将来可以处理的并行请求数。更严重的是，后面可能你只剩下几个连接，最终以串行而不是并行的方式来处理请求</p></li><li><p>更糟的是，postgres 连接会被留在打开的请求事务里。这会导致 postgres “持有” 表中某一行的旧值，因为它对这个事务可见。这个问题会存在好几周，造成表的有效大小无限制的增长 —— 导致后面的查询以数量级减缓 —— 从几毫秒到几分钟。虽然这个问题和 postgres 紧密相关，但是它很好的说明了程序员一个简单的失误会让应用程序陷入一种非常糟糕的状态。</p></li><li><p>一个连接可能被保持在已认证状态，然后被后续的请求使用，你最终可能在为一个错误的用户运行请求</p></li><li><p>套接字可能保持打开状态。Node.js 通常会在一个闲置的套接字上应用 2 分钟的超时，但是这个配置可能被复写，导致文件描述符泄露。如果发生这种情况，你可能会用尽文件描述符然后崩溃。即使你没有改写超时的配置，客户端也会挂起两分钟然后得到一个非预期的 <code>hang-up</code> 错误。两分钟的延迟将使得问题处理与调试变成烦恼。</p></li><li><p>内存引用被保留，这会造成泄露，导致系统内存用尽，或者（更糟糕的是）增长 GC（垃圾回收）的用时，导致性能严重受损。这个非常难以调试，有时你很难将内存泄露与程序员错误联系到一起。</p></li></ol><p><strong>从程序员错误中恢复的最好的方法就是立即 crash</strong>。你应当使用一个 restarter 来运行你的程序，以便在 crash 时能自动重启程序。有了 restarter，crash 是面对短暂的程序员错误时恢复可靠服务的最快方法。</p><p>在程序员错误 crash 的唯一不好的地方是连接的客户端可能会暂时中断，但请记住：</p><ul><li><p>根据定义，这些错误总是 Bug。我们不是在谈论合法的系统或网络失败，而是程序里的 Bug。在生产环境中这应该是比较罕见的，优先级最高的是必须 debug 和修复它们</p></li><li><p>对于上述描述所有情况（以及更多情况），请求没有必要一定得成功完成。请求可能成功完成，请求可能再次 crash 服务器，请求可能以明显的方式不适当的完成（例如：503，但是服务器不 crash），或者请求可能以难以调试的微妙的方式错误地完成</p></li><li><p>在一个可靠的分布式系统中，客户端必须能够通过重新连接和重试请求来处理服务器故障。无论 Node.js 程序是否允许 crash，网络和系统故障都是实实在在存在的</p></li><li><p>如果你的生产环境程序过于频繁地 crash 以至于连接断开都成了一个问题，那么真正的问题时你的服务器过于 buggy，而不是在有 Bug 情况下的 crash</p></li></ul><p>如果由于服务器 crash 客户端出现频繁断开的问题，你应当聚焦于造成服务 crash 的 Bug —— 让这些 Bug 成为异常 —— 而不是尝试避免在代码明显错误的情况下的 crash。debug 这些问题的最佳方式是配置 Node 在出现一个未捕获异常时 dump 内核详情。在 GNU/Linux 或着基于 illumos 的系统上使用 dump 的内核文件，你不仅可以查看程序 crash 时的堆栈记录，也能看到这些函数的参数，以及更多其他 JavaScript 对象，甚至那些在闭包里引用的变量。即使没有配置内核文件 dump，你也可以使用函数堆栈信息和日志来开始处理问题。</p><p>最后，请记住，服务器上的程序员错误指挥成为客户端上的操作错误，客户端必须处理服务器崩溃与网络故障。这不仅仅是理论上的 —— 在生产环境中确实都会发生。</p><hr><h2 id="编写函数的模式">编写函数的模式</h2><p>我们已经讨论了如何处理错误，但是当你正在写一个新函数，你如何传递（<em>deliver</em>）错误给调用你这个函数的代码？</p><p>最最重要的一点是为你的函数 <strong>写好文档</strong>，包括它接受的参数（包括它们的类型、约束），返回什么，什么错误可能发生，这些错误意味着什么。<strong>如果你不知道可能发生什么错误，或者不了解错误的含义，那么你的程序的正常运行只是巧合</strong>。所以，如果你正在写一个新的函数，你必须告知调用者可能发生什么错误，每种错误意味着什么。</p><h3 id="throw-回调-reject-还是-eventemitter">throw, 回调, reject 还是 EventEmitter?</h3><p>函数传递错误有三种基本的模式：</p><ul><li><p><code>throw</code> 同步传递一个错误 —— 也就是说，在函数被调用处的相通上下文。如果调用者（或者调用者的调用者…）使用 <code>try/catch</code>，那么它们可以捕获这个错误。如果没有任何一个调用者捕获，程序通常 crash（错误也可能会被 <code>domains</code> 或者进程级的 <code>uncaughtException</code> 事件捕获，下文将进行讨论）。</p></li><li><p>回调函数是异步传递错误的最基本方式。用户传给你一个函数（回调函数），稍后当异步操作完成时执行它。通常的形式是回调函数以 <code>callback(err, result)</code> 的方式调用，<code>err</code> 和 <code>result</code> 参数中只有一个为非 null，谁为 null 有操作成功还是失败决定</p></li><li><p>Promise rejections 是异步传递错误的常见方式。自包含对 <code>async</code>/<code>await</code> 支持的 Node.js 版本 8 发布以来，这种方式越来越受欢迎。这允许异步代码写得看起来向同步代码，并且可以使用 <code>try</code>/<code>catch</code> 捕获错误</p></li><li><p>对于更复杂的情况，代替使用回调函数，函数本身可以返回一个 <code>EventEmitter</code> 对象，调用者应该在 EventEmitter 对象上监听 <code>error</code> 事件。这在两种特定的情况下很有用：</p><ul><li>当您执行可能产生多个错误或多个结果的复杂操作时。例如，考虑一个需要从数据区中获取多行数据的请求，一旦有数据到达时 <code>stream</code> 它们给客户端，而不是先等所有的数据先获取到。在这种情况下，你的函数最好返回一个 EventEmitter，对每一个结果都触发 <code>row</code> 事件，当所有结果报告完毕时触发 <code>end</code> 事件，当任何错误发生时触发 <code>error</code> 事件。</li><li>对于那些具有复杂状态机的对象，可能繁盛许多不同的异步事件。例如，一个套接字是一个 EventEmitter，可能触发 “connect”, “end”, “timeout”, “drain”, 和 “close”。很自然地，我们会将 “error” 也作为套接字另一种可以被触发的事件。当使用这种方式，很重要的是清楚 “error” 何时被触发，是否任何其他事件会被触发，在同一事件可能会看到哪些其他事件（例如 “close”），它们发生的顺序如何，套接字是否会在事件结束时被关闭。</li></ul></li></ul><p>在大多数情况下，我们会将回调函数与 EventEmitter 归到 “异步错误传递” 这一类中。如果需要异步地传递错误，通常需要使用其中一个（回调函数或 EventEmitter），但不能同时使用。</p><p>那么，什么时候使用 <code>throw</code>，什么使用使用回调或 EventEmitter？这取决于两件事：</p><ul><li>是操作错误，还是程序员错误？</li><li>函数本身是同步的，还是异步的？</li></ul><p>到目前为止，最常见的情况是异步函数中的操作错误。这些中的大多数，你可能希望你的函数接收一个回调函数作为函数，你只需要将错误传递给回调函数。这非常有效，并且被广泛使用（加入了 async/await，回调的模式慢慢被替代）。关于例子可以查看 Node.js 的 <code>fs</code> 模块。如果你有一个比上面描述的更复杂的情况，你可能想要使用 EventEmitter，但你仍然时异步地传递错误。</p><p>下一个最常见的情况是同步函数中的操作错误，例如 <code>JSON.parse</code>。对于这些函数，如果你遇到一个操作错误（例如无效的用户输入），你必须同步地传递错误，你可以 <code>throw</code> 它或者 <code>return</code> 它。</p><p>对于一个给定的函数，如果任何操作错误可以异步传递，那么所有异步错误都应该异步传递。在某些情况下，你会立即知道请求会失败，但不是因为程序员错误。也许该函数缓存了最近请求的结果，并且缓存的是一个你将返回给调用者的错误对象。尽管你知道请求会立即失败，你也应该异步地传递错误（因为函数对外的预期是异步函数）。</p><p>通用规则是：<strong>函数可以同步（例如，通过 <code>throw</code>）或异步（通过将它们传递给回调或在 EventEmitter 上触发错误事件）来传递操作错误，但不应该同时执行这两者</strong>。这样，用户可以通过在回调中处理错误或使用 <code>try/catch</code> 来处理错误，但是他们永远不需要同时执行这两种操作。使用哪一种方式取决于函数如何传递其错误，并且应该参考函数的文档以决定。</p><p>差点遗漏了程序员错误。回想之前的观点：程序员错误总是 Bug。通常可以通过在函数开头检查函数的参数类型（和其他约束）来立即识别它们。一个比较落后的例子：有人可能在调用一个异步函数时没有传递回调函数。你应该立即抛出这些错误，因为程序已经出错而在这个点上最好的调试的机会就是得到一个堆栈信息，如果有出错时刻内核信息就更好了。为此，我们建议在函数开头校验所有参数。</p><p>由于永远不应该处理程序员错误，上面提到的调用者只能用 <code>try</code>/<code>catch</code> 或者回调函数（或者 EventEmitter）其中一种处理异常的准则并没有因为这条意见而改变。如果你想知道更多，请见上面的 （不要）处理程序员的失误。</p><p>下面是对 Node.js 核心库中的一些示例函数使用这些建议的摘要，按照每种问题出现的频率来粗略排序：</p><table><thead><tr><th style="text-align:center">示例函数</th><th style="text-align:center">函数类型</th><th style="text-align:center">示例错误</th><th style="text-align:center">错误类型</th><th style="text-align:center">如何传递</th><th style="text-align:center">调用者处理</th></tr></thead><tbody><tr><td style="text-align:center"><code>fs.stat</code></td><td style="text-align:center">异步</td><td style="text-align:center">file not found</td><td style="text-align:center">操作错误</td><td style="text-align:center">回调函数</td><td style="text-align:center">回调函数处理</td></tr><tr><td style="text-align:center"><code>JSON.parse</code></td><td style="text-align:center">同步</td><td style="text-align:center">bad user input</td><td style="text-align:center">操作错误</td><td style="text-align:center"><code>throw</code></td><td style="text-align:center"><code>try</code>/<code>catch</code></td></tr><tr><td style="text-align:center"><code>fs.stat</code></td><td style="text-align:center">异步</td><td style="text-align:center">filename is <code>null</code></td><td style="text-align:center">程序员错误</td><td style="text-align:center"><code>throw</code></td><td style="text-align:center">无（crash）</td></tr></tbody></table><p>异步函数（第一行）中的操作错误是目前最常见的错误。除了用户输入验证外，报告操作错误的同步函数在 Node.js 中非常少。然而，随着 Node.js 新版的发布（8.x+），大家开始将异步函数 Promise 化，并在 <code>try</code>/<code>catch</code> 中使用 await（之前说的 <code>try</code> 块中不应该出现异步操作，但是 await 的出现，改变了这一点）。（第 3 行的）程序员错误除了再开发中永远不应该出现。</p><h3 id="bad-input-操作错误还是程序员错误？">bad input: 操作错误还是程序员错误？</h3><p>你如何得知什么是操作错误，什么是程序员错误？很简单：取决于你如何定义与文档记录你的函数允许何种类型与如何解释它们。如果你接收到的是你的文档没有记录可接收的东西，那么就是程序员错误。如果输入的是你的文档记录可接受的但是你已说明目前不能正确处理的，那就是操作错误。</p><p>你必须根据自己的判断来决定你想要多严格，但我们可以制定一些建议：<br>具体点，想象一个叫 <code>connect</code> 的函数，它接收一个 IP 地址和一个回调，回调在函数执行成功或失败后执行。假设用户传递的东西显然不是有效的 IP 地址，例如 <code>'bob'</code> 字符串。在这种情况下，你有这些选择：</p><ul><li><p>文档说明该函数只接受表示有效 IPV4 地址的字符串，如果用户传入 <code>'bob'</code> 则立即抛出异常。强烈推荐这样做</p></li><li><p>文档说明该函数接收任何字符串。如果用户传入 <code>'bob'</code>，则发出一个异步错误表明不能连接到 <code>'bob'</code> 这个 IP 地址</p></li></ul><p>这两点与上面的操作错误与程序员错误的指南一致。你决定了这样的错误是程序员错误还是操作错误。通常，用户输入校验的功能是十分松散的。例如，<code>Date.parse</code> ，它接收很多种类型的输入。但对于其他大部分函数，我们强烈建议更严格而不是更宽松。你的函数越是想猜测调用者的意思，就越可能猜错。你的本意是想让开发者在使用的时候更加自由，结果却耗费了开发者数个小时来 debug（由于你程序做了太多猜测，而有些猜测的逻辑存在 Bug）。此外，如果你觉得在将来的版本中让函数不那么严格是个好主意，那你可以这样做，但是，如果你发现由于猜测用户的意图导致了很多恼人的 Bug，你再想不破坏兼容性就能修复是不可能的。</p><blockquote><p>笔者注：由严格到宽松可以，但是发现宽松的情况下有 Bug，此时要想修复或变得更严格，你就只能打破兼容性了</p></blockquote><p>所以如果一个值怎么都不可能是有效的（本该是 <code>string</code> 却得到一个 <code>undefined</code>，本该是 IP 地址形式的 <code>string</code> 但明显不是），你应该在文档里写明这是不允许的并且立刻抛出一个异常。你要你用文档进行了说明，那这些错误就是程序员错误，而不是操作错误。通过立即抛出错误，你可以最大限度的减少 Bug 带来的破坏，并保留开发人员用于 Debug 需要的信息（例如，堆栈信息，如果进行了 dump core 还可以记下参数和内存信息）。</p><h3 id="那么-domains-和-process-on-uncaughtexception-呢">那么 <code>domains</code> 和 <code>process.on('uncaughtException')</code> 呢</h3><p>操作错误总是可以通过一个显式的机制来处理：捕获异常，回调中处理错误，在 EventEmitter 对象上处理 error 事件等等。<code>domains</code> 和进程级的 <code>'uncaughtException'</code> 事件主要用于尝试处理意外的错误或从意外的错误中恢复。根据上面给出的原因，不推荐恢复。</p><hr><h2 id="函数编写的具体建议">函数编写的具体建议</h2><p>我们已经谈论了许多指导原则，现在我们具体点：</p><blockquote><p><code>1. 弄清楚你的函数做的是什么</code></p><p>这是最最重要的事情，每个接口函数的文档应该明晰：</p><ul><li>期望接收哪些参数</li><li>每个参数的类型</li><li>对这些参数的任何其他约束（例如：必须是有效的 IP 地址）</li></ul><p>如果这些中的点错了或者忘记遗漏，那就是程序错误，你应当立即抛出。</p><p>你还应当将这些点写入文档：</p><ol><li>调用者应该能预见到的操作错误（包括错误的名字）</li><li>你的函数如何处理操作错误（被抛出，传递给回调函数，在 EventEmitter 对象上触发事件等等）</li><li>返回值</li></ol></blockquote><p><span></span></p><blockquote><p><code>2. 为所有的错误使用 Error 对象（或子类），实现为错误制定的约定</code></p><p>你所有的错误应该使用 Error 类或其子类。你应当提供 <code>name</code> 和 <code>message</code> 属性，堆栈也应该被收集（并且可靠）</p></blockquote><p><span></span></p><blockquote><p><code>3. 使用 Error 对象的</code>name<code>属性在程序上区分错误</code></p><p>当你需要弄清楚错误是什么类型时，使用 <code>name</code> 属性。JavaScript 内置的供你重用的名字包括 “RangeError”（参数超出有效范围）和 “TypeError”（参数类型错误）。对于 HTTP 错误，通常使用 RFC 给定的状态文本来命名错误，例如 “BadRequestError” 或 “ServiceUnavailableError”。</p><p>不要觉得需要为一切错误创造新名字。你不需要细分 InvalidHostnameError, InvalidIpAddressError, InvalidDnsServerError 等等，你可以只使用一个 InvalidArgumentError 然后用表述错误的属性来扩展它（见下文）。</p></blockquote><p><span></span></p><blockquote><p><code>4. 使用解释细节的属性来扩展 Error 对象</code></p><p>例如，如果是一个参数无效的错误，将 <code>propertyName</code> 属性设为无效属性的名字，将 <code>propertyValue</code> 设置为传入的值。如果连接服务器失败，使用 <code>remoteIp</code> 说明你尝试连接 IP。如果你得到了一个系统错误，请包含 <code>syscall</code> 属性说明是哪个系统调用失败了，并使用 <code>errno</code> 属性说明系统返回的 <code>errno</code>。有关要使用的示例属性名称，请参阅附录。</p><p>至少，你需要：</p><ul><li><code>name</code>：用于在程序上区分错误类型（例如：非法参数、连接失败）</li><li><code>message</code>：人可读的错误信息，应该足够完整使读它的人能理解。如果是从堆栈的较低层级传递错误，你应该添加在 <code>message</code> 上添加你正在做的事情的说明。包装错误的更多讨论见下一点</li><li><code>stack</code>：一般来讲，不要随便扰乱 stack 信息，甚至不要去扩展它。V8 引擎只有在这个属性真正被读取时才会去运算，以此显著提高错误处理的性能。如果你只是为了扩展 stack 而去读取它，即使你的调用者不需要 stack 信息你也会付出读取的代价</li></ul><p>你也应当在错误信息中包含足够的信息，以便调用者无需解析你的错误 信息即可构建自己的错误信息。调用者可能希望对错误消息本地化，或将大量错误聚合在一起，或以不同的方式展示错误信息（比如在网页的一个表格里，或者高亮显示用户错误输入的字段）。</p></blockquote><p><span></span></p><blockquote><p><code>5. 如果将较低层级的错误传递给调用者，考虑包装一下</code></p><p>通常你会发现异步函数 funcA 调用了一些其他的异步函数 funcB，如果 funcB 发出一个错误，你会希望 funcA 发出相同的错误（注意有时并不这样，funcA 可能会重试，也可能忽略错误什么事情也不用做）。但我们只是考虑funcA想在这里直接返回funcB错误的简单情况。</p><p>在这种情况下，考虑包装一下 Error 对象而不是直接返回它。包装的意思是上传一个包含底层错误所有信息的新的错误，并且带上当前层的有用上下文。<code>verror</code> 模块提供了一种非常方便的包装方式。</p><p>例如，假设你有一个叫做 <code>fetchConfig</code> 的函数，从远程数据库拉取服务器配置。你可能会在服务器启动的时候调用这个函数。整个流程看起来是这样的：</p><ol><li>加载配置<ol><li>连接到数据库服务器。这一步将会：<ol><li>解析数据库服务器的 DNS 域名</li><li>创建一个与数据库服务器的 TCP 连接</li><li>数据库服务器认证</li></ol></li><li>数据库查询</li><li>解码返回数据</li><li>加载配置</li></ol></li><li>开始处理请求</li></ol><p>假如在运行时连接到数据库服务器出现问题，如果因为没有到达主机的路由 1.1.2 失败了，并且每一个层级将错误上传给调用者（理应如此），但是不包装错误，那么你可能或得到一个这样的错误信息：</p><p><code>myserver: Error: connect ECONNREFUSED</code></p><p>这显然没有多少帮助。</p><p>另一方面，如果每一层包装从下一层返回的错误，你可以获得更多信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myserver: failed <span class="keyword">to</span> start up: failed <span class="keyword">to</span> load configuration: failed <span class="keyword">to</span> connect <span class="keyword">to</span></span><br><span class="line">database server: failed <span class="keyword">to</span> connect <span class="keyword">to</span> 127.0.0.1<span class="built_in"> port </span>1234: connect ECONNREFUSED</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>你可能在某些层级想跳过包装，得到一个不那么学究气息的信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myserver: failed <span class="keyword">to</span> load configuration:<span class="built_in"> connection </span>refused <span class="keyword">from</span> database at</span><br><span class="line">127.0.0.1<span class="built_in"> port </span>1234.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>然而，报错的时候详细一点总比信息不够要好。</p><p>如果你决定包装错误，有一些事是你需要考虑的：</p><ul><li><p>保留原始错误不要篡改，确保调用者仍能使用底层的错误以防它需要从底层的错误中直接获取信息</p></li><li><p>要么使用相同的名字，要么显式地选择一个更有意义的名字。例如，底层可能是来自 Node 的一个普通错误，但步骤 1 的错误可能是 <code>InitializationError</code>。（但是如果程序可以通过其它的属性区分，就不要觉得一定有责任取一个新的名字）</p></li><li><p>保留原始错误的所有属性，适当地扩充 <code>message</code> 属性（但不要在原始错误上直接修改）。浅拷贝像 <code>syscall</code>, <code>errno</code> 这种类似的其他属性。您最好复制除 <code>name</code>, <code>message</code> 和 之外的所有属性，而不是硬编码要显式复制的属性列表。不要对 <code>stack</code> 做任何事情，因为即便只是读取它便已经非常昂贵了。如果调用者想要生成组合堆栈，它应该用（需要读取组合堆栈时）迭代输出每个错误的堆栈来代替组合堆栈 。</p></li></ul><p>joynet 使用 <code>verror</code> 模块来包装错误，因为它简洁的语法。</p></blockquote><hr><h2 id="示例">示例</h2><p>考虑一个异步连接到 IPV4 地址和端口的函数，下面是我们如何为它写文档的示例：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Make a TCP connection <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">given</span> IPv4 address.  Arguments:</span><br><span class="line"> *</span><br><span class="line"> *    ip4addr        a <span class="built_in">string</span> representing a valid IPv4 address</span><br><span class="line"> *</span><br><span class="line"> *    tcpPort        a positive <span class="built_in">integer</span> representing a valid TCP port</span><br><span class="line"> *</span><br><span class="line"> *    <span class="keyword">timeout</span>        a positive <span class="built_in">integer</span> denoting <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> milliseconds</span><br><span class="line"> *                   <span class="keyword">to</span> wait <span class="keyword">for</span> a response <span class="keyword">from</span> <span class="keyword">the</span> remote server <span class="keyword">before</span></span><br><span class="line"> *                   <span class="keyword">considering</span> <span class="keyword">the</span> connection <span class="keyword">to</span> have failed.</span><br><span class="line"> *</span><br><span class="line"> *    callback       invoked when <span class="keyword">the</span> connection succeeds <span class="keyword">or</span> fails.  Upon</span><br><span class="line"> *                   success, callback <span class="keyword">is</span> invoked <span class="keyword">as</span> callback(null, socket),</span><br><span class="line"> *                   <span class="keyword">where</span> `socket` <span class="keyword">is</span> a Node net.Socket object.  Upon failure,</span><br><span class="line"> *                   callback <span class="keyword">is</span> invoked <span class="keyword">as</span> callback(err) instead.</span><br><span class="line"> *</span><br><span class="line"> * This function may fail <span class="keyword">for</span> several reasons:</span><br><span class="line"> *</span><br><span class="line"> *    SystemError    For <span class="string">"connection refused"</span> <span class="keyword">and</span> <span class="string">"host unreachable"</span> <span class="keyword">and</span> other</span><br><span class="line"> *                   errors returned <span class="keyword">by</span> <span class="keyword">the</span> connect(<span class="number">2</span>) system call.  For these</span><br><span class="line"> *                   errors, err.errno will be <span class="keyword">set</span> <span class="keyword">to</span> <span class="keyword">the</span> actual errno symbolic</span><br><span class="line"> *                   <span class="built_in">name</span>.</span><br><span class="line"> *</span><br><span class="line"> *    TimeoutError   Emitted <span class="keyword">if</span> <span class="string">"timeout"</span> milliseconds elapse <span class="keyword">without</span></span><br><span class="line"> *                   successfully completing <span class="keyword">the</span> connection.</span><br><span class="line"> *</span><br><span class="line"> * All errors will have <span class="keyword">the</span> conventional <span class="string">"remoteIp"</span> <span class="keyword">and</span> <span class="string">"remotePort"</span> properties.</span><br><span class="line"> * After any <span class="keyword">error</span>, any socket <span class="keyword">that</span> was created will be closed.</span><br><span class="line"> */</span><br><span class="line">function connect(ip4addr, tcpPort, <span class="keyword">timeout</span>, callback) &#123;</span><br><span class="line">  assert.<span class="keyword">equal</span>(typeof (ip4addr), '<span class="built_in">string</span>',</span><br><span class="line">      <span class="string">"argument 'ip4addr' must be a string"</span>);</span><br><span class="line">  assert.ok(net.isIPv4(ip4addr),</span><br><span class="line">      <span class="string">"argument 'ip4addr' must be a valid IPv4 address"</span>);</span><br><span class="line">  assert.<span class="keyword">equal</span>(typeof (tcpPort), '<span class="built_in">number</span>',</span><br><span class="line">      <span class="string">"argument 'tcpPort' must be a number"</span>);</span><br><span class="line">  assert.ok(!isNaN(tcpPort) &amp;&amp; tcpPort &gt; <span class="number">0</span> &amp;&amp; tcpPort &lt; <span class="number">65536</span>,</span><br><span class="line">      <span class="string">"argument 'tcpPort' must be a positive integer between 1 and 65535"</span>);</span><br><span class="line">  assert.<span class="keyword">equal</span>(typeof (<span class="keyword">timeout</span>), '<span class="built_in">number</span>',</span><br><span class="line">      <span class="string">"argument 'timeout' must be a number"</span>);</span><br><span class="line">  assert.ok(!isNaN(<span class="keyword">timeout</span>) &amp;&amp; <span class="keyword">timeout</span> &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">"argument 'timeout' must be a positive integer"</span>);</span><br><span class="line">  assert.<span class="keyword">equal</span>(typeof (callback), 'function');</span><br><span class="line"></span><br><span class="line">  /* do work */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在概念上很简单，但演示了我们所谈论的一系列建议：</p><ul><li><p>参数，它们的类型，值的约束都有明确的记录</p></li><li><p>函数对它接收的参数是严格的，当得到的是一个无效的输入时他会抛出错误（程序员错误）</p></li><li><p>记录了一系列可能的操作错误。不同的 <code>name</code> 属性值用于在逻辑上区分不同的错误，<code>errno</code> 用于获取系统错误的详细信息</p></li><li><p>错误的传递方式也被记录（失败是调用 <code>callback</code>）</p></li><li><p>返回的错误具有 <code>remoteIp</code> 和 <code>remotePort</code> 字段以便使用者可以定义自定义的错误 <code>message</code></p></li><li><p>尽管显而易见，但连接失败后的状态清楚记录在案：任何打开的 <code>socket</code> 将已经被关闭</p></li></ul><p>这看起来像是给一个很容易理解的函数写了超过大部分人会写的的超长注释，但大部分函数实际上没有这么容易理解。所有建议都应该被有选择的吸收，如果事情很简单，你应该自己做出判断，但是记住：用十分钟把预计发生的记录下来可能之后会为你或其他人节省数个小时。</p><hr><h2 id="总结">总结</h2><ul><li><p>学习了区分操作错误，即那些可以被预测的哪怕在正确的程序里也无法避免的错误（例如，无法连接到服务器），和程序员错误，即那些程序中的 Bug</p></li><li><p>操作错误可以也应当被处理，程序员错误无法被处理或从中可靠地恢复（也不应当），尝试这样做只会更难调试</p></li><li><p>一个给定的函数，它处理异常的方式要么是同步（用 <code>throw</code> 方式）要么是异步的（用 <code>callback</code> 或者 <code>EventEmitter</code>），不会两者兼具。用户可以在回调函数里处理错误，也可以使用 <code>try</code>/<code>catch</code> 捕获异常 ，但是不能一起用。实际上，使用 <code>throw</code> 并且期望调用者使用 <code>try</code>/<code>catch</code> 是很罕见的，因为 Node.js 里的同步函数通常不会产生运行失败（主要的例外是类似于 <code>JSON.parse</code> 的用户输入验证函数）。</p></li><li><p>在写新函数的时候，用文档清楚地记录函数预期的参数，包括它们的类型、其它约束（例如 “必须是有效的IP地址”），可能会合理发生的操作失败（例如无法解析主机名，连接服务器失败，或其他服务器端错误），以及错误是怎么传递给调用者的（同步，用 <code>throw</code>，还是异步，用 <code>callback</code> 和 <code>EventEmitter</code>）。</p></li><li><p>缺少或无效的参数时程序员错误，这种错误发生时你应当总是 <code>throw</code>。可能作者决定接收的函数存在灰色地带，但是如果你传递的不是它所记录的能接受的，则始终是程序员错误</p></li><li><p>当传递错误时，使用标准的 <code>Error</code> 类以及其他标准属性。在其他属性上添加尽可能多的有帮助的附加信息。在可能的情况下，使用约定的属性名（如下）。</p></li></ul><hr><h2 id="附录：错误对象约定属性名">附录：错误对象约定属性名</h2><p>强烈推荐你使用这些属性名以与 Node.js 核心以及 Node.js 插件传递的错误保持一致。这些中的大多数不会适用于给定的错误，但是出现疑问的时候，您应该以编程方式和自定义错误消息包含任何看似有用的信息。</p><img src="/2018/11/04/err-handling-in-nodejs-cn/1.png" title="错误对象约定属性名表">]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 翻译 </tag>
            
            <tag> 错误处理 </tag>
            
            <tag> 指南 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】Node.js的事件循环（Event Loop）、定时器（Timers）和 process.nextTick()</title>
      <link href="/2018/11/01/event-loop-timers-and-nexttick-cn/"/>
      <url>/2018/11/01/event-loop-timers-and-nexttick-cn/</url>
      <content type="html"><![CDATA[<p>翻译自 Node.js 官方文档：<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a></p><a id="more"></a><h2 id="什么是事件循环？">什么是事件循环？</h2><p>事件循环是一种允许 Node.js 实现无阻塞的 IO 操作 —— 尽管 JavaScript 是单线程的 —— 通过尽可能将操作卸到系统内核的机制。</p><p>因为大部分现代内核都是多线程的，他们可以在后台执行多个操作。当这些操作的其中一个完成后，内核告知 Node.js 以便对应的回调能添加到 <strong>poll</strong> 队列以最终执行。下面我们将深入这个主题的细节。</p><h2 id="事件循环解析">事件循环解析</h2><p>当 Node.js 启动，它初始化事件循环，处理提供的输入脚本（或将脚本放到 <code>REPL</code> 内，不再本文的讨论范围内），脚本可能做了异步 API 调用、定时器或者调用 <code>process.nextTick()</code>。然后开始处理事件循环。</p><blockquote><p>换句话说，先执行完脚本中同步的代码。</p></blockquote><p>下面的图表展示了事件循环操作顺序的简单概览：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │          <span class="built_in"> check </span>          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><blockquote><p><em>注：左边每个块在事件循环中被称为 “阶段”</em></p></blockquote><p>每个阶段有一个 FIFO（先进先出）的将要执行的回调函数的队列。虽然每个阶段都有自己独特运行的地方，但通常来说，当事件循环进入一个指定的阶段，它将执行特定于该阶段的任何操作，然后执行该阶段的队列中的回调函数直到队列消耗完毕或执行函数的数量达到了最大值。当回调函数队列被耗尽或达到了回调极限，事件循环将进入下一个阶段，下一个阶段如是。</p><p>由于这些操作中的任何一个可以规划更多操作并且在 <code>poll</code> 阶段中处理的新事件（例如新的连接来了，新的数据来了的回调）由内核排队，因此新的 <code>poll</code> 事件可以在处理 <code>poll</code> 事件时继续加入队列。因此，长时间运行的回调可以允许轮询阶段运行的时间比计时器的阈值长得多。有关详细信息，请参阅下面的 <code>timers</code> 和 <code>poll</code> 章节。</p><blockquote><p><em>注：Windows 和 Unix/Linux 实现之间存在轻微差异，但对于本文这个并不重要。</em><br><em>这里讲的是最重要的部分，实际上有 7,8 个步骤，但我们关心的，Node.js 实际上使用的就是上面这些</em></p></blockquote><h2 id="阶段概览">阶段概览</h2><ul><li><strong>timers</strong>: 这个阶段执行由 <code>setTimeout()</code> 和 <code>setInterval()</code> 规划的回调</li><li><strong>pending callbacks</strong>: 执行延迟到下一个循环迭代的 I/O 回调</li><li><strong>idle, prepare</strong>: 只在内部使用</li><li><strong>poll</strong>: 检索新的 I/O 事件，执行 I/O 相关回调（除了 <code>close callback</code>，定时器和 <code>setImmediate()</code> 规划之外的几乎所有回调），节点将在适当的时候阻塞</li><li><strong>check</strong>: <code>setImmediate()</code>回调在这里执行</li><li><strong>close callbacks</strong>: 一些 <code>close callbacks</code>，例如 <code>socket.on ('close', fn)</code> 的 <code>fn</code></li></ul><p>在事件循环的每次运行之间，Node.js 检查它是否在等待任何异步 I/O 或定时器，如果没有，则关闭事件循环，进程退出。</p><h2 id="阶段细节">阶段细节</h2><h3 id="timers">timers</h3><p>一个定时器指定了阈值，阈值是指之后被提供的回调函数<strong>可能</strong>被执行，而不是我们希望他被执行的确切时间。定时器回调在给定的时间过完后尽可能早地执行，然而，操作系统规划或运行其他回调可能延迟定时器回调的执行。</p><blockquote><p><em>注：技术上 <code>poll</code> 阶段控制了定时器的回调什么时候执行</em></p></blockquote><p>一个例子，你规划了一个 timeout 在 100ms 的阈值后执行回调，然后你的脚本开始一个花费 95ms 异步文件读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当事件循环进入 <code>poll</code> 阶段，它的队列为空（<code>fs.readFile()</code> 还没有完成），所以它将等待剩余的毫秒数，直到最快的定时器阈值到达。然而，等待 95ms 后，<code>fs.readFile()</code> 结束了文件的读取，它的需要花费 10ms 才能完成的回调将加入 <code>poll</code> 队列，此时 <code>poll</code> 队列为非空，开始遍历队列以执行。当该回调结束，队列里没有了其他回调函数，于是事件循环将看到最快的定时器到达了阈值，然后折返回 <code>timers</code> 阶段去执行定时器回调。在上面的例子里，你将看到定时器从规划到它的回调被执行总共延时了 105ms（而不是预期的 100ms）。</p><blockquote><p><em>注：为了防止 <code>poll</code> 阶段“饿死”事件循环，<code>libuv</code>（实现了 Node.js 所有异步行为及事件循环的 C 库）有一个强制的最大值，到达最大值将会停止 <code>polling</code> 更多事件</em></p></blockquote><h3 id="pending-callbacks">pending callbacks</h3><p>此阶段执行某些系统操作（例如TCP错误类型）的回调。例如，如果 TCP 套接字在尝试连接时收到 ECONNREFUSED，则某些 <code>*nix</code> 系统希望等待报告错误。这将加入到 <code>pending callbacks</code> 的执行队列。</p><h3 id="poll">poll</h3><p><code>poll</code> 阶段有两个主要的功能</p><ol><li>计算 <code>poll</code> 阶段应该阻塞和轮询 I/O 多久，然后</li><li>处理 <code>poll</code> 队列里的事件代码</li></ol><p>当事件循环进入 <code>poll</code> 阶段，开始轮询，会按照下面的规则运行：</p><ol><li><p>如果 <code>poll</code> 队列不为空，事件循环将遍历回调队列同步执行直到队列耗尽或达到了系统强制的极限</p></li><li><p>如果 <code>poll</code> 队列为空，又分为以下两种情况</p><ol><li>如果脚本出现了 <code>setImmediate()</code> 规划（<code>setImmediate()</code> 的回调将加入 <code>check</code> 阶段的队列），事件循环将结束 <code>poll</code> 阶段，然后进入 <code>check</code> 阶段以执行 <code>setImmediate()</code> 的回调</li><li>如果脚本没有出现 <code>setImmediate()</code> 规划，事件循环将检查是否有定时器达到了阈值，根据是否有一个或多个 <code>timer</code> 达到了阈值，又可以分为以下两种情况：<ol><li>没有 <code>timer</code> 达到了阈值，事件循环将等待新的回调加到 <code>poll</code> 队列（incoming connection, request 等）</li><li>有一个或多个 <code>timer</code> 达到了阈值，事件循环将折回到 <code>timer</code> 阶段执行定时器的回调</li></ol></li></ol></li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">poll -----&gt; &lt;circle wait&gt;</span><br><span class="line">  |</span><br><span class="line">  |--------</span><br><span class="line">  |       |</span><br><span class="line">  v       v</span><br><span class="line">check    timer</span><br></pre></td></tr></table></figure><h3 id="check">check</h3><p>这个阶段允许我们<strong>在 <code>poll</code> 阶段完成后立即执行回调</strong>，如果 <code>poll</code> 阶段空闲（idle）并且脚本调用了 <code>setImmediate()</code>，事件循环将进入 <code>check</code> 阶段而不是等待。</p><p><code>setImmediate()</code> 实际上是一个特殊的定时器，它在事件循环的一个单独阶段运行。它使用 <code>libuv</code> API 来调度在 <code>poll</code> 阶段完成后执行的回调。</p><h3 id="close-callbacks">close callbacks</h3><p>如果一个 <code>socket</code> 或 <code>handle</code> 突然被关闭（例如：<code>socket.destroy()</code>，<code>close</code> 事件将会在这个阶段触发）。否则它将通过 <code>process.nextTick()</code> 来触发</p><h2 id="setimmediate-vs-settimeout">setImmediate() vs setTimeout()</h2><p><code>setImmediate()</code> 和 <code>setTimeout()</code> 相似，但是行为上的差异决定于它们合适被调用</p><ul><li><code>setImmediate()</code> 被设计用于一旦当前 <code>poll</code> 阶段完成后便执行其回调</li><li><code>setTimeout()</code> 规划在经过最小阈值（以 ms 为单位）后运行的脚本</li></ul><p>执行上面两个定时器的顺序将根据调用它们的上下文而有所不同。如果从主模块中调用两者，则时间将受到进程性能的限制（可能受到计算机上运行的其他应用程序的影响）。</p><p>例如，如果我们运行不在 I/O 周期内的以下脚本（即主模块中调用），则执行两个定时器的顺序是不确定的，因为它受到进程性能的约束：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout_vs_immediate.js</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>但是，如果移动到 I/O 周期内对两个进行调用，则始终首先执行 <code>setImmediate()</code> 的回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout_vs_immediate.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>使用 <code>setImmediate()</code> 而不是 <code>setTimeout()</code> 的主要优点是 <code>setImmediate()</code> 将始终在任何定时器之前执行（如果在相同的 I/O 周期内调度），与存在多少定时器无关。</p><h2 id="process-nexttick">process.nextTick()</h2><h3 id="理解-process-nexttick">理解 process.nextTick()</h3><p>你可能注意到了 <code>process.nextTick()</code> 不在上面的示意图表里，尽管它也是异步 API 的一部分。这是因为从技术上来说，<code>process.nextTick()</code> 不是事件循环的一部分。<code>process.nextTick()</code> 将会在当前操作（当前正在运行的队列中的某个回调）完成后马上被执行，不论当前处于事件循环处于哪个阶段。</p><p>回看之前的示意图，在给定阶段的任何时间调用 <code>process.nextTick()</code>，在继续事件循环之前，所有传入 <code>process.nextTick()</code> 的回调函数将会被执行。通过递归的 <code>process.nextTick</code>，会“饿死”你的 I/O，阻止事件循环到达 <code>poll</code> 阶段，导致出现一些糟糕的场景。</p><h3 id="为什么我们会这样做？">为什么我们会这样做？</h3><p>为什么 Node.js 中会出现 <code>process.nextTick()</code> 这样的东西？**有一部分原因是 Node.js 的设计理念：当某个 API 应该始终是异步的，即使在某些地方使用时不是必须的（这个时候 <code>process.nextTick()</code> 可以实现这种同步 API 向异步 API 的转化）**它不是必须的。以此代码段为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiCall</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'string'</span>)</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback,</span><br><span class="line">                            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument should be string'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段进行参数检查，如果不正确，它会将错误传递给回调。最近更新的 API 允许将参数传递给 <code>process.nextTick()</code>，允许它将回调后传递的任何参数作为参数传播到回调，因此您不必嵌套函数。</p><p>我们上面做的是将错误传回给用户，但只有在我们允许其余的用户代码（同步代码）执行之后。通过使用 <code>process.nextTick()</code>，我们保证 <code>apiCall()</code> 始终<strong>在用户代码的其余部分之后</strong>（即当前的所有同步代码执行之后）和<strong>允许事件循环继续之前</strong>运行其回调。为了实现这个，JS 调用栈允许被展开，然后立即执行传入的回调函数，回调函数允许我们继续递归调用 <code>process.nextTick()</code> 而不会触发 <code>RangeError: Maximum call stack size exceeded from v8.</code></p><blockquote><p><em>笔者注：调用栈展开又可成为调用栈释放</em></p></blockquote><blockquote><p><em>笔者注：此处的意思是指 <code>process.nextTick(() =&gt; {})</code> 的方式会导致函数调用栈溢出的问题，而 <code>process.nextTick(fn, args)</code> 则可以防止函数调用栈溢出</em></p><p><em>笔者注：类似尾递归优化的原理</em></p></blockquote><p>（如果没有 <code>process.nextTick()</code> 来转化为异步 API）这种理念（即某些 API 必须是异步的）可能会导致一些潜在的问题。以此片段为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this has an asynchronous signature, but calls callback synchronously</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the callback is called before `someAsyncApiCall` completes.</span></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// since someAsyncApiCall has completed, bar hasn't been assigned any value</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>用户将 <code>someAsyncApiCall()</code> 定义为具有异步签名（函数名中体现了），但它实际上是同步操作。调用它时，在事件循环的同一阶段调用提供给 <code>someAsyncApiCall()</code> 的回调，因为 <code>someAsyncApiCall()</code> 实际上不会异步执行任何操作。因此，回调尝试引用变量 <code>bar</code>，尽管它在范围内可能没有该变量，因为该脚本还没有运行完成。</p><p>通过将回调函数放置在 <code>process.nextTick()</code>，脚本便能够运行完整（同步代码能全部执行完），允许在调用回调之前初始化所有变量，函数等。它还具有暂时跳出事件循环继续的优点。<strong>在允许事件循环继续之前，向用户警告错误可能是有用的</strong>。以下前一个示例使用 <code>process.nextTick()</code> 的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这是一个实际的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>当只有一个端口作为参数传入，端口立即被绑定。所以注册的 <code>listening</code> 回调可以设置为立即被调用。问题是：<code>on('listening')</code> 回调在那时可能还没被注册。</p><p>为了解决这个问题，<code>listening</code> 事件通过 <code>nextTick()</code> 被入队（nextTick Queue）以允许脚本先执行完（同步代码）。这允许用户（在同步代码中）设置任何他们需要的事件处理函数。</p><h2 id="process-nexttick-vs-setimmediate">process.nextTick() vs setImmediate()</h2><p>就用户而言，我们有两个类似的呼叫，但它们的名称令人困惑。</p><ul><li><code>process.nextTick()</code> 在当前阶段<strong>立即</strong>被触发</li><li><code>setImmediate()</code> 在事件循环的下一趟迭代或称之为 <code>tick</code> 触发</li></ul><blockquote><p><em>注：这里的一个一趟迭代指的是一个阶段队列的遍历执行</em></p></blockquote><p>实质上，应该交换名称。 <code>process.nextTick()</code> 比 <code>setImmediate()</code> 更 ‘immediate’，但这是过去已经定好的，不太可能改变。做出这个交换会破坏 <code>npm</code> 上的大部分包。每天都会产生更多新模块，这意味着我们多等待一天，做出交换会带来更多的潜在的破损。尽管这两个的名称造成了困惑，但它们的名字不会改变。</p><p>我们推荐开发者在所有情景下都使用 <code>setImmediate()</code>，因为它更容易被理解（并且它有着更广泛的环境兼容性，例如在浏览器的 JS 里）。</p><h2 id="为什么要使用-process-nexttick">为什么要使用 process.nextTick()</h2><p>两个理由：</p><ol><li><p>允许用户处理错误（将错误通过 <code>process.nextTick(fn, error)</code> 传递给 <code>fn</code>），清除任何不需要的资源（例如在 <code>nextTick</code> 手动解除同步代码中的内存引用），或者在事件循环继续之前再次尝试请求</p></li><li><p>有时需要允许回调在调用栈展开之后但在事件循环继续之前运行。</p></li></ol><p>一个例子是为了匹配用户的期望：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, (conn) =&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><p>假设 <code>listen()</code> 在事件循环开始时运行，但是 <code>listening</code> 回调用 <code>setImmediate()</code> 包裹。除非传递 <code>hostname</code>，否则将立即绑定到端口（并立即触发 <code>listening</code> 事件）。要想事件循环继续，它必须先达到轮询阶段，这意味着存在一个可能的空窗期：在 <code>listening</code> 事件的代码（用 <code>setImmediate()</code> 包裹的）执行前就收到了一个连接，也就是相当于先于 <code>listening</code> 触发了 <code>connection</code> 事件。</p><blockquote><p><em>注：使用 <code>process.nextTick()</code> 可以规避这个问题，保证 <code>listening</code> 的回调先触发</em></p></blockquote><p>另一个例子是运行一个函数构造函数，比如继承自 <code>EventEmitter</code>，它想在构造函数中调用一个事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>您无法立即从构造函数中真正触发事件，因为脚本还没有运行到用户为该事件分配回调的位置。因此，在构造函数本身中，您可以使用 <code>process.nextTick()</code> 来设置回调以在构造函数完成后发出事件，从而提供预期的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use nextTick to emit the event once a handler is assigned</span></span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 异步 </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用白鹭引擎开发微信小游戏的一些流程改进</title>
      <link href="/2018/10/24/wx-minigame-dev-using-egret/"/>
      <url>/2018/10/24/wx-minigame-dev-using-egret/</url>
      <content type="html"><![CDATA[<p>微信小游戏是运行在微信环境下的类 HTML5 游戏，可以使用诸如 Laya, cocos2d, egret 等 HTML5 游戏引擎来进行开发。笔者最近使用 egret engine（白鹭引擎）开发了两款微信小游戏，一款单机，另一款支持联机对战，下文是在这两个项目中使用 egret 总结出的个人最佳实践。</p><img src="/2018/10/24/wx-minigame-dev-using-egret/ctg.jpg" title="插糖果"><img src="/2018/10/24/wx-minigame-dev-using-egret/tty.jpg" title="来追我鸭"><a id="more"></a><h2 id="原理">原理</h2><p>将 egret 发布为微信小游戏后会发现导出的目录 <code>xxx-wxgame</code> 下有以下文件和目录：</p><img src="/2018/10/24/wx-minigame-dev-using-egret/output-dir.jpg" title="导出目录"><p>图中标注的部分就是 egret 为生成微信小游戏做的工作。其中 <code>egret.wxgame.js</code>, <code>weapp-adapter.js</code> 和 <code>library</code> 是 DOM/BOM API 及白鹭 API 向微信小游戏适配的代码，使得我们面向 egret 编写的特异代码能无缝迁移到微信小游戏环境下运行，<code>openDataContext</code> 是开放数据域代码目录。</p><h2 id="问题1：platform-ts-与-platform-js">问题1：Platform.ts 与 platform.js</h2><p>按照 egret 给的工作流，源码里的 <code>Platform.ts</code> 只是用于 egret 自带的调试工具调试时使用，使用假数据模拟微信平台接口的返回值，编译之后生成的是对应的 <code>platform.js</code>。</p><p>这里存在两个问题：</p><ol><li><code>Platform.ts</code> 不会（也不应该）直接同步编译到 <code>platform.js</code> 中，所以这部分代码得编写/修改两次</li><li><code>platform.js</code> 无法从 <code>Platform.ts</code> 直接编译得到，所以项目源码与导出的微信小游戏代码都得加入代码库进行管理</li></ol><p>我的解决方案：基本抛弃白鹭工作流里的 <code>Platform.ts</code>，实现自己 <code>Platfrom</code> 处理模式。</p><img src="/2018/10/24/wx-minigame-dev-using-egret/platform.jpg" title="platform改良机制后目录"><p>在 <code>src</code> 源码里实现 <code>Platform</code> 机制，最终平台代码直接打包到我们的输出的 <code>main.min.js</code> 中，对于 <code>wx</code> 对象不存在无法通过编译的问题使用 <code>src/global.d.ts</code> 编写类型声明来解决。</p><img src="/2018/10/24/wx-minigame-dev-using-egret/platform-code.jpg" title="具体代码方案"><p>这样平台代码只需要在一处进行编写，而不需要向之前一样：在 <code>wing</code>（egret 提供的基于 VS Code 改造的编辑器）编写/修改完平台代码后，还需要在微信开发者工具内编写/改写 <code>platform.js</code>。</p><p>其实包括下面的问题 2 都是围绕着一个核心思路来改造工作流：一处编辑，无需切换到微信开发者工具去修改代码。</p><h2 id="问题2：开放数据域">问题2：开放数据域</h2><p>egret 在导出微信小游戏时，会生成一个比较简单的 <code>openDataContext</code> 目录到输出目录，最终开放数据域代码的编写需要切换到微信开发者工具去编写。</p><p>所以对于开放数据域，也会存在与 <code>Platform</code> 相类似的问题1，解决思路是利用 egret 编译任务定制功能。</p><p>首先我们直接在项目下自己新增 <code>openDataContext</code> 目录，里面放置的全部是开放数据域相关的代码。</p><img src="/2018/10/24/wx-minigame-dev-using-egret/openDataContext.jpg" title="openDataContext改进后目录"><p>然后我们修改 <code>scripts/wxgame/wxgame.ts</code> 中的任务代码，实现我们的需求：<strong>最终直接使用源码目录的 <code>openDataContext</code>，而不使用白鹭帮忙生成的 <code>openDataContext</code></strong></p><p>思路是：删除 egret 生成的 <code>openDataContext</code>（可选），递归复制源码目录的 <code>openDataContext</code> 到微信小游戏导出目录下，（可选）也可以先进行代码打包、压缩再复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cp <span class="keyword">from</span> <span class="string">'child_process'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFileSync</span>(<span class="params">source, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> targetFile = target</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(target)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.lstatSync(target).isDirectory()) &#123;</span><br><span class="line">            targetFile = path.join(target, path.basename(source))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fs.writeFileSync(targetFile, fs.readFileSync(source))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFolderRecursiveSync</span>(<span class="params">source, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> files = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> targetFolder = path.join(target, path.basename(source));</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(targetFolder)) &#123;</span><br><span class="line">        fs.mkdirSync(targetFolder)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fs.lstatSync(source).isDirectory()) &#123;</span><br><span class="line">        files = fs.readdirSync(source)</span><br><span class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> curSource = path.join(source, file)</span><br><span class="line">            <span class="keyword">if</span> (fs.lstatSync(curSource).isDirectory()) &#123;</span><br><span class="line">                copyFolderRecursiveSync(curSource, targetFolder)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                copyFileSync(curSource, targetFolder)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFolderRecursive</span>(<span class="params">folder: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> files = [];</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(folder)) &#123;</span><br><span class="line">        files = fs.readdirSync(folder)</span><br><span class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> curPath = folder + <span class="string">"/"</span> + file</span><br><span class="line">            <span class="keyword">if</span> (fs.lstatSync(curPath).isDirectory()) &#123;</span><br><span class="line">                deleteFolderRecursive(curPath);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fs.unlinkSync(curPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        fs.rmdirSync(folder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WxgamePlugin</span> <span class="title">implements</span> <span class="title">plugins</span>.<span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> onFile(file: plugins.File) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> onFinish(pluginContext: plugins.CommandContext) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他定制任务</span></span><br><span class="line">        copyFileSync(<span class="string">`<span class="subst">$&#123;pluginContext.projectRoot&#125;</span>/platform.js`</span>, <span class="string">`<span class="subst">$&#123;pluginContext.outputDir&#125;</span>/platform.js`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开放数据域</span></span><br><span class="line">        <span class="keyword">const</span> openDataContextTargetPath = path.join(pluginContext.outputDir, <span class="string">'openDataContext'</span>)</span><br><span class="line">        <span class="keyword">const</span> openDataContextSrcPath = path.join(pluginContext.projectRoot, <span class="string">'openDataContext'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除输出目录的 `openDataContext`，再复制 `openDataContext` 目录到输出目录</span></span><br><span class="line">        <span class="comment">// deleteFolderRecursive(openDataContextTargetPath)</span></span><br><span class="line">        <span class="comment">// copyFolderRecursiveSync(openDataContextSrcPath, pluginContext.outputDir)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打包压缩输出</span></span><br><span class="line">        cp.exec(<span class="string">`webpack --entry <span class="subst">$&#123;openDataContextSrcPath&#125;</span>/index.js -o <span class="subst">$&#123;openDataContextTargetPath&#125;</span>/index.js`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以自己再进行特异化订制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们每次点击发布或执行 <code>egret publish</code> 时便会同步源码目录的 <code>openDataContext</code> 到输出目录，也达到了我们只需要在 <code>wing</code> 这一处编写所有代码的需求。</p><h2 id="问题3：代码的压缩与二次混淆">问题3：代码的压缩与二次混淆</h2><p>在未对白鹭工作流作任何修改的情况下，白鹭输出时会进行编译、打包和简单的压缩混淆，但是混淆的还是不够，且开放数据域的代码无法被打包，尤其是当两款游戏用到了一些公用组件时，直接用白鹭输出的代码包去微信那边提审有可能会因为代码包查重通不过而被拒。</p><p>对于开放数据域来说，代码的压缩已经在问题2中顺便给解决了。</p><p>而游戏逻辑代码输出的文件是 <code>main.min.js</code>，这样混淆的方案就随你选择了，你可以使用 <code>uglifyjs</code> 来对输出的 <code>main.min.js</code> 来进行压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换 $&#123;...&#125; 为你对应源码目录和发布目录</span></span><br><span class="line">uglifyjs -o <span class="variable">$&#123;pluginContext.outputDir&#125;</span>/js/main.min.js <span class="variable">$&#123;pluginContext.outputDir&#125;</span>/js/main.min.js --toplevel -c</span><br></pre></td></tr></table></figure><h2 id="其他小问题">其他小问题</h2><h3 id="微信开发者工具经常黑屏">微信开发者工具经常黑屏</h3><p>解决方案：关掉微信开发者工具的文件变动时自动编译可以缓解</p><h3 id="第三方模块">第三方模块</h3><p>笔者是在源码目录新建一个 <code>3rd</code> 的目录放置第三方模块</p><img src="/2018/10/24/wx-minigame-dev-using-egret/3rd.jpg" title="第三方模块"><br><br>下一篇笔者将继续分享游戏代码层面遇到的问题和解决方案。]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 微信小游戏 </tag>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 排版中的 vertical-align</title>
      <link href="/2018/05/05/vertical-align-and-web-typography/"/>
      <url>/2018/05/05/vertical-align-and-web-typography/</url>
      <content type="html"><![CDATA[<p>如果你对 Web 排版中的 <code>vertical-align</code> 一直捉摸不透，那么这篇文章可能便是你一直想要寻找的资料了。</p><a id="more"></a><h2 id="基本概念">基本概念</h2><p><img src="http://static.zybuluo.com/yangfch3/mkpa9vcl1km2hv4uvkygjj3m/image_1bafbonhdkmunvt10s2a232b61g.png" alt="image_1bafbonhdkmunvt10s2a232b61g.png-23.9kB"></p><center>浏览器中的大小写字母、中文混排</center><h3 id="基线与行高">基线与行高</h3><p>基线：<code>baseline</code><br>行高：<code>line-height</code></p><p>为了表述的方便，我们首先回到小时候看看曾经使用过的拼音线格：<br><img src="http://static.zybuluo.com/yangfch3/cqadi1c1y1oko5yjufygku54/image_1bafau0ji1nb01oea1h1012icqks13.png" alt="image_1bafau0ji1nb01oea1h1012icqks13.png-329.5kB"></p><p>从上图我们基本就能明确基线与行高两个概念了：</p><ol><li>基线：多数字母排列的基准线</li><li>段落中连续行的基线间的垂直距离称为行高（Line Height）或行距（Leading）</li></ol><p>思考与扩展：当我们没有指定确定的行高时，浏览器给予行内元素的行高是多少？</p><blockquote><ol><li>没有确定行高时，其 <code>line-height</code> 的值默认为 <code>normal</code></li><li>对于没有使用行内元素包裹的文字（如：<code>&lt;div&gt;abc&lt;/div&gt;</code>），浏览器在底层的处理相当于为这些文字包上一层行内元素（相当于 <code>&lt;div&gt;&lt;span&gt;abc&lt;/span&gt;&lt;/div&gt;</code>）</li><li>浏览器为行内元素设置的默认行高 <code>normal</code> 取值随着字体大小、字体类型的变化而变化</li></ol></blockquote><h3 id="x-height">x-height</h3><p><code>x</code> 这个字母在排版中具有不俗的地位，下面来看看如何个不俗法。</p><p><img src="http://static.zybuluo.com/yangfch3/u6xpmwsuni6y75kkkteixe7z/image_1bafc7uglqo61ote1j521flct511t.png" alt="image_1bafc7uglqo61ote1j521flct511t.png-30kB"></p><p><code>x-height</code> 指的便是小写字母 <code>x</code> 字母的实际物理高度。为什么会选择 <code>x</code> 呢，可能是因为其良好的对称性、上下边缘平整才成为这个天选之子吧。</p><p>这里为什么会莫名其妙地说起 <code>x-height</code> 这个概念呢？在前端有什么用呢？</p><p>请继续往下阅读吧，可以预告一下：<code>x-height</code> 与我们今天的主角 <code>vertical-align</code> 有联系。</p><h3 id="小写字母的-下沉">小写字母的“下沉”</h3><p>首先上一段代码：<br><img src="http://static.zybuluo.com/yangfch3/ebqehj53esh0opdhgb873q8o/image_1bafdkra71u6dotkkub17l8cpt2a.png" alt="image_1bafdkra71u6dotkkub17l8cpt2a.png-33.3kB"></p><p>看看实际效果：<br><img src="http://static.zybuluo.com/yangfch3/c80337hz0ibfj8qfouqfkthw/image_1bafdn8011bb71ogq1eaecdo1o0a34.png" alt="image_1bafdn8011bb71ogq1eaecdo1o0a34.png-31.3kB"></p><p>然后我们来<strong>局部放大小写字母</strong>部分，通过对角线找到 <strong>行盒</strong> 的垂直中线（图中竖直方向中间的红线），与 <code>x</code> 的中心位置进行对比便能发现：<strong>行盒垂直方向的中线高于小写的 <code>x</code> 的中心点</strong>。<br><img src="http://static.zybuluo.com/yangfch3/aj7g136ex9a7sizpm210w7p9/image_1bafdmmadvrc19dqur71927q732n.png" alt="image_1bafdmmadvrc19dqur71927q732n.png-142.9kB"></p><p>这个情况，可以形象地记忆为小写字母的 <strong>下沉</strong>。</p><h3 id="文本排版参考线">文本排版参考线</h3><p><img src="http://static.zybuluo.com/yangfch3/wxwyxkakjmqqr1luakis57s1/image_1bafetjs27d11udtiu94c11o279.png" alt="image_1bafetjs27d11udtiu94c11o279.png-30.4kB"></p><center>一图看懂</center><h2 id="进阶">进阶</h2><h3 id="关于网页中的图片">关于网页中的图片</h3><p>图片做为网页中特殊的行内元素，但是图片又不是文字，为了更好阐述下文图文混排的知识，根据经验我做出如下阐述：</p><ol><li>图片的 <code>baseline</code>、<code>bottom</code> 可以认为位置相同，都是图片的底边位置</li><li>图片的 <code>top</code> 可以认为是图片的上边位置</li><li>图片不是文本，所以我们可以认为图片没有所谓的 <code>text-top</code>、<code>text-bottom</code>、<code>sub</code>、<code>sup</code> 概念</li></ol><h3 id="莫名出现的空白">莫名出现的空白</h3><p>源码：<br><img src="http://static.zybuluo.com/yangfch3/y34n1nb1b6gpb9yt3b4b0ui3/image_1bafhcotm12m338av3o15cj1nul13.png" alt="image_1bafhcotm12m338av3o15cj1nul13.png-25.9kB"></p><p>效果：<br><img src="http://static.zybuluo.com/yangfch3/p5186vgoyogkpkecn921ugll/image_1bafhd8nsmj31vj71mcdjkjc831g.png" alt="image_1bafhd8nsmj31vj71mcdjkjc831g.png-12.6kB"></p><p>嗯，出现了莫名的空白，其实这也是我们经常遇到的问题，这个空白出现的原因是什么呢？</p><blockquote><p>想通这个问题很简单，你只要先假设图片的相邻处有文字，思考图片文字的对齐方案，单后再把文字去掉就能想通了。</p></blockquote><p>值得注意的是这个空白只有在标准模式下渲染才会出现，在接近标准模式（HTML 4.0）、怪异模式（HTML 3.0、IE5-）下渲染不会有。</p><p>那么我们如何消除这个空白呢？</p><ol><li>外层块盒设置 <code>font-size: 0</code></li><li>外层块盒 <code>line-height</code> 设置得足够小（在 Chrome 下设置要小于 12px）</li></ol><h3 id="合成行盒的各排版参考线">合成行盒的各排版参考线</h3><p>合成行盒就是类似下面这种情况，简单点说便是图片文字混排的情况</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>XYZ<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过测试，我们能得到以下结果：合成行盒各排版参考线情况<br><img src="http://static.zybuluo.com/yangfch3/n4d9u34113xwte420m2wasc4/image_1bafi8hrat54ob91c9l1fch14br9.png" alt="image_1bafi8hrat54ob91c9l1fch14br9.png-110.1kB"></p><blockquote><p>修正：图中的 <code>x-height</code> 应为 <strong>半<code>x-height</code></strong></p></blockquote><p>总结的几个原则：</p><ol><li>大部分排版参考线只由这里面字体最小的那部分确定</li><li>大图能决定合成行盒的 <code>top</code></li></ol><h2 id="vertical-align-详解">vertical-align 详解</h2><p>请认认真真地咀嚼下面的结论，遇到具体情境时再结合上文的手段进行分析，你就能得出正确的对齐手段。</p><blockquote><p><strong>baseline</strong>：把当前盒的基线与父盒的基线对齐。如果该盒没有基线（如图片），就将底部外边距的边界和父盒的基线对齐<br><strong>sub</strong>：把当前盒的基线降低到合适的位置作为父盒的下标（该值不影响该元素文本的字体大小）<br><strong>super</strong>：把当前盒的基线提升到合适的位置作为父盒的上标（该值不影响该元素文本的字体大小）<br><strong>text-top</strong>：把当前盒的 top 和**父盒的内容区的 top（即父盒的 text-top）<strong>对齐<br><strong>text-bottom</strong>：把当前盒的 bottom 和</strong>父盒的内容区的 bottom （即父盒的 text-bottom）<strong>对齐<br><strong>middle</strong>：把当前盒的垂直中心和父盒的基线加上父盒的半 x-height 对齐<br><strong>top</strong>：把当前盒的 top 与</strong>行盒的 top（父盒下合成行盒的 top）<strong>对齐<br><strong>bottom</strong>：把当前盒的 bottom 与</strong>行盒的 bottom（父盒下合成行盒的 bottom）**对齐<br><strong><code>&lt;percentage&gt;</code></strong>：把当前盒提升（正值）或者降低（负值）这个距离，百分比是相对元素自身 line-height 计算。当值为 0% 时等同于 baseline。<br><strong><code>&lt;length&gt;</code></strong>：把当前盒提升（正值）或者降低（负值）这个距离。当值为 0 时等同于 baseline。（CSS2）</p></blockquote><hr><h2 id="附录">附录</h2><p>一个用于测试的简单的、经典的页面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cmn-Hans"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1,user-scalable=no,width=device-width,shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>vertical-align demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">几个可以尝试的扩展练习：</span></span><br><span class="line"><span class="comment">1. 尝试先将图片确定为某个 vertical-align 值，再来变更两个 span 的 vertical-align 值，查看效果，分析原理</span></span><br><span class="line"><span class="comment">2. 尝试随意地为两个 span 和一个 img 分配 vertical-align 值，查看效果，分析原理</span></span><br><span class="line"><span class="comment">3. 如果 span 内文字多行会怎么样？</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:#E5EDFF;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff;font-size: 40px;"</span>&gt;</span>ZXXXxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://dummyimage.com/300x200/000/fff"</span> <span class="attr">style</span>=<span class="string">"width: 300px; height: 200px;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 23px;"</span>&gt;</span>zxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">可以尝试的扩展练习：为最外层 div 内的各个元素随机设置 vertical-align，查看效果，分析原理</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: #ccc"</span>&gt;</span>zxxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:#E5EDFF; display: inline-block"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 40px;"</span>&gt;</span>ZXXXxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://dummyimage.com/300x200/000/fff"</span> <span class="attr">style</span>=<span class="string">"width: 300px; height: 200px;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 23px;"</span>&gt;</span>zxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 排版 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pm2 与 log4js 混用指南</title>
      <link href="/2018/04/22/log4js-with-pm2/"/>
      <url>/2018/04/22/log4js-with-pm2/</url>
      <content type="html"><![CDATA[<p>我相信你是在使用 <code>pm2</code> 和 <code>log4js</code> 中踩到了坑才会搜素到这篇文章，我便假定你已经对二者都有了基本的了解，遂不再赘述二者的介绍。</p><p><code>pm2</code> 在使用 <code>cluster</code> 模式部署应用时，服务都通过 <code>worker</code> 进程提供，<code>pm2</code> 做为 <code>master</code> 进行监控管理。</p><img src="/2018/04/22/log4js-with-pm2/pm2.png" title="pm2"><p>由于存在多个 <code>worker</code> 进程，那么我们在使用 <code>log4js</code> 进行日志记录时会有下列疑问：</p><ol><li>多个 <code>worker</code> 进程能否正常写入同一个日志文件</li><li>要实现 1，<code>pm2</code> 需要作何处理，<code>log4js</code> 需要作何处理</li></ol><a id="more"></a><h2 id="退而求其次：多进程分日志？">退而求其次：多进程分日志？</h2><p>首先来尝试“逃避”上面的两个问题。</p><p>要“逃避”上面疑问最简易的方案就是：每个进程写入自己的日志文件（例如：<code>robotService-worker&lt;id&gt;.log</code>）。只需要对 <code>log4js</code> 做一下简易的设置即可实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    disableClustering: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案带来了<strong>日志分散、查阅与处理不方便</strong>的问题，一般情况下不采用。此方案较为经典的使用场景是 <code>pomelo</code> 的多进程游戏日志采集（但 <code>pomelo</code> 不是使用 <code>cluster</code> 来搭建集群）。</p><h2 id="log4js-与-pm2-相关源码">log4js 与 pm2 相关源码</h2><p><code>lib/log4js</code> 下的 <code>getLogger</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a logger instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@static</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loggerCategoryName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;Logger&#125; instance of logger for the category</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLogger</span><span class="params">(category)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">    configure(process.env.LOG4JS_CONFIG || defaultConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cat = category || <span class="string">'default'</span>;</span><br><span class="line">  debug(`creating logger <span class="keyword">as</span> $&#123;isMaster() ? <span class="string">'master'</span> : <span class="string">'worker'</span>&#125;`);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Logger((isMaster() ? sendLogEventToAppender : workerDispatch), cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明 <code>log4js</code> 在 <code>cluster</code> 集群模式下与单进程模式（<strong><code>isMaster</code> 方法来区分</strong>）下获取 <code>logger</code> 的存在差异。我们关注到 <code>log4js</code> 在 <code>worker</code> 进程下执行的是 <strong><code>workerDispatch</code></strong>。</p><p>下面是 <code>isMaster</code> 的源码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPM2Master</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.pm2 &amp;&amp; process.env[<span class="built_in">config</span>.pm2InstanceVar] === <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMaster</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.disableClustering || cluster.isMaster || isPM2Master();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明 <code>log4js</code> 对普通的 <code>cluster</code> 模式和 <code>pm2</code> 的 <code>cluster</code> 模式又做了区分。我们留意到有两个可配置项：<code>pm2</code> <code>pm2InstanceVar</code>，可以查看 <code>log4js</code> 的<a href="https://log4js-node.github.io/log4js-node/api.html" target="_blank" rel="noopener">文档</a>了解这两个配置项。</p><p>继续看 <code>workerDispatch</code> 的源码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">workerDispatch</span>(logEvent) &#123;</span><br><span class="line">  <span class="selector-tag">debug</span>(<span class="built_in">`sending message to master from worker $&#123;process.pid&#125;`</span>);</span><br><span class="line">  <span class="selector-tag">process</span><span class="selector-class">.send</span>(&#123; <span class="attribute">topic</span>: <span class="string">'log4js:message'</span>, <span class="attribute">data</span>: serialise(logEvent) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以得知：<strong>在 pm2 cluster 模式下，<code>log4js</code> 不在 worker 进程直接记录日志，而是将需要记录日志的消息发送给 <code>master</code> 进程。</strong></p><p><code>log4js</code> 既然有发送消息的代码，那肯定有接收消息的代码，下面是接收消息的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">configurationFileOrObject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> configObject = configurationFileOrObject;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> configObject === <span class="string">'string'</span>) &#123;</span><br><span class="line">    configObject = loadConfigurationFile(configurationFileOrObject);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(<span class="string">`Configuration is <span class="subst">$&#123;configObject&#125;</span>`</span>);</span><br><span class="line">  config = <span class="keyword">new</span> Configuration(configObject);</span><br><span class="line">  <span class="built_in">module</span>.exports.levels = config.levels;</span><br><span class="line">  <span class="keyword">const</span> loggerModule = logger(config.levels, levelForCategory, setLevelForCategory);</span><br><span class="line">  Logger = loggerModule.Logger;</span><br><span class="line">  LoggingEvent = loggerModule.LoggingEvent;</span><br><span class="line">  <span class="built_in">module</span>.exports.connectLogger = connectModule(config.levels).connectLogger;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// just in case configure is called after shutdown</span></span><br><span class="line">  process.removeListener(<span class="string">'message'</span>, receiver);</span><br><span class="line">  <span class="keyword">if</span> (cluster) &#123;</span><br><span class="line">    cluster.removeListener(<span class="string">'message'</span>, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.disableClustering) &#123;</span><br><span class="line">    debug(<span class="string">'Not listening for cluster messages, because clustering disabled.'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPM2Master()) &#123;</span><br><span class="line">    <span class="comment">// PM2 cluster support</span></span><br><span class="line">    <span class="comment">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></span><br><span class="line">    <span class="comment">// we only want one of the app instances to write logs</span></span><br><span class="line">    debug(<span class="string">'listening for PM2 broadcast messages'</span>);</span><br><span class="line">    process.on(<span class="string">'message'</span>, receiver);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    debug(<span class="string">'listening for cluster messages'</span>);</span><br><span class="line">    cluster.on(<span class="string">'message'</span>, receiver);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    debug(<span class="string">'not listening for messages, because we are not a master process'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> log4js;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// in a multi-process node environment, worker loggers will use</span></span><br><span class="line"><span class="comment">// process.send</span></span><br><span class="line"><span class="keyword">const</span> receiver = <span class="function">(<span class="params">worker, message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// prior to node v6, the worker parameter was not passed (args were message, handle)</span></span><br><span class="line">  debug(<span class="string">'cluster message received from worker '</span>, worker, <span class="string">': '</span>, message);</span><br><span class="line">  <span class="keyword">if</span> (worker.topic &amp;&amp; worker.data) &#123;</span><br><span class="line">    message = worker;</span><br><span class="line">    worker = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (message &amp;&amp; message.topic &amp;&amp; message.topic === <span class="string">'log4js:message'</span>) &#123;</span><br><span class="line">    debug(<span class="string">'received message: '</span>, message.data);</span><br><span class="line">    sendLogEventToAppender(deserialise(message.data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendLogEventToAppender</span>(<span class="params">logEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span>;</span><br><span class="line">  debug(<span class="string">'Received log event '</span>, logEvent);</span><br><span class="line">  <span class="keyword">const</span> appenders = appendersForCategory(logEvent.categoryName);</span><br><span class="line">  appenders.forEach(<span class="function">(<span class="params">appender</span>) =&gt;</span> &#123;</span><br><span class="line">    appender(logEvent);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是日志是由 <code>worker</code> --①–&gt; pm2 <code>master</code> --②–&gt; <code>worker</code> 进行的传递，其思路就是日志只由一个 <code>worker</code> 去记录。<strong>而 ② 处的转发以及选择哪一个 <code>worker</code> 去接收就需要 <code>pm2-intercom</code> 这个 pm2 的 module 来处理了。</strong></p><h2 id="结论">结论</h2><p>要解决前言中的两个疑问，可以这样做：</p><ol><li><code>pm2</code> 安装 <code>pm2 install pm2-intercom</code></li><li><code>log4js</code> 启用以下配置： <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    pm2: <span class="literal">true</span></span><br><span class="line">    <span class="string">//</span> <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="结束了？">结束了？</h2><p>没有。</p><p>在上面的代码中我们发现 <code>isPM2Master</code> 的判断中有这样一句代码：<code>process.env[config.pm2InstanceVar] === '0'</code>。</p><p>我们查阅 <code>pm2</code> 的<a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="noopener">文档</a>发现，<code>pm2</code> 的进程都是有编号的，默认使用 <code>NODE_APP_INSTANCE</code> 环境变量（<strong>可以自己配置指定</strong>）上标识是 <code>master</code>（=== ‘0’） 还是 <code>worker</code>。<code>log4js</code> 也是根据这个特征来实现 <code>isPM2Master</code> 检测。</p><p>但是 <code>pm2</code> 不一定使用默认的 <code>NODE_APP_INSTANCE</code> 环境变量来编号，可能会变化——可能是用户自己定义了其他名称（例如<code>node-config</code> 将这个环境变量字段占用了，<code>pm2</code> 只能改用其他的），所以当 <code>pm2</code> 改变了字段名时，<code>log4js</code> 要做相应的配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">pm2InstanceVar</span>: <span class="string">'INSTANCE_ID'</span>; <span class="comment">// 默认 NODE_APP_INSTANCE，与 pm2 的配置保持一致即可</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附赠：单机多-pm2-实例">附赠：单机多 pm2 实例</h2><p>一台机器上可以部署多个 pm2 实例，这在我们需要再一台机器上部署多个不同的服务时可以用到，例如我们可能同时在一台机器上部署 <code>web-server</code> 和 <code>api-server</code>（因为机器紧张等原因）。</p><p>当我们第一次调用 <code>pm2</code> 时，我们会发现 <code>$HOME/.pm2</code> 目录被创建，里面存储着 <strong>（该）<code>pm2</code> 实例</strong> 的运行信息和日志输出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app<span class="selector-class">.js</span> -<span class="selector-tag">i</span> <span class="number">3</span> --name=web-server</span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># pwd</span></span><br><span class="line">/home/admin/.pm2</span><br><span class="line"></span><br><span class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># ls -a -l</span></span><br><span class="line">total 72</span><br><span class="line">drwxrwxr-x  <span class="number"> 5 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:19 .</span><br><span class="line">drwx------.<span class="number"> 12 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 11 </span>09:53 ..</span><br><span class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:20 logs</span><br><span class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin  <span class="number"> 127 </span>Mar<span class="number"> 28 </span>20:58 module_conf.json</span><br><span class="line">drwxrwxr-x  <span class="number"> 3 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 28 </span>20:55 modules</span><br><span class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 16 </span>15:24 pids</span><br><span class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin<span class="number"> 34054 </span>Apr<span class="number"> 16 </span>15:24 pm2.log</span><br><span class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin    <span class="number"> 4 </span>Mar<span class="number"> 29 </span>17:19 pm2.pid</span><br><span class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 pub.sock</span><br><span class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 rpc.sock</span><br><span class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin   <span class="number"> 13 </span>Mar<span class="number"> 24 </span>15:12 touch</span><br></pre></td></tr></table></figure><p>所以要创建多个 <code>pm2</code> 实例就需要每个实例使用不同的目录来存储运行信息。<code>pm2</code> 使用 <code>PM2_HOME</code> 环境变量来识别存储运行信息的目录：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 start app.js -i --name=web-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有和 web-server 集群相关的 pm2 命令都加上 PM2_HOME</span></span><br><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 list</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 start app.js -i --name=api-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有和 api-server 集群相关的 pm2 命令都加上 PM2_HOME</span></span><br><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 list</span><br></pre></td></tr></table></figure><p>为特定的 <code>pm2</code> 实例安装模块：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 install pm2-intercom</span><br><span class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 install pm2-intercom</span><br></pre></td></tr></table></figure><p>Tip：pm2 模块的安装可以不使用线上下载安装的方式（例如不方便执行 <code>pm2 install</code> 操作时），你只需要将模块放到 <code>modules</code> 目录下，然后修改 <code>module_conf.json</code> 注册模块即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dump.pm2</span><br><span class="line">├── dump<span class="selector-class">.pm2</span><span class="selector-class">.bak</span></span><br><span class="line">├── logs</span><br><span class="line">├── module_conf.json</span><br><span class="line">├── modules</span><br><span class="line">│   └── pm2-intercom</span><br><span class="line">│       ├── etc</span><br><span class="line">│       ├── node_modules</span><br><span class="line">│       └── package-lock.json</span><br><span class="line">├── pids</span><br><span class="line">├── pm2.log</span><br><span class="line">├── pm2.pid</span><br><span class="line">├── pub.sock</span><br><span class="line">├── rpc.sock</span><br><span class="line">└── touch</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// module_conf.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"pm2-intercom"</span>: &#123;</span><br><span class="line">        <span class="string">"default-strategy"</span>: <span class="string">"broadcast"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"module-db-v2"</span>: &#123;</span><br><span class="line">        <span class="string">"pm2-intercom"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pm2 </tag>
            
            <tag> log4js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细说 S.O.L.I.D</title>
      <link href="/2017/11/05/SOLID/"/>
      <url>/2017/11/05/SOLID/</url>
      <content type="html"><![CDATA[<p><code>S.O.L.I.D</code> 五原则（以下简称五原则）：</p><ul><li><strong>单一功能原则</strong></li><li><strong>开放封闭原则</strong></li><li><strong>里氏替换原则</strong></li><li><strong>接口隔离原则</strong></li><li><strong>依赖反转原则</strong>。</li></ul><a id="more"></a><p><img src="http://static.zybuluo.com/yangfch3/1vhmouqgjzw983ftbiuqlyoi/image_1bqcv642t1bj01a041g0udcae4l9.png" alt="image_1bqcv642t1bj01a041g0udcae4l9.png-40kB"></p><p><code>S.O.L.I.D</code> 做为面向对象编程和面向对象设计的五个基本原则，在面向对象的软件开发史上做为“最佳实践”指导着人们开发出代码清晰可读、容易维护和扩展的系统。</p><p><code>S.O.L.I.D</code> 由 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener">Robert C. Martin (Uncle Bob)</a> 总结提出。</p><h2 id="code-rot">Code rot</h2><p><img src="http://static.zybuluo.com/yangfch3/1dl9j3ppshabajdnq3ujua8k/image_1bu3f0pemstn1htf3bl1v9l157719.png" alt="image_1bu3f0pemstn1htf3bl1v9l157719.png-257.2kB"><br>什么样的代码是烂代码呢？如何识别将来可能会演变成烂代码的代码呢？</p><ol><li><strong>刚性</strong>：小改变导致整个系统重写</li><li><strong>脆弱性</strong>：一个模块的改变导致其他不相关模块行为变得不当，想象一下一台汽车因为电台的变动影响到了车窗的使用</li><li><strong>不可迁移性</strong>：一个模块的内部组件不能提取到新环境使用，原因是组件间的耦合与强依赖。规避策略是将中央抽象与 low-level 细节分离</li><li><strong>粘性</strong>：当构建和测试难以进行，需要花费大量的时间执行（例如：在充值处做了小改动，也需要花费时间去测试游戏各个环节能否正常运行）</li></ol><p>人们主要能体会到软件中的两类价值：</p><ol><li>帮助人们更好地做某件事，提高生产力，降低时间与金钱支出</li><li><strong>软件的行为表现</strong>：满足现阶段的用户需求，同时能频繁地变动以满足用户的需求变更，且没有 Bug 与崩溃。</li></ol><p>第一类价值的保证靠的的团队的产品等角色的发挥，而第二类价值的保证则需要工程师的软件架构设计来保证了，而 S.O.L.I.D 是应用最为广泛也最为基础的设计指导原则。</p><hr><h2 id="单一功能原则-rsp">单一功能原则 - RSP</h2><h3 id="解释">解释</h3><p>一个类或类似的结构只做一件事，只因为一个原因而发生变动</p><h3 id="详细阐述">详细阐述</h3><p>类的一切数据与方法都应该与这个单一的职责有关，即凝聚力。但这并不意味着你的类只能包含一个方法或属性。</p><h3 id="优点">优点</h3><ol><li>降低类的复杂度</li><li>提高可维护性</li><li>提高可读性</li><li>降低需求变化带来的风险</li></ol><h3 id="示例">示例</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Not</span> good, **<span class="number">3</span>** responsibility</span><br><span class="line">class <span class="type">Employee</span> &#123;</span><br><span class="line">    public <span class="type">Pay</span> calculatePay() <span class="meta">&#123;...&#125;</span> <span class="comment"># 1) calculation logic</span></span><br><span class="line">    public <span class="built_in">void</span> save() <span class="meta">&#123;...&#125;</span> <span class="comment"># 2) database logic</span></span><br><span class="line">    public <span class="type">String</span> describeEmployee() <span class="meta">&#123;...&#125;</span> <span class="comment"># 3) reporting logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Modem 类的设计改进：<br><img src="http://static.zybuluo.com/yangfch3/fhc0rg3c34qz6utayxdxgdsx/image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png" alt="image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png-9.4kB"> =&gt; <img src="http://static.zybuluo.com/yangfch3/op876brznpgc56yawj4dsu1f/image_1bu4tvpgf1nfi2giv6bqjd1apb23.png" alt="image_1bu4tvpgf1nfi2giv6bqjd1apb23.png-28.1kB"></p><hr><h2 id="开放封闭原则-ocp">开放封闭原则 - OCP</h2><h3 id="解释-v2">解释</h3><p>软件中的对象（类，模块，函数等等）对扩展开放，对修改封闭。</p><h3 id="详细阐述-v2">详细阐述</h3><p>现有代码应该只在下面三种情况进行 <strong>修改</strong>：</p><ol><li>现有代码里有 Bug 或错误</li><li>现有代码实现的需求发生了变动（例如之前确定的算法或逻辑发生了改变）</li></ol><p>下面情况不应该需要改变现有代码，而能通过<strong>继承</strong>、<strong>多态</strong>来进行 <strong>扩展</strong> 即可变更软件的行为：</p><ol><li>以前做过可预测的同类需求。例如在员工管理系统中需要新增一个员工类型，支付系统需要新增一种支付方式</li></ol><p>通常的实现方法：<strong>对抽象编程，而不对具体编程；使用抽象类或接口，而不是使用具体的类；新功能的的增加通过实现继承抽象类或实现接口，而非改变已有代码来完成。</strong></p><p><strong>只有在将会发生的变化是可预测的情况下，OCP 才会有所帮助，所以你应当只有在类似的变化已经发生过的情况下使用它。</strong></p><h3 id="优点-v2">优点</h3><ol><li>扩展新功能时不容易引入新 Bug</li><li>新的功能添加无需对全部代码进行代码审查、单元测试</li><li>代码稳定性</li><li>解耦，增加弹性</li></ol><h3 id="实例">实例</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not Good</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不难预料，将来可能支持除现金之外的收款方式</span></span><br><span class="line"><span class="comment"> * 这里直接写死成 acceptCash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void checkOut(Receipt receipt) &#123;</span><br><span class="line">  Money <span class="keyword">total</span> = Money.zero;</span><br><span class="line">  <span class="keyword">for</span> (item : items) &#123;</span><br><span class="line">    <span class="keyword">total</span> += item.getPrice();</span><br><span class="line">    receipt.addItem(item);</span><br><span class="line">  &#125;</span><br><span class="line">  Payment p = acceptCash(<span class="keyword">total</span>);</span><br><span class="line">  receipt.addPayment(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将来需要新增一种收款方式，可能会被改成这样</span></span><br><span class="line">void checkOut(Receipt receipt) &#123;</span><br><span class="line">  Money <span class="keyword">total</span> = Money.zero;</span><br><span class="line">  <span class="keyword">for</span> (item : items) &#123;</span><br><span class="line">    <span class="keyword">total</span> += item.getPrice();</span><br><span class="line">    receipt.addItem(item);</span><br><span class="line">  &#125;</span><br><span class="line">  Payment p;</span><br><span class="line">  <span class="keyword">if</span> (credit)</span><br><span class="line">    p = acceptCredit(<span class="keyword">total</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    p = acceptCash(<span class="keyword">total</span>);</span><br><span class="line">  receipt.addPayment(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PaymentMethod</span> &#123;<span class="function"><span class="keyword">void</span> <span class="title">acceptPayment</span>(<span class="params">Money total</span>)</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkOut</span>(<span class="params">Receipt receipt, PaymentMethod pm</span>) </span>&#123;</span><br><span class="line">  Money total = Money.zero;</span><br><span class="line">  <span class="keyword">for</span> (item : items) &#123;</span><br><span class="line">    total += item.getPrice();</span><br><span class="line">    receipt.addItem(item);</span><br><span class="line">  &#125;</span><br><span class="line">  Payment p = pm.acceptPayment(total);</span><br><span class="line">  receipt.addPayment(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="里氏替换原则-lsp">里氏替换原则 - LSP</h2><h3 id="解释-v3">解释</h3><p>任何基类可以出现的地方，子类一定可以出现。所有子类需要按照其基本类别的方式进行操作。子类可以扩展父类的功能，但不能改变父类原有的行为预期。</p><h3 id="详细阐述-v3">详细阐述</h3><p>Liskov 提出的关于继承的原则：<strong>继承必须确保超类中所拥有的属性与方法在子类中仍然拥有</strong>。</p><p>Robert C. Martin 提出了更抽象的简化：<strong>子类必须能够替换成他们的基类</strong>。这也是里氏替换原则的精髓。</p><p>LSP 是继承复用的基石，只有当子类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而子类也可以在基类的基础上增加新的行为。</p><p>一般来说，如果超类的子类型做了超类的客户端所不期望的事情，那么这违背了 LSP。设想一个派生类抛出一个异常，超类不抛出，或者如果一个派生类有一些意想不到的副作用。</p><p>更具有指导意义的详细规范：</p><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ol><h3 id="优点-v3">优点</h3><ol><li>里氏替换原则是实现开放封闭原则的具体规范</li><li>见开放封闭原则的优缺点</li></ol><h3 id="示例-v2">示例</h3><p>见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html" target="_blank" rel="noopener">链接</a></p><hr><h2 id="接口隔离原则-isp">接口隔离原则 - ISP</h2><h3 id="解释-v4">解释</h3><p>一个类不应该被强制依赖它不需要的接口成员。多个小的、特定的、具有内聚性的客户端接口要好于单个宽泛用途的、内聚性差的接口。</p><h3 id="详细阐述-v4">详细阐述</h3><p>与单一职责原则的不同点：</p><ol><li>单一职责原则注重的是对象的职责；而接口隔离原则注重对接口依赖的隔离</li><li>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</li></ol><p>接口的粒度需要我们自己去把控，接口的粒度过小会造成接口数量过多，设计复杂化；接口粒度过大，就很容易违背接口隔离原则。</p><p>另见下方示例</p><h3 id="优点-v4">优点</h3><ol><li>灵活性</li><li>避免接口臃肿</li></ol><h3 id="示例-v3">示例</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not Good</span></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">Messenger</span> &#123;</span><br><span class="line">  <span class="selector-tag">askForCard</span>();</span><br><span class="line">  <span class="selector-tag">tellInvalidCard</span>();</span><br><span class="line">  <span class="selector-tag">askForPin</span>();</span><br><span class="line">  <span class="selector-tag">tellInvalidPin</span>();</span><br><span class="line">  <span class="selector-tag">tellCardWasSiezed</span>();</span><br><span class="line">  <span class="selector-tag">askForAccount</span>();</span><br><span class="line">  <span class="selector-tag">tellNotEnoughMoneyInAccount</span>();</span><br><span class="line">  <span class="selector-tag">tellAmountDeposited</span>();</span><br><span class="line">  <span class="selector-tag">tellBalance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginMessenger</span> </span>&#123;</span><br><span class="line">  askForCard();</span><br><span class="line">  tellInvalidCard();</span><br><span class="line">  askForPin();</span><br><span class="line">  tellInvalidPin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalMessenger</span> </span>&#123;</span><br><span class="line">  tellNotEnoughMoneyInAccount();</span><br><span class="line">  askForFeeConfirmation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publc <span class="class"><span class="keyword">class</span> <span class="title">EnglishMessenger</span> <span class="keyword">implements</span> <span class="title">LoginMessenger</span>, <span class="title">WithdrawalMessenger</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="依赖反转原则-dip">依赖反转原则 - DIP</h2><h3 id="解释-v5">解释</h3><ol><li>高层模块不应该依赖低层模块，所有模块都应该依赖抽象</li><li>抽象不应该依赖细节/具体</li><li>细节/具体应该依赖抽象</li></ol><h3 id="详细阐述-v5">详细阐述</h3><p>什么是依赖？</p><blockquote><p>不是我自身的，却是我需要的，都是我所依赖的。<br>我若依赖你，我就不能离开你。</p></blockquote><p>什么是高层模块？什么是低层模块？</p><blockquote><p>类 A 直接依赖于类 B，假如要将类 A 修改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑。类 B 和 C 是底层模块，负责基本的原子操作。</p></blockquote><p>什么是抽象？什么是细节？</p><blockquote><p>抽象：抽象类或接口<br>细节：具体的实现类或实现方法</p></blockquote><p>这里的依赖是什么？反转后的依赖变成了什么？</p><blockquote><p>这里的依赖原本指高层模块对低层模块的依赖，倒置的依赖演变成实现类对接口或抽象类的依赖</p></blockquote><p>反转怎么理解？</p><blockquote><p>由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。</p></blockquote><p><img src="http://static.zybuluo.com/yangfch3/dmo4sdqgvlw6uaa0a1eljgjm/image_1bu57m1gtbj8122q11etnn75gm2g.png" alt=""></p><h3 id="优点-v5">优点</h3><ol><li>松散耦合</li><li>多人开发，提取模块的抽象，可以进行多人并行开发</li><li>违背了依赖反转原则，那么开放封闭原则也就无法实行</li></ol><h3 id="示例-v4">示例</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> &#123;</span> <span class="keyword">char</span> getchar(); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> &#123;</span> <span class="keyword">void</span> putchar(<span class="keyword">char</span> c)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharCopier</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> copy(Reader reader, Writer writer) &#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = reader.getchar()) != EOF) &#123;</span><br><span class="line">      writer.putchar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块 B</span></span><br><span class="line"><span class="keyword">public</span> Keyboard <span class="keyword">implements</span> Reader &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> Printer <span class="keyword">implements</span> Writer &#123;…&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> CharCopier(<span class="keyword">new</span> Keyboard(), <span class="keyword">new</span> Writer());</span><br></pre></td></tr></table></figure><p>或见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html" target="_blank" rel="noopener">链接</a></p><h3 id="说明">说明</h3><p>依赖倒置原则的核心就是 <strong>面向接口编程的思想</strong>，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。但是这个原则也是 5 个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p><p>依赖倒置原则或者说面向接口编程的思想催生了许多经典的设计模式，欲细究可自行深入研究面向接口编程。</p><hr><p>参考资料：<br><a href="https://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/" target="_blank" rel="noopener">Object-oriented design principles and the 5 ways of creating SOLID applications</a><br><a href="http://www.cnblogs.com/hellojava/category/431379.html" target="_blank" rel="noopener">http://www.cnblogs.com/hellojava/category/431379.html</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Patterns </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 缓存及策略制定</title>
      <link href="/2017/10/19/HTTP-Cache/"/>
      <url>/2017/10/19/HTTP-Cache/</url>
      <content type="html"><![CDATA[<p>我们常常会注意到静态资源后面都跟着一串指纹码：<br><img src="http://static.zybuluo.com/yangfch3/8m3e3wnqpmxwhztq755quy1w/image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png" alt="image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png-20.6kB"><br><img src="http://static.zybuluo.com/yangfch3/kp4cmtg8o50i34lh501vlhf3/image_1b1c9gujm10snq8f947iv5t49.png" alt="image_1b1c9gujm10snq8f947iv5t49.png-28.4kB"><br><img src="http://static.zybuluo.com/yangfch3/s3aubu6l1ylr6igytpuv18y6/image_1b1c9jtvr1aogmd0seg1o0714lu13.png" alt="image_1b1c9jtvr1aogmd0seg1o0714lu13.png-15.8kB"><br><img src="http://static.zybuluo.com/yangfch3/44bhvo0c8c89lggd60uyyhqn/image_1b1c9of7qf6b1abfvmp1er12801g.png" alt="image_1b1c9of7qf6b1abfvmp1er12801g.png-17.2kB"></p><p>同时我们在进行网络请求分析时会遇到 Cache-Control、Last-Modified 等这些 Header 字段。</p><p>在冥冥中，我们知道这些肯定与缓存有着重大的关系。缓存机制中有哪些关键的东西在起作用，如何制定最优的 <strong>缓存-更新</strong> 机制就是本文需要研究的问题。</p><a id="more"></a><h2 id="前言">前言</h2><p>首先让我们来看一次经典的 <strong>请求-响应</strong> 过程，以 <a href="https://zhihu.com" target="_blank" rel="noopener">zhihu.com</a> 登录页的某个 JavaScript 资源为例：<br><img src="http://static.zybuluo.com/yangfch3/0gotv3wpms8o77advh2x4jqn/image_1b1cacu1n1b4019s61jo816fj5ud1t.png" alt="image_1b1cacu1n1b4019s61jo816fj5ud1t.png-586.8kB"></p><p>我们从这次连接中看到以下与缓存相关的 HTTP(s) 请求头/响应头：</p><ul><li>Request Header<ol><li>Cache-Control</li><li>If-Modified-Since</li><li>If-None-Match</li></ol></li><li>Response Header<ol><li>Cache-Control（图上没有体现）</li><li>Last-Modified</li><li>ETag</li></ol></li></ul><p>一般，我们请求的缓存就是由上述 HTTP Header 进行<strong>校验</strong>与<strong>控制</strong>。是否需要缓存？缓存层级？缓存多久？缓存到期后如何处理？这些问题就是接下来的文章需要解决的。</p><h2 id="etag-if-none-match">ETag &amp; If-None-Match</h2><p>ETag 我们可以很形象地称之为<strong>验证令牌</strong>，这个令牌在<strong>缓存不符合我们的 Cache-Control 指定的规则</strong> 时起作用。</p><p>ETag 由服务器生成，由 Response Header 携带传送给客户端进行保存，客户端请求 Request Header 通过 If-None-Match 携带缓存的 ETag 值给服务器进行校验。</p><blockquote><p>ETag 是 Response Header 的字段，If-None-Match 是 Request Header 的字段，因为二者功能协作且字段值一致，下面统一用 ETag 代替。</p></blockquote><p>假如我们有如下静态资源，请求细节如下：<br><img src="http://static.zybuluo.com/yangfch3/95pdeafw683dqhtwj8ymhnpp/image_1b1cbv67c17de1kdb16rce9mtk2a.png" alt="image_1b1cbv67c17de1kdb16rce9mtk2a.png-18.4kB"></p><p>现在过了 120 秒，浏览器又对该资源发起了请求。</p><p>首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应缓存的文件现在已经“过期”，不能直接使用。此时，浏览器可以直接发出新请求，获取新的完整响应，<strong>但是这样做效率较低，因为如果本地缓存已过期，但服务器上资源在此期间未被更改过，我们就没有理由再去下载一遍</strong>。</p><p>这就是 ETag 头中指定的验证令牌所要解决的<em>问题</em><sup>1</sup>：服务器会生成并返回一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码（具体实现细节由服务器决定）。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其（通过 If-None-Match 携带）发送给服务器：如果指纹码仍然一致，说明资源未被修改，我们就可以跳过下载，继续延长 Cache-Control（120s）。</p><blockquote><p>1：如果资源未被更改过，我们就没有理由再去下载与客户端缓存中已有的完全相同的资源。</p></blockquote><p>总结以上内容就是：</p><ol><li>ETag 在缓存过期（过了 Cache-Control 指定期限）之后起作用的</li><li>ETag 在缓存过期后判定是对缓存<strong>续命</strong>还是<strong>更新</strong></li></ol><h2 id="last-modified-if-modified-since">Last-Modified &amp; If-Modified-Since</h2><p>其实在 ETag 出现之前，就有了 Last-Modified/If-Modified-Since 验证机制。使用资源的最近一次更新时间（Last-Modified）进行校验是最符合我们日常认知的，也是最容易想到的一种方式。</p><blockquote><p>Last-Modified 是 Response Header 的字段<br>If-Modified-Since 是 Request Header 的字段</p></blockquote><p>ETag 的出现是对 Last-Modified 机制的补充与严谨化。</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存（而 ETag 是依据文件内容特征生成的指纹，能更精确地表示文件有无变化）</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul><p>Last-Modified 与 ETag 一起使用时，服务器会<strong>优先验证 ETag</strong>，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p><h2 id="cache-control">Cache-Control</h2><p><code>Cache-Control</code> 有一个比较特殊的点：Request Header 有此字段，Response Header 也有这个字段。</p><h3 id="max-age-num">max-age=[num]</h3><p>服务器返回头 Cache-Control 的 max-age 告诉客户端：<strong>此资源在客户端缓存时间为多久</strong>。</p><p>而比较特殊的 max-age=0 则相当于告知客户端：<strong>此资源刻意缓存在客户端，但每次重新请求都应该向服务器请求校验</strong>。</p><ol><li>服务器首次返回一个 max-age=0 的静态资源，客户端缓存到本地</li><li>客户端需要重新请求此静态资源时，发现本地有缓存，但是缓存已过期（因为 max-age=0）</li><li>客户端重新发送请求，携带 If-None-Match 头以及 max-age=0</li><li>服务端将收到的 If-None-Match 与文件的 ETag 比对</li><li>如果比对不一致，则下发静态资源，同时返回 Cache-Control 头和新的 ETag，客户端比对本地的 ETag 与返回的 ETag 后使用新的资源，并回到步骤 1</li><li>如果比对一致，则不下发返回静态资源，同时返回 Cache-Control 头和没变的 ETag，客户端比对本地的 ETag 与返回的 ETag 后直接使用缓存</li></ol><h3 id="no-cache">no-cache</h3><p>Response Header 的 no-cache 和 max-age=0 作用你可以将其等同起来。</p><p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#no-cacheno-store" target="_blank" rel="noopener">链接1</a><br><a href="https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="noopener">链接2</a></p><ol><li>no-cache 不代表禁止客户端缓存</li><li>no-cache 不是不缓存，而是不直接使用缓存（需要验证）</li></ol><blockquote><p>I believe max-age=0 simply tells caches (and user agents) the response is stale from the get-go and so they SHOULD revalidate the response (eg. with the If-Not-Modified header) before using a cached copy, whereas, no-cache tells them they MUST revalidate before using a cached copy.</p></blockquote><p><code>Cache-Control: max-age=0</code> 与 <code>Cache-Control: no-cache</code> 可能存在的不同点是：可能在点击浏览器的前进后退按钮时会存在差异。<code>Cache-Control: max-age=0</code> 可以直接使用，而 <code>Cache-Control: no-cache</code> 则会验证。</p><p>还有一个问题时，在某些版本的浏览器下，客户端对 no-cache 与 no-store 的处理是一样的：都是直接不缓存。</p><p>no-cache 在 Request Header 的作用则比较简单：告诉服务器，本地没有缓存或不使用缓存，你需要给我最新的文件。Chrome 下的强制刷新以及 Disable Cache 采取的就是在 Request Header 使用 no-cache。</p><h3 id="no-store">no-store</h3><p><code>Cache-Control: no-store</code> 直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</p><h3 id="public-private">public &amp; private</h3><p>服务器返回的 Cache-Control Header 如果有 public 字段，则表示可以多级缓存（用户代理、CDN、服务提供商）。</p><p>private 则表示单用户缓存，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是中间服务商不能缓存。</p><h2 id="实例：express-req-fresh-的判定机制">实例：Express req.fresh 的判定机制</h2><p>Express 中 req.fresh 用于判定客户端的请求是否是“新鲜”的请求（而不是对已缓存资源的请求），只有当请求头的 <code>cache-control</code> 不等于 <code>no-cache</code> 并且满足以下任意一条才表示客户端的请求是“新鲜”的（即服务器需要提供新资源）：</p><blockquote><ul><li>指定了 <code>if-modified-since</code> 请求头并且 <code>last-modified</code> 请求头等于或时间上早于 <code>modified</code> 响应头</li><li><code>if-none-match</code> 请求头是 <code>*</code></li><li><code>if-none-match</code> 请求头无法匹配响应头的 <code>etag</code></li></ul></blockquote><h2 id="http-caching-最佳实践">HTTP Caching 最佳实践</h2><p><img src="http://static.zybuluo.com/yangfch3/jwinkxrha3w4bkgq59kgr89f/image_1b1ciceslctp1ho2ib1rvf1evj2n.png" alt="image_1b1ciceslctp1ho2ib1rvf1evj2n.png-47.8kB"></p><h2 id="缓存与频繁更新的矛盾">缓存与频繁更新的矛盾</h2><p>有些资源是需要频繁更新的，但是我们又确实希望客户端对其进行缓存。此时我们就需要<strong>针对我们资源的特性制定不同的缓存策略与缓存级别</strong>，并使用<strong>资源指纹 URL</strong>搭配实现资源的随意更新。</p><p>于是我们可以看回本文开始部分介绍的几个典型网站静态资源的指纹URL案例：</p><ol><li>index.xxxxxxx.js</li><li>index$xxxxxx.js</li><li>index-xxxxxxx.js</li><li>/index.js?x.x.x</li></ol><p>上面的 <code>x</code> 即为指纹区，选择何种指纹视项目与团队规范而定。</p><p><strong>指纹 URL + Cache-Control</strong> 实现缓存与更新的精细控制案例：<br><img src="http://static.zybuluo.com/yangfch3/0achbqbncuy3hdfar6l5thm7/image_1b1cj198v4itmue1ishdsecbj34.png" alt="image_1b1cj198v4itmue1ishdsecbj34.png-29.7kB"></p><p>分析一下上面的例子：</p><ul><li>HTML 被标记成 <code>no-cache</code>（或 <code>max-age=0</code>），这意味着浏览器在每次请求时都会重新验证文档，如果内容更改，会获取最新版本。同时，在 HTML 标记中，我们<strong>在 CSS 和 JavaScript 资源的网址中嵌入指纹码</strong>：如果这些文件的内容更改，网页的 HTML 也会随之更改，并将下载 HTML 响应的新副本。</li><li>允许浏览器和中继缓存（例如 CDN）缓存 CSS，过期时间设置为 1 年。注意，我们可以放心地使用 1 年的“远期过期”，因为我们在文件名中嵌入了文件指纹码：如果 CSS 更新，网址也会随之更改。</li><li>JavaScript 过期时间也设置为 1 年，但是被标记为 private，<strong>也许是因为包含了 CDN 不应缓存的一些用户私人数据</strong>。</li><li>缓存图片时不包含版本或唯一指纹码（一般项目中也会包含指纹码），过期时间设置为 1 天。</li></ul><p>组合使用 <code>ETag</code>、<code>Cache-Control</code> 和唯一网址（指纹 URL），我们可以提供最佳的方案：<strong>较长的过期时间，控制可以缓存响应的位置，以及按需更新。</strong></p><h2 id="注意点">注意点</h2><ol><li><p>网址区分大小写</p></li><li><p>除了文中提到的这些 Header 字段，服务器还可以自己制定与实现一些辅助缓存机制的字段。如：<code>X-Cache</code> 这样。</p></li><li><p>如果在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保启用了 HTTP 缓存，并根据用途设置了合理的缓存大小，同时，确保缓存持久化。查看平台文档并确认您的设置！</p><blockquote><p>例如在微信内 Webview 的缓存就有一些比较特殊的地方，具体可阅读开发文档。</p></blockquote></li><li><p>在很多情况下我们还会在响应 Header 内遇到 Expires 字段，这是 HTTP 1.0 时的标准，主要是为了兼容较为老旧的浏览器。在 HTTP 1.1 中定义了 Cache-Control 代替 Expires。</p></li></ol><hr><p>参考资料：<br><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="noopener">Google: Web Fundamentals - HTTP Caching</a><br><a href="http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="noopener">What’s the difference between Cache-Control: max-age=0 and no-cache?</a></p>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTTP </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器内核、引擎、页面呈现原理及其优化</title>
      <link href="/2017/03/04/browser-core-and-engine/"/>
      <url>/2017/03/04/browser-core-and-engine/</url>
      <content type="html"><![CDATA[<p>介绍浏览器内核、JavaScript 引擎以及页面呈现原理等基础知识，同时根据原理提出页面呈现优化方案。</p><a id="more"></a><h2 id="浏览器内核">浏览器内核</h2><p>浏览器内核又叫渲染引擎，主要负责 HTML、CSS 的解析，页面布局、渲染与复合层合成。浏览器内核的不同带来的主要问题是对 CSS 的支持度与属性表现差异。</p><p>现在主流的内核有：Blink、Webkit、Gecko、EdgeHTML、Trident，这里面有几个需要注意的地方：</p><ol><li><p>Blink 是在 Webkit 的基础上的改进，是现在对新特性支持度最好的内核</p></li><li><p>移动端基本上全部是 Webkit 或 Blink 内核（除去 Android 上腾讯家的 X5），这两个内核对新特性的支持度较高，所以新特性可以在移动端大展身手。</p></li><li><p>Trident 是 IE4+ 的内核，一直持续到 IE11，EdgeHTML 是微软抛弃 IE 后开发的全新内核</p></li><li><p>更多资料请看附录表格</p></li></ol><h3 id="几种渲染模式">几种渲染模式</h3><p>一般现代浏览器都会有以下几种渲染模式：</p><ol><li>标准模式</li><li>接近标准模式（又称有限怪异模式）</li><li>怪异模式</li></ol><h3 id="不同渲染模式出现的原因">不同渲染模式出现的原因</h3><p>在 IE5 与 NS4 那个年代，浏览器大战，标准未立，Web 则在经历早期快速地发展。</p><p>后来标准逐步建立，新标准的规范与以前 IE5、NS4 的实现存在着不可避免的差异差异，但是此时的网络世界许许多多旧时的页面正在运行，如果按照新标准的实现来渲染的话会有大量的问题出现。</p><p>所以此时大部分现代浏览器厂商想到了区别性地使用<strong>不同渲染模式</strong>来对待这些 Web 页面。</p><p>而 IE 随着升级，对现代标准的支持也越来越完善，所以 IE 为了正常渲染旧时页面，<strong>支持我们指定哪个版本的 IE 模式来渲染页面</strong>。</p><p>总结就是：</p><ol><li>怪异模式是 IE5 与 NS4 年代遗留问题的回退方案</li><li>怪异模式在大部分浏览器都有部署，并且能在一定的机制下触发</li></ol><h3 id="不同渲染模式的触发">不同渲染模式的触发</h3><p>标准未立之前，HTML 文档是没有文档头的，同时在 HTML5 之前的 HTML4/3 的文档头都有各自的特征，所以在大部分现代浏览器下触发的机制如下：</p><ol><li><p>无 <code>DOCTYPE</code> 头触发<strong>怪异模式</strong></p></li><li><p><code>DOCTYPE</code> 头不正确（不是 html）也触发<strong>怪异模式</strong></p><blockquote><p>如：<code>&lt;!DOCTYPE svg&gt;</code></p></blockquote></li><li><p><code>DOCTYPE</code> 头为 HTML3 头触发<strong>怪异模式</strong></p></li><li><p><code>DOCTYPE</code> 头为 HTML4 头则触发<strong>接近标准模式</strong>（或称<strong>有限怪异模式</strong>）</p></li><li><p>常见的 HTML5 DOCTYPE 声明则使用<strong>标准模式</strong></p></li></ol><p>在 IE 下，除了文档头的差异可以自动触发渲染模式的选择，我们还能手动指定（在 IE8+ 适用）使用哪个版本的 IE 渲染模式来渲染我们的页面（<a href="http://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do" target="_blank" rel="noopener">扩展阅读</a>）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用当前操作系统已装的最新的 IE --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- chrome=1 是针对双核浏览器使优先使用 Chrome --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge,chrome=1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 IE9 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=9"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果你需要使用 IE5 的怪异模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=5"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="不同渲染模式的表现差异">不同渲染模式的表现差异</h3><p><strong>怪异模式与标准模式</strong></p><blockquote><ol><li>怪异模式使用不同于标准的盒模型（也就相当于 IE8+ 下的：<code>box-sizing: border-box</code>）</li><li>怪异模式下某些行内（inline）元素的垂直对齐行为表现怪异：<strong>怪异模式下对齐图片至包含它们的盒子的下边框</strong>，而 <strong>标准模式图片对其到父盒的 baseline</strong></li></ol></blockquote><p><strong>接近标准模式（有限怪异模式）与标准模式</strong></p><blockquote><p>主要区别即为上面的第 2 点</p></blockquote><h2 id="javascript-引擎">JavaScript 引擎</h2><p>JavaScript 负责 JavaScript 代码的解释与执行，主流的 JavaScript 引擎有：V8、SpiderMonkey、JavaScriptCore、Chakra。</p><p>浏览器与引擎详情见附录表格。</p><h2 id="页面呈现原理">页面呈现原理</h2><p>当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后是如何一步步将页面呈现出来的呢？这里面浏览器需要做哪些工作？如何优化呈现的过程提升 Web 应用质量？</p><h3 id="六部曲">六部曲</h3><p>一个页面的呈现，粗略的说会经过以下这些步骤：</p><ol><li><p>DOM 树的构建（Parse HTML）</p></li><li><p>构建 CSSOM 树（Recaculate Style）</p><blockquote><p>为什么是 <strong>Re</strong>-caculate Style 呢？这是因为浏览器本身有 <code>User Agent StyleSheet</code>，所以最终的样式是我们的样式代码样式与用户代理默认样式<strong>覆盖/重新计算</strong>得到的。</p></blockquote></li><li><p>合并 DOM 树与 CSSOM 树为 Render 树</p></li><li><p>布局（Layout）</p></li><li><p>绘制（Paint）</p></li><li><p>复合图层化（Composite）</p><blockquote><p>图层化是自己理解后形象的意译</p></blockquote></li></ol><p>其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。</p><h3 id="六部曲中的阻塞">六部曲中的阻塞</h3><p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p><p>我们来分析这六部曲中存在的阻塞问题：</p><ol><li><p>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（<strong>阻塞 1</strong>）</p><blockquote><p>那是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定，见 2</p></blockquote></li><li><p>当遇到 <code>&lt;script&gt;</code> 标签需要执行脚本代码时，浏览器会检查是否这个 <code>&lt;script&gt;</code> 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 <code>&lt;script&gt;</code> 上部还有 CSS 样式没加载，则浏览器会等待 <code>&lt;script&gt;</code> 上方样式的加载完成才会执行该 <code>&lt;script&gt;</code> 内的脚本（<strong>阻塞 2</strong>）</p></li><li><p>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（<strong>同步阻塞</strong>）</p></li><li><p>同时外部脚本、外部样式表的下载也是耗费时间较多的点</p></li></ol><h3 id="六部曲之-dom-树的构建">六部曲之 DOM 树的构建</h3><p><img src="http://static.zybuluo.com/yangfch3/ob8y6inhvvmg6rl9z4vn43fq/image_1ba5aftnnm7i11t8kl716c2164o9.png" alt="image_1ba5aftnnm7i11t8kl716c2164o9.png-96.9kB"><br>浏览器构建 DOM 树可以简单的总结为以下几步：</p><ol><li><p><strong>转码（Bytes -&gt; Characters）</strong>—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</p></li><li><p><strong>Tokens 化（Characters -&gt; Tokens）</strong>—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</p></li><li><p><strong>构建 Nodes（Tokens -&gt; Nodes）</strong>—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br><img src="http://static.zybuluo.com/yangfch3/hfa6bzlsczzalvk5t89aa56f/image_1ba5an0vmfsn1kb928a1lv8vkpm.png" alt="image_1ba5an0vmfsn1kb928a1lv8vkpm.png-49.2kB"></p></li><li><p><strong>构建 DOM 树（Nodes -&gt; DOM Tree）</strong>—— 最重要的工作是建立起每个结点的父子兄弟关系</p></li></ol><blockquote><p><strong>在 Chrome 开发者工具下 Timeline 面板的 <code>Parse HTML</code> 阶段对应着 DOM 树的构建</strong>。<br><br></p></blockquote><p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/24911872?refer=dreawer" target="_blank" rel="noopener">从Chrome源码看浏览器如何构建DOM树</a></p><blockquote><p>留意这篇文章的这些点：</p><ol><li>DOM 构建时对 DOCType 处理</li><li>DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响</li><li>处理开标签与闭标签的压栈、弹栈处理</li><li>Chromium 对待自定义标签的处理</li><li>JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比</li></ol></blockquote><h3 id="六部曲之-cssom-树的构建">六部曲之 CSSOM 树的构建</h3><p>CSSOM 树的构建 “原料” 的来源有：<strong>外部 CSS 文件、内部样式、内联样式</strong>。</p><p>CSSOM 树的构建其实是一个 <strong>样式的重新计算</strong> 的过程，为什么是重新计算呢？</p><blockquote><p>用户代理（即浏览器）本身有一套内置样式表，<strong>所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算</strong>。</p><p>所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 <code>Recalculate Style</code> 阶段</p></blockquote><p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br><img src="http://static.zybuluo.com/yangfch3/brh4juu5r4r8f7oh9jrekcle/image_1ba7m6adr1h52bm2mblup214t59.png" alt="image_1ba7m6adr1h52bm2mblup214t59.png-10.3kB"></p><p>最终构建的 CSSOM 树大致如下：<br><img src="http://static.zybuluo.com/yangfch3/yes5apeozng4x0j3xpjj3ubi/image_1ba7m7h67t731ikr1461topakgm.png" alt="image_1ba7m7h67t731ikr1461topakgm.png-42.2kB"></p><h3 id="六部曲之渲染树的构建">六部曲之渲染树的构建</h3><ol><li><p>DOM 树与 CSSOM 树融合成渲染树</p></li><li><p>渲染树只包括渲染页面需要的节点</p><blockquote><p>排除 <code>&lt;script&gt;</code> <code>&lt;meta&gt;</code> 等功能化、非视觉节点<br>排除 <code>display: none</code> 的节点</p></blockquote></li></ol><p><img src="http://static.zybuluo.com/yangfch3/27ik5bf4rguih1mrpi112opo/image_1ba7mjun4h4l123b1smn13indhg13.png" alt="image_1ba7mjun4h4l123b1smn13indhg13.png-116.2kB"></p><h3 id="六部曲之布局">六部曲之布局</h3><p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。</p><blockquote><p><strong>Layout 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</strong></p></blockquote><p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 <code>Layout trashing</code>，又叫做回流（Reflow）。</p><h3 id="六部曲之绘制">六部曲之绘制</h3><p>一旦布局（Layout）步骤完成，浏览器便触发 “Paint Setup” 与 “Paint” 事件（渲染引擎底层概念），执行 <code>paint</code> 操作，<strong>结合渲染树与布局信息绘制实际像素</strong>。</p><blockquote><p>注：在 Timeline 工具内，<code>Layout</code> 与 <code>Paint</code> 两个过程被统一归并到 <code>Paint</code> 阶段。</p></blockquote><h3 id="六部曲之复合图层化">六部曲之复合图层化</h3><p>在很多情况下，我们<strong>不会将复合图层化</strong>归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p><p>见 <a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="noopener">链接</a></p><h2 id="页面性能优化">页面性能优化</h2><p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p><h3 id="优化不可避免的阻塞：优化关键呈现路径">优化不可避免的阻塞：优化关键呈现路径</h3><p><strong>关键呈现路径里的一些概念</strong>：</p><ul><li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li><li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li><li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li></ul><p><strong>优化关键呈现路径的指导原则</strong>：</p><ul><li>尽量减少关键资源数量。</li><li>尽量减少关键字节数。</li><li>尽量缩短关键路径的长度。</li></ul><p><strong>优化关键呈现路径常规步骤</strong>：</p><ol><li>分析和描述关键路径：资源数量、字节数、长度。</li><li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li><li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li><li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li></ol><p><strong>优化关键呈现路径的具体建议</strong>：</p><ol><li><p>文件合并、压缩</p></li><li><p>推荐使用异步（<code>async</code>） JavaScript 资源，或使用延迟（<code>defer</code>）执行的 JavaScript</p></li><li><p>一般 <code>&lt;script&gt;</code> 脚本的靠后书写</p></li><li><p>避免运行时间长的 JavaScript，<strong>耗时任务的拆分，chunk 化运行</strong></p><blockquote><p>例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</p></blockquote></li><li><p>避免使用 CSS import</p></li><li><p>内联、内部化阻止呈现的 CSS</p><blockquote><p>一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</p></blockquote></li></ol><h3 id="针对复合图层化的优化">针对复合图层化的优化</h3><p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p><h4 id="复合图层化机制">复合图层化机制</h4><p>某些属性的变更（<code>transform</code>、<code>opacity</code>）满足以下条件：</p><ul><li>不影响文档流。</li><li>不依赖文档流。</li><li>不会造成重绘。</li></ul><p>那么这些属性变更时就需要一种机制：机制需要能将属性变更的部分与页面其他部分隔离开来，其他部分已经渲染完好进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。</p><p>所以图层化的关键字：<strong>缓存</strong>、<strong>隔离</strong>、<strong>图层合成</strong></p><p>使用 <code>transform</code> 与 <code>opacity</code> 进行属性变更是经典的符合图层化方法，以下是其他会<strong>提升元素为复合图层的场景</strong>：</p><ol><li>3d 或透视变换 CSS 属性，例如 <code>translate3d</code>, <code>translateZ</code> 等等（JS 一般通过这种方式，使元素获得复合图层）</li><li><code>&lt;video&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;canvas&gt;</code> <code>&lt;webgl&gt;</code> 等元素。</li><li>混合插件（如flash）。</li><li>元素自身的 <code>opacity</code> 和 <code>transform</code> 做 CSS 动画。</li><li>拥有 CSS Filter 的元素。</li><li>使用 <code>will-change</code> 属性。</li><li><code>position:fixed</code>。</li><li>元素有一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</li></ol><h4 id="图层化的优势">图层化的优势</h4><p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来动画性能的提升。</p><h4 id="图层化的潜在问题-内存开销">图层化的潜在问题 —— 内存开销</h4><p>那么图层化的弊端在哪里呢？</p><p>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况（如下图）。</p><p><img src="http://static.zybuluo.com/yangfch3/dphdmt262yimw0vwjl4nomk5/image_1baah8s0vcol3464t21foe1sb91g.png" alt="image_1baah8s0vcol3464t21foe1sb91g.png-31.3kB"></p><center>同样表现的页面，单图层与多图层的内存开销</center><h4 id="因为开销-所以节制">因为开销，所以节制</h4><p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p><h3 id="针对回流的优化">针对回流的优化</h3><ol><li><p><a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS Triggers</a></p><ol><li>CSS3 &gt; JavaScript</li><li>属性变更优先考虑顺序（性能表现排序）<ol><li><code>transfrom</code>, <code>opacity</code></li><li><code>background-color</code> 等</li><li><code>position</code> - <code>top</code> <code>bottom</code> <code>left</code> <code>right</code></li><li><code>width</code> <code>height</code> 等</li><li><code>margin</code>, <code>padding</code>, <code>border</code></li></ol></li></ol></li><li><p><a href="https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9" target="_blank" rel="noopener">What forces layout</a></p><blockquote><p>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。</p><p>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</p></blockquote></li></ol><h3 id="其他优化技巧">其他优化技巧</h3><h4 id="节流函数">节流函数</h4><p>已经比较明白了，那就略吧</p><h4 id="惰性载入函数">惰性载入函数</h4><p>也已经比较明白，也略吧</p><h4 id="重任务分片多帧">重任务分片多帧</h4><p><a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="noopener">实例讲解</a></p><h2 id="timeline-工具">Timeline 工具</h2><p>使用 Timeline 工具我们能做以下事：</p><ol><li>页面渲染帧率分析，得到异常帧信息</li><li>各类文件执行耗时/耗资源分析</li><li>文件等待 - 下载时间</li><li>页面呈现期间的事件列表</li><li>某个帧/某个事件的详细信息分析</li></ol><p><img src="http://static.zybuluo.com/yangfch3/xrxcqw4c0ignhkxgsfiqssrk/image_1ba7qi29r1b5f12c7tvh1muh9rm.png" alt="image_1ba7qi29r1b5f12c7tvh1muh9rm.png-524.5kB"></p><center>理解 Timeline 工具使用，读懂这图就够了</center><p><img src="http://static.zybuluo.com/yangfch3/vrr16pctepw9uct9raq881ps/image_1ba7rnvjs4gb1l35b6a1d9r3db34.png" alt="image_1ba7rnvjs4gb1l35b6a1d9r3db34.png-28.7kB"></p><center>常用事件，更多事件见[扩展阅读](#扩展阅读)</center><p>而我们在日常开发中，用 Timeline 最多的场景是：</p><ol><li>编写动画，Debug 不流畅的异常帧，针对性优化（见本章<a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a>一节）</li><li>侦测 <strong>重新计算样式</strong>、<strong>重新布局</strong>、<strong>重绘</strong>、<strong>重新合成</strong> 等事件，针对性优化</li><li>了解 JavaScript 函数调用栈以及函数调用带来的回流/重绘事件信息</li><li>查看在某个事件中代码的执行耗时（点击上图 Main 部分，点击下方常驻 Panel 内与文件相关的可点击链接）<br><img src="http://static.zybuluo.com/yangfch3/zhuzgdlqafnkjjzqwin1883w/image_1ba7rah2h136v1keujkjbn7pmv2a.png" alt="image_1ba7rah2h136v1keujkjbn7pmv2a.png-152.8kB"></li></ol><h3 id="让你的-timeline-调试更强大">让你的 Timeline 调试更强大</h3><ol><li><p>选择性地开启以下开关<br><img src="http://static.zybuluo.com/yangfch3/xnq7wto8jihkkkr6yhfiuppx/image_1ba7qso561sv3ep6lur1civ1vba13.png" alt="image_1ba7qso561sv3ep6lur1civ1vba13.png-49.2kB"></p></li><li><p>开启开发者工具实验性特性开关<br><img src="http://static.zybuluo.com/yangfch3/yii0ycjbnmixc2hzgt87w064/image_1ba7r0k4u12du17j819kkvcqgfv1t.png" alt="image_1ba7r0k4u12du17j819kkvcqgfv1t.png-405.1kB"></p><p><img src="http://static.zybuluo.com/yangfch3/akltusf3gvtzafsrg212ot82/image_1ba7r0cuochpk331s6810jq1t8n1g.png" alt="image_1ba7r0cuochpk331s6810jq1t8n1g.png-60.6kB"></p></li></ol><h3 id="扩展阅读">扩展阅读</h3><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool" target="_blank" rel="noopener">Timeline 官方简介</a><br><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference" target="_blank" rel="noopener">Timeline 事件参考</a><br><a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="noopener">推荐：Timeline 进行帧分析，避免页面卡顿</a></p><h2 id="附录">附录</h2><h3 id="浏览器内核与-js-引擎一览">浏览器内核与 JS 引擎一览</h3><table><thead><tr><th style="text-align:center">浏览器/RunTime</th><th style="text-align:center">内核（渲染引擎）</th><th style="text-align:center">JavaScript 引擎</th></tr></thead><tbody><tr><td style="text-align:center">Chrome</td><td style="text-align:center">Blink（28~）<br>Webkit（Chrome 27）</td><td style="text-align:center">V8</td></tr><tr><td style="text-align:center">FireFox</td><td style="text-align:center">Gecko</td><td style="text-align:center">SpiderMonkey</td></tr><tr><td style="text-align:center">Safari</td><td style="text-align:center">Webkit</td><td style="text-align:center">JavaScriptCore</td></tr><tr><td style="text-align:center">Edge</td><td style="text-align:center">EdgeHTML</td><td style="text-align:center">Chakra(for JavaScript)</td></tr><tr><td style="text-align:center">IE</td><td style="text-align:center">Trident</td><td style="text-align:center">Chakra(for JScript)</td></tr><tr><td style="text-align:center">PhantomJS</td><td style="text-align:center">Webkit</td><td style="text-align:center">JavaScriptCore</td></tr><tr><td style="text-align:center">Node.js</td><td style="text-align:center">-</td><td style="text-align:center">V8</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于被删的旧文章</title>
      <link href="/2017/02/21/new-beginning/"/>
      <url>/2017/02/21/new-beginning/</url>
      <content type="html"><![CDATA[<p>受限于以前知识深度与广度，博客旧文章存在诸多谬误，在此为以前传播过错误的知识致歉。如果你是通过搜索引擎或其他文章的引用来到本站进入了 404 页面，而你又对已经删除的文章内容感兴趣，你可以与我联系（yangfch3#<a href="http://gmail.com" target="_blank" rel="noopener">gmail.com</a>）索要旧稿，我会修正旧稿错误后回复给你。</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
