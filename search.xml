<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[pm2 与 log4js 混用指南]]></title>
      <url>/2018/04/22/log4js-with-pm2/</url>
      <content type="html"><![CDATA[<p>我相信你是在使用 <code>pm2</code> 和 <code>log4js</code> 中踩到了坑才会搜素到这篇文章，我便假定你已经对二者都有了基本的了解，遂不再赘述二者的介绍。</p>
<p><code>pm2</code> 在使用 <code>cluster</code> 模式部署应用时，服务都通过 <code>worker</code> 进程提供，<code>pm2</code> 做为 <code>master</code> 进行监控管理。</p>
<img src="/2018/04/22/log4js-with-pm2/pm2.png" alt="pm2" title="pm2">
<p>由于存在多个 <code>worker</code> 进程，那么我们在使用 <code>log4js</code> 进行日志记录时会有下列疑问：</p>
<ol>
<li>多个 <code>worker</code> 进程能否正常写入同一个日志文件</li>
<li>要实现 1，<code>pm2</code> 需要作何处理，<code>log4js</code> 需要作何处理</li>
</ol>
<a id="more"></a>
<h2 id="退而求其次：多进程分日志？">退而求其次：多进程分日志？</h2>
<p>首先来尝试“逃避”上面的两个问题。</p>
<p>要“逃避”上面疑问最简易的方案就是：每个进程写入自己的日志文件（例如：<code>robotService-worker&lt;id&gt;.log</code>）。只需要对 <code>log4js</code> 做一下简易的设置即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    disableClustering: <span class="literal">true</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方案带来了<strong>日志分散、查阅与处理不方便</strong>的问题，一般情况下不采用。此方案较为经典的使用场景是 <code>pomelo</code> 的多进程游戏日志采集（但 <code>pomelo</code> 不是使用 <code>cluster</code> 来搭建集群）。</p>
<h2 id="log4js-与-pm2-相关源码">log4js 与 pm2 相关源码</h2>
<p><code>lib/log4js</code> 下的 <code>getLogger</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Get a logger instance.</span></div><div class="line"><span class="comment"> * <span class="doctag">@static</span></span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> loggerCategoryName</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;Logger&#125; instance of logger for the category</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLogger</span><span class="params">(category)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) &#123;</div><div class="line">    configure(process.env.LOG4JS_CONFIG || defaultConfig);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> cat = category || <span class="string">'default'</span>;</div><div class="line">  debug(`creating logger <span class="keyword">as</span> $&#123;isMaster() ? <span class="string">'master'</span> : <span class="string">'worker'</span>&#125;`);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Logger((isMaster() ? sendLogEventToAppender : workerDispatch), cat);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明 <code>log4js</code> 在 <code>cluster</code> 集群模式下与单进程模式（<strong><code>isMaster</code> 方法来区分</strong>）下获取 <code>logger</code> 的存在差异。我们关注到 <code>log4js</code> 在 <code>worker</code> 进程下执行的是 <strong><code>workerDispatch</code></strong>。</p>
<p>下面是 <code>isMaster</code> 的源码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPM2Master</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.pm2 &amp;&amp; process.env[<span class="built_in">config</span>.pm2InstanceVar] === <span class="string">'0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMaster</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.disableClustering || cluster.isMaster || isPM2Master();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明 <code>log4js</code> 对普通的 <code>cluster</code> 模式和 <code>pm2</code> 的 <code>cluster</code> 模式又做了区分。我们留意到有两个可配置项：<code>pm2</code> <code>pm2InstanceVar</code>，可以查看 <code>log4js</code> 的<a href="https://log4js-node.github.io/log4js-node/api.html" target="_blank" rel="external">文档</a>了解这两个配置项。</p>
<p>继续看 <code>workerDispatch</code> 的源码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">function</span> <span class="selector-tag">workerDispatch</span>(logEvent) &#123;</div><div class="line">  <span class="selector-tag">debug</span>(<span class="built_in">`sending message to master from worker $&#123;process.pid&#125;`</span>);</div><div class="line">  <span class="selector-tag">process</span><span class="selector-class">.send</span>(&#123; <span class="attribute">topic</span>: <span class="string">'log4js:message'</span>, <span class="attribute">data</span>: serialise(logEvent) &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以得知：<strong>在 pm2 cluster 模式下，<code>log4js</code> 不在 worker 进程直接记录日志，而是将需要记录日志的消息发送给 <code>master</code> 进程。</strong></p>
<p><code>log4js</code> 既然有发送消息的代码，那肯定有接收消息的代码，下面是接收消息的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">configurationFileOrObject</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> configObject = configurationFileOrObject;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> configObject === <span class="string">'string'</span>) &#123;</div><div class="line">    configObject = loadConfigurationFile(configurationFileOrObject);</div><div class="line">  &#125;</div><div class="line">  debug(<span class="string">`Configuration is <span class="subst">$&#123;configObject&#125;</span>`</span>);</div><div class="line">  config = <span class="keyword">new</span> Configuration(configObject);</div><div class="line">  <span class="built_in">module</span>.exports.levels = config.levels;</div><div class="line">  <span class="keyword">const</span> loggerModule = logger(config.levels, levelForCategory, setLevelForCategory);</div><div class="line">  Logger = loggerModule.Logger;</div><div class="line">  LoggingEvent = loggerModule.LoggingEvent;</div><div class="line">  <span class="built_in">module</span>.exports.connectLogger = connectModule(config.levels).connectLogger;</div><div class="line"></div><div class="line">  <span class="comment">// just in case configure is called after shutdown</span></div><div class="line">  process.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  <span class="keyword">if</span> (cluster) &#123;</div><div class="line">    cluster.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (config.disableClustering) &#123;</div><div class="line">    debug(<span class="string">'Not listening for cluster messages, because clustering disabled.'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPM2Master()) &#123;</div><div class="line">    <span class="comment">// PM2 cluster support</span></div><div class="line">    <span class="comment">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></div><div class="line">    <span class="comment">// we only want one of the app instances to write logs</span></div><div class="line">    debug(<span class="string">'listening for PM2 broadcast messages'</span>);</div><div class="line">    process.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isMaster) &#123;</div><div class="line">    debug(<span class="string">'listening for cluster messages'</span>);</div><div class="line">    cluster.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    debug(<span class="string">'not listening for messages, because we are not a master process'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  enabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> log4js;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// in a multi-process node environment, worker loggers will use</span></div><div class="line"><span class="comment">// process.send</span></div><div class="line"><span class="keyword">const</span> receiver = <span class="function">(<span class="params">worker, message</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// prior to node v6, the worker parameter was not passed (args were message, handle)</span></div><div class="line">  debug(<span class="string">'cluster message received from worker '</span>, worker, <span class="string">': '</span>, message);</div><div class="line">  <span class="keyword">if</span> (worker.topic &amp;&amp; worker.data) &#123;</div><div class="line">    message = worker;</div><div class="line">    worker = <span class="literal">undefined</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (message &amp;&amp; message.topic &amp;&amp; message.topic === <span class="string">'log4js:message'</span>) &#123;</div><div class="line">    debug(<span class="string">'received message: '</span>, message.data);</div><div class="line">    sendLogEventToAppender(deserialise(message.data));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendLogEventToAppender</span>(<span class="params">logEvent</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span>;</div><div class="line">  debug(<span class="string">'Received log event '</span>, logEvent);</div><div class="line">  <span class="keyword">const</span> appenders = appendersForCategory(logEvent.categoryName);</div><div class="line">  appenders.forEach(<span class="function">(<span class="params">appender</span>) =&gt;</span> &#123;</div><div class="line">    appender(logEvent);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是日志是由 <code>worker</code> --①–&gt; pm2 <code>master</code> --②–&gt; <code>worker</code> 进行的传递，其思路就是日志只由一个 <code>worker</code> 去记录。<strong>而 ② 处的转发以及选择哪一个 <code>worker</code> 去接收就需要 <code>pm2-intercom</code> 这个 pm2 的 module 来处理了。</strong></p>
<h2 id="结论">结论</h2>
<p>要解决前言中的两个疑问，可以这样做：</p>
<ol>
<li><code>pm2</code> 安装 <code>pm2 install pm2-intercom</code></li>
<li><code>log4js</code> 启用以下配置： <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    pm2: <span class="literal">true</span></div><div class="line">    <span class="string">//</span> <span class="string">...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="结束了？">结束了？</h2>
<p>没有。</p>
<p>在上面的代码中我们发现 <code>isPM2Master</code> 的判断中有这样一句代码：<code>process.env[config.pm2InstanceVar] === '0'</code>。</p>
<p>我们查阅 <code>pm2</code> 的<a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="external">文档</a>发现，<code>pm2</code> 的进程都是有编号的，默认使用 <code>NODE_APP_INSTANCE</code> 环境变量（<strong>可以自己配置指定</strong>）上标识是 <code>master</code>（=== ‘0’） 还是 <code>worker</code>。<code>log4js</code> 也是根据这个特征来实现 <code>isPM2Master</code> 检测。</p>
<p>但是 <code>pm2</code> 不一定使用默认的 <code>NODE_APP_INSTANCE</code> 环境变量来编号，可能会变化——可能是用户自己定义了其他名称（例如<code>node-config</code> 将这个环境变量字段占用了，<code>pm2</code> 只能改用其他的），所以当 <code>pm2</code> 改变了字段名时，<code>log4js</code> 要做相应的配置：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attribute">pm2InstanceVar</span>: <span class="string">'INSTANCE_ID'</span>; <span class="comment">// 默认 NODE_APP_INSTANCE，与 pm2 的配置保持一致即可</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附赠：单机多-pm2-实例">附赠：单机多 pm2 实例</h2>
<p>一台机器上可以部署多个 pm2 实例，这在我们需要再一台机器上部署多个不同的服务时可以用到，例如我们可能同时在一台机器上部署 <code>web-server</code> 和 <code>api-server</code>（因为机器紧张等原因）。</p>
<p>当我们第一次调用 <code>pm2</code> 时，我们会发现 <code>$HOME/.pm2</code> 目录被创建，里面存储着**（该）<code>pm2</code> 实例**的运行信息和日志输出。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm2 start app<span class="selector-class">.js</span> -<span class="selector-tag">i</span> <span class="number">3</span> --name=web-server</div></pre></td></tr></table></figure>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># pwd</span></div><div class="line">/home/admin/.pm2</div><div class="line"></div><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># ls -a -l</span></div><div class="line">total 72</div><div class="line">drwxrwxr-x  <span class="number"> 5 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:19 .</div><div class="line">drwx------.<span class="number"> 12 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 11 </span>09:53 ..</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:20 logs</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin  <span class="number"> 127 </span>Mar<span class="number"> 28 </span>20:58 module_conf.json</div><div class="line">drwxrwxr-x  <span class="number"> 3 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 28 </span>20:55 modules</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 16 </span>15:24 pids</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin<span class="number"> 34054 </span>Apr<span class="number"> 16 </span>15:24 pm2.log</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin    <span class="number"> 4 </span>Mar<span class="number"> 29 </span>17:19 pm2.pid</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 pub.sock</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 rpc.sock</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin   <span class="number"> 13 </span>Mar<span class="number"> 24 </span>15:12 touch</div></pre></td></tr></table></figure>
<p>所以要创建多个 <code>pm2</code> 实例就需要每个实例使用不同的目录来存储运行信息。<code>pm2</code> 使用 <code>PM2_HOME</code> 环境变量来识别存储运行信息的目录：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 start app.js -i --name=web-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 web-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 list</div></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 start app.js -i --name=api-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 api-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 list</div></pre></td></tr></table></figure>
<p>为特定的 <code>pm2</code> 实例安装模块：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 install pm2-intercom</div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 install pm2-intercom</div></pre></td></tr></table></figure>
<p>Tip：pm2 模块的安装可以不使用线上下载安装的方式（例如不方便执行 <code>pm2 install</code> 操作时），你只需要将模块放到 <code>modules</code> 目录下，然后修改 <code>module_conf.json</code> 注册模块即可。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dump.pm2</div><div class="line">├── dump<span class="selector-class">.pm2</span><span class="selector-class">.bak</span></div><div class="line">├── logs</div><div class="line">├── module_conf.json</div><div class="line">├── modules</div><div class="line">│   └── pm2-intercom</div><div class="line">│       ├── etc</div><div class="line">│       ├── node_modules</div><div class="line">│       └── package-lock.json</div><div class="line">├── pids</div><div class="line">├── pm2.log</div><div class="line">├── pm2.pid</div><div class="line">├── pub.sock</div><div class="line">├── rpc.sock</div><div class="line">└── touch</div></pre></td></tr></table></figure>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// module_conf.json</div><div class="line">&#123;</div><div class="line">    <span class="string">"pm2-intercom"</span>: &#123;</div><div class="line">        <span class="string">"default-strategy"</span>: <span class="string">"broadcast"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"module-db-v2"</span>: &#123;</div><div class="line">        <span class="string">"pm2-intercom"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Node </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pm2 </tag>
            
            <tag> log4js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[细说 S.O.L.I.D]]></title>
      <url>/2017/11/05/SOLID/</url>
      <content type="html"><![CDATA[<p><code>S.O.L.I.D</code> 五原则（以下简称五原则）：</p>
<ul>
<li><strong>单一功能原则</strong></li>
<li><strong>开放封闭原则</strong></li>
<li><strong>里氏替换原则</strong></li>
<li><strong>接口隔离原则</strong></li>
<li><strong>依赖反转原则</strong>。</li>
</ul>
<a id="more"></a>
<p><img src="http://static.zybuluo.com/yangfch3/1vhmouqgjzw983ftbiuqlyoi/image_1bqcv642t1bj01a041g0udcae4l9.png" alt="image_1bqcv642t1bj01a041g0udcae4l9.png-40kB"></p>
<p><code>S.O.L.I.D</code> 做为面向对象编程和面向对象设计的五个基本原则，在面向对象的软件开发史上做为“最佳实践”指导着人们开发出代码清晰可读、容易维护和扩展的系统。</p>
<p><code>S.O.L.I.D</code> 由 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="external">Robert C. Martin (Uncle Bob)</a> 总结提出。</p>
<h2 id="code-rot">Code rot</h2>
<p><img src="http://static.zybuluo.com/yangfch3/1dl9j3ppshabajdnq3ujua8k/image_1bu3f0pemstn1htf3bl1v9l157719.png" alt="image_1bu3f0pemstn1htf3bl1v9l157719.png-257.2kB"><br>
什么样的代码是烂代码呢？如何识别将来可能会演变成烂代码的代码呢？</p>
<ol>
<li><strong>刚性</strong>：小改变导致整个系统重写</li>
<li><strong>脆弱性</strong>：一个模块的改变导致其他不相关模块行为变得不当，想象一下一台汽车因为电台的变动影响到了车窗的使用</li>
<li><strong>不可迁移性</strong>：一个模块的内部组件不能提取到新环境使用，原因是组件间的耦合与强依赖。规避策略是将中央抽象与 low-level 细节分离</li>
<li><strong>粘性</strong>：当构建和测试难以进行，需要花费大量的时间执行（例如：在充值处做了小改动，也需要花费时间去测试游戏各个环节能否正常运行）</li>
</ol>
<p>人们主要能体会到软件中的两类价值：</p>
<ol>
<li>帮助人们更好地做某件事，提高生产力，降低时间与金钱支出</li>
<li><strong>软件的行为表现</strong>：满足现阶段的用户需求，同时能频繁地变动以满足用户的需求变更，且没有 Bug 与崩溃。</li>
</ol>
<p>第一类价值的保证靠的的团队的产品等角色的发挥，而第二类价值的保证则需要工程师的软件架构设计来保证了，而 S.O.L.I.D 是应用最为广泛也最为基础的设计指导原则。</p>
<hr>
<h2 id="单一功能原则-rsp">单一功能原则 - RSP</h2>
<h3 id="解释">解释</h3>
<p>一个类或类似的结构只做一件事，只因为一个原因而发生变动</p>
<h3 id="详细阐述">详细阐述</h3>
<p>类的一切数据与方法都应该与这个单一的职责有关，即凝聚力。但这并不意味着你的类只能包含一个方法或属性。</p>
<h3 id="优点">优点</h3>
<ol>
<li>降低类的复杂度</li>
<li>提高可维护性</li>
<li>提高可读性</li>
<li>降低需求变化带来的风险</li>
</ol>
<h3 id="示例">示例</h3>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// <span class="type">Not</span> good, **<span class="number">3</span>** responsibility</div><div class="line">class <span class="type">Employee</span> &#123;</div><div class="line">    public <span class="type">Pay</span> calculatePay() <span class="meta">&#123;...&#125;</span> <span class="comment"># 1) calculation logic</span></div><div class="line">    public <span class="built_in">void</span> save() <span class="meta">&#123;...&#125;</span> <span class="comment"># 2) database logic</span></div><div class="line">    public <span class="type">String</span> describeEmployee() <span class="meta">&#123;...&#125;</span> <span class="comment"># 3) reporting logic</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Modem 类的设计改进：<br>
<img src="http://static.zybuluo.com/yangfch3/fhc0rg3c34qz6utayxdxgdsx/image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png" alt="image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png-9.4kB"> =&gt; <img src="http://static.zybuluo.com/yangfch3/op876brznpgc56yawj4dsu1f/image_1bu4tvpgf1nfi2giv6bqjd1apb23.png" alt="image_1bu4tvpgf1nfi2giv6bqjd1apb23.png-28.1kB"></p>
<hr>
<h2 id="开放封闭原则-ocp">开放封闭原则 - OCP</h2>
<h3 id="解释-v2">解释</h3>
<p>软件中的对象（类，模块，函数等等）对扩展开放，对修改封闭。</p>
<h3 id="详细阐述-v2">详细阐述</h3>
<p>现有代码应该只在下面三种情况进行 <strong>修改</strong>：</p>
<ol>
<li>现有代码里有 Bug 或错误</li>
<li>现有代码实现的需求发生了变动（例如之前确定的算法或逻辑发生了改变）</li>
</ol>
<p>下面情况不应该需要改变现有代码，而能通过<strong>继承</strong>、<strong>多态</strong>来进行 <strong>扩展</strong> 即可变更软件的行为：</p>
<ol>
<li>以前做过可预测的同类需求。例如在员工管理系统中需要新增一个员工类型，支付系统需要新增一种支付方式</li>
</ol>
<p>通常的实现方法：<strong>对抽象编程，而不对具体编程；使用抽象类或接口，而不是使用具体的类；新功能的的增加通过实现继承抽象类或实现接口，而非改变已有代码来完成。</strong></p>
<p><strong>只有在将会发生的变化是可预测的情况下，OCP 才会有所帮助，所以你应当只有在类似的变化已经发生过的情况下使用它。</strong></p>
<h3 id="优点-v2">优点</h3>
<ol>
<li>扩展新功能时不容易引入新 Bug</li>
<li>新的功能添加无需对全部代码进行代码审查、单元测试</li>
<li>代码稳定性</li>
<li>解耦，增加弹性</li>
</ol>
<h3 id="实例">实例</h3>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 不难预料，将来可能支持除现金之外的收款方式</span></div><div class="line"><span class="comment"> * 这里直接写死成 acceptCash</span></div><div class="line"><span class="comment"> */</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将来需要新增一种收款方式，可能会被改成这样</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p;</div><div class="line">  <span class="keyword">if</span> (credit)</div><div class="line">    p = acceptCredit(<span class="keyword">total</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PaymentMethod</span> &#123;<span class="function"><span class="keyword">void</span> <span class="title">acceptPayment</span>(<span class="params">Money total</span>)</span>;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkOut</span>(<span class="params">Receipt receipt, PaymentMethod pm</span>) </span>&#123;</div><div class="line">  Money total = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    total += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = pm.acceptPayment(total);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="里氏替换原则-lsp">里氏替换原则 - LSP</h2>
<h3 id="解释-v3">解释</h3>
<p>任何基类可以出现的地方，子类一定可以出现。所有子类需要按照其基本类别的方式进行操作。子类可以扩展父类的功能，但不能改变父类原有的行为预期。</p>
<h3 id="详细阐述-v3">详细阐述</h3>
<p>Liskov 提出的关于继承的原则：<strong>继承必须确保超类中所拥有的属性与方法在子类中仍然拥有</strong>。</p>
<p>Robert C. Martin 提出了更抽象的简化：<strong>子类必须能够替换成他们的基类</strong>。这也是里氏替换原则的精髓。</p>
<p>LSP 是继承复用的基石，只有当子类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而子类也可以在基类的基础上增加新的行为。</p>
<p>一般来说，如果超类的子类型做了超类的客户端所不期望的事情，那么这违背了 LSP。设想一个派生类抛出一个异常，超类不抛出，或者如果一个派生类有一些意想不到的副作用。</p>
<p>更具有指导意义的详细规范：</p>
<ol>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ol>
<h3 id="优点-v3">优点</h3>
<ol>
<li>里氏替换原则是实现开放封闭原则的具体规范</li>
<li>见开放封闭原则的优缺点</li>
</ol>
<h3 id="示例-v2">示例</h3>
<p>见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html" target="_blank" rel="external">链接</a></p>
<hr>
<h2 id="接口隔离原则-isp">接口隔离原则 - ISP</h2>
<h3 id="解释-v4">解释</h3>
<p>一个类不应该被强制依赖它不需要的接口成员。多个小的、特定的、具有内聚性的客户端接口要好于单个宽泛用途的、内聚性差的接口。</p>
<h3 id="详细阐述-v4">详细阐述</h3>
<p>与单一职责原则的不同点：</p>
<ol>
<li>单一职责原则注重的是对象的职责；而接口隔离原则注重对接口依赖的隔离</li>
<li>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</li>
</ol>
<p>接口的粒度需要我们自己去把控，接口的粒度过小会造成接口数量过多，设计复杂化；接口粒度过大，就很容易违背接口隔离原则。</p>
<p>另见下方示例</p>
<h3 id="优点-v4">优点</h3>
<ol>
<li>灵活性</li>
<li>避免接口臃肿</li>
</ol>
<h3 id="示例-v3">示例</h3>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">Messenger</span> &#123;</div><div class="line">  <span class="selector-tag">askForCard</span>();</div><div class="line">  <span class="selector-tag">tellInvalidCard</span>();</div><div class="line">  <span class="selector-tag">askForPin</span>();</div><div class="line">  <span class="selector-tag">tellInvalidPin</span>();</div><div class="line">  <span class="selector-tag">tellCardWasSiezed</span>();</div><div class="line">  <span class="selector-tag">askForAccount</span>();</div><div class="line">  <span class="selector-tag">tellNotEnoughMoneyInAccount</span>();</div><div class="line">  <span class="selector-tag">tellAmountDeposited</span>();</div><div class="line">  <span class="selector-tag">tellBalance</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginMessenger</span> </span>&#123;</div><div class="line">  askForCard();</div><div class="line">  tellInvalidCard();</div><div class="line">  askForPin();</div><div class="line">  tellInvalidPin();	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  tellNotEnoughMoneyInAccount();</div><div class="line">  askForFeeConfirmation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">publc <span class="class"><span class="keyword">class</span> <span class="title">EnglishMessenger</span> <span class="keyword">implements</span> <span class="title">LoginMessenger</span>, <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  ...	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="依赖反转原则-dip">依赖反转原则 - DIP</h2>
<h3 id="解释-v5">解释</h3>
<ol>
<li>高层模块不应该依赖低层模块，所有模块都应该依赖抽象</li>
<li>抽象不应该依赖细节/具体</li>
<li>细节/具体应该依赖抽象</li>
</ol>
<h3 id="详细阐述-v5">详细阐述</h3>
<p>什么是依赖？</p>
<blockquote>
<p>不是我自身的，却是我需要的，都是我所依赖的。<br>
我若依赖你，我就不能离开你。</p>
</blockquote>
<p>什么是高层模块？什么是低层模块？</p>
<blockquote>
<p>类 A 直接依赖于类 B，假如要将类 A 修改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑。类 B 和 C 是底层模块，负责基本的原子操作。</p>
</blockquote>
<p>什么是抽象？什么是细节？</p>
<blockquote>
<p>抽象：抽象类或接口<br>
细节：具体的实现类或实现方法</p>
</blockquote>
<p>这里的依赖是什么？反转后的依赖变成了什么？</p>
<blockquote>
<p>这里的依赖原本指高层模块对低层模块的依赖，倒置的依赖演变成实现类对接口或抽象类的依赖</p>
</blockquote>
<p>反转怎么理解？</p>
<blockquote>
<p>由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。</p>
</blockquote>
<p><img src="http://static.zybuluo.com/yangfch3/dmo4sdqgvlw6uaa0a1eljgjm/image_1bu57m1gtbj8122q11etnn75gm2g.png" alt=""></p>
<h3 id="优点-v5">优点</h3>
<ol>
<li>松散耦合</li>
<li>多人开发，提取模块的抽象，可以进行多人并行开发</li>
<li>违背了依赖反转原则，那么开放封闭原则也就无法实行</li>
</ol>
<h3 id="示例-v4">示例</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块 A</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> &#123;</span> <span class="keyword">char</span> getchar(); &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> &#123;</span> <span class="keyword">void</span> putchar(<span class="keyword">char</span> c)&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharCopier</span> &#123;</span></div><div class="line">  <span class="keyword">void</span> copy(Reader reader, Writer writer) &#123;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">while</span> ((c = reader.getchar()) != EOF) &#123;</div><div class="line">      writer.putchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模块 B</span></div><div class="line"><span class="keyword">public</span> Keyboard <span class="keyword">implements</span> Reader &#123;...&#125;</div><div class="line"><span class="keyword">public</span> Printer <span class="keyword">implements</span> Writer &#123;…&#125;</div><div class="line"></div><div class="line"><span class="comment">// 应用</span></div><div class="line">...</div><div class="line"><span class="keyword">new</span> CharCopier(<span class="keyword">new</span> Keyboard(), <span class="keyword">new</span> Writer());</div></pre></td></tr></table></figure>
<p>或见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html" target="_blank" rel="external">链接</a></p>
<h3 id="说明">说明</h3>
<p>依赖倒置原则的核心就是 <strong>面向接口编程的思想</strong>，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。但是这个原则也是 5 个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p>
<p>依赖倒置原则或者说面向接口编程的思想催生了许多经典的设计模式，欲细究可自行深入研究面向接口编程。</p>
<hr>
<p>参考资料：<br>
<a href="https://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/" target="_blank" rel="external">Object-oriented design principles and the 5 ways of creating SOLID applications</a><br>
<a href="http://www.cnblogs.com/hellojava/category/431379.html" target="_blank" rel="external">http://www.cnblogs.com/hellojava/category/431379.html</a></p>
]]></content>
      
        <categories>
            
            <category> Design Patterns </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Design Patterns </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web 缓存及策略制定]]></title>
      <url>/2017/10/19/HTTP-Cache/</url>
      <content type="html"><![CDATA[<p>我们常常会注意到静态资源后面都跟着一串指纹码：<br>
<img src="http://static.zybuluo.com/yangfch3/8m3e3wnqpmxwhztq755quy1w/image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png" alt="image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png-20.6kB"><br>
<img src="http://static.zybuluo.com/yangfch3/kp4cmtg8o50i34lh501vlhf3/image_1b1c9gujm10snq8f947iv5t49.png" alt="image_1b1c9gujm10snq8f947iv5t49.png-28.4kB"><br>
<img src="http://static.zybuluo.com/yangfch3/s3aubu6l1ylr6igytpuv18y6/image_1b1c9jtvr1aogmd0seg1o0714lu13.png" alt="image_1b1c9jtvr1aogmd0seg1o0714lu13.png-15.8kB"><br>
<img src="http://static.zybuluo.com/yangfch3/44bhvo0c8c89lggd60uyyhqn/image_1b1c9of7qf6b1abfvmp1er12801g.png" alt="image_1b1c9of7qf6b1abfvmp1er12801g.png-17.2kB"></p>
<p>同时我们在进行网络请求分析时会遇到 Cache-Control、Last-Modified 等这些 Header 字段。</p>
<p>在冥冥中，我们知道这些肯定与缓存有着重大的关系。缓存机制中有哪些关键的东西在起作用，如何制定最优的 <strong>缓存-更新</strong> 机制就是本文需要研究的问题。</p>
<a id="more"></a>
<h2 id="前言">前言</h2>
<p>首先让我们来看一次经典的 <strong>请求-响应</strong> 过程，以 <a href="https://zhihu.com" target="_blank" rel="external">zhihu.com</a> 登录页的某个 JavaScript 资源为例：<br>
<img src="http://static.zybuluo.com/yangfch3/0gotv3wpms8o77advh2x4jqn/image_1b1cacu1n1b4019s61jo816fj5ud1t.png" alt="image_1b1cacu1n1b4019s61jo816fj5ud1t.png-586.8kB"></p>
<p>我们从这次连接中看到以下与缓存相关的 HTTP(s) 请求头/响应头：</p>
<ul>
<li>Request Header
<ol>
<li>Cache-Control</li>
<li>If-Modified-Since</li>
<li>If-None-Match</li>
</ol>
</li>
<li>Response Header
<ol>
<li>Cache-Control（图上没有体现）</li>
<li>Last-Modified</li>
<li>ETag</li>
</ol>
</li>
</ul>
<p>一般，我们请求的缓存就是由上述 HTTP Header 进行<strong>校验</strong>与<strong>控制</strong>。是否需要缓存？缓存层级？缓存多久？缓存到期后如何处理？这些问题就是接下来的文章需要解决的。</p>
<h2 id="etag-if-none-match">ETag &amp; If-None-Match</h2>
<p>ETag 我们可以很形象地称之为<strong>验证令牌</strong>，这个令牌在<strong>缓存不符合我们的 Cache-Control 指定的规则</strong> 时起作用。</p>
<p>ETag 由服务器生成，由 Response Header 携带传送给客户端进行保存，客户端请求 Request Header 通过 If-None-Match 携带缓存的 ETag 值给服务器进行校验。</p>
<blockquote>
<p>ETag 是 Response Header 的字段，If-None-Match 是 Request Header 的字段，因为二者功能协作且字段值一致，下面统一用 ETag 代替。</p>
</blockquote>
<p>假如我们有如下静态资源，请求细节如下：<br>
<img src="http://static.zybuluo.com/yangfch3/95pdeafw683dqhtwj8ymhnpp/image_1b1cbv67c17de1kdb16rce9mtk2a.png" alt="image_1b1cbv67c17de1kdb16rce9mtk2a.png-18.4kB"></p>
<p>现在过了 120 秒，浏览器又对该资源发起了请求。</p>
<p>首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应缓存的文件现在已经“过期”，不能直接使用。此时，浏览器可以直接发出新请求，获取新的完整响应，<strong>但是这样做效率较低，因为如果本地缓存已过期，但服务器上资源在此期间未被更改过，我们就没有理由再去下载一遍</strong>。</p>
<p>这就是 ETag 头中指定的验证令牌所要解决的<em>问题</em><sup>1</sup>：服务器会生成并返回一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码（具体实现细节由服务器决定）。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其（通过 If-None-Match 携带）发送给服务器：如果指纹码仍然一致，说明资源未被修改，我们就可以跳过下载，继续延长 Cache-Control（120s）。</p>
<blockquote>
<p>1：如果资源未被更改过，我们就没有理由再去下载与客户端缓存中已有的完全相同的资源。</p>
</blockquote>
<p>总结以上内容就是：</p>
<ol>
<li>ETag 在缓存过期（过了 Cache-Control 指定期限）之后起作用的</li>
<li>ETag 在缓存过期后判定是对缓存<strong>续命</strong>还是<strong>更新</strong></li>
</ol>
<h2 id="last-modified-if-modified-since">Last-Modified &amp; If-Modified-Since</h2>
<p>其实在 ETag 出现之前，就有了 Last-Modified/If-Modified-Since 验证机制。使用资源的最近一次更新时间（Last-Modified）进行校验是最符合我们日常认知的，也是最容易想到的一种方式。</p>
<blockquote>
<p>Last-Modified 是 Response Header 的字段<br>
If-Modified-Since 是 Request Header 的字段</p>
</blockquote>
<p>ETag 的出现是对 Last-Modified 机制的补充与严谨化。</p>
<ul>
<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存（而 ETag 是依据文件内容特征生成的指纹，能更精确地表示文件有无变化）</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Last-Modified 与 ETag 一起使用时，服务器会<strong>优先验证 ETag</strong>，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p>
<h2 id="cache-control">Cache-Control</h2>
<p><code>Cache-Control</code> 有一个比较特殊的点：Request Header 有此字段，Response Header 也有这个字段。</p>
<h3 id="max-age-num">max-age=[num]</h3>
<p>服务器返回头 Cache-Control 的 max-age 告诉客户端：<strong>此资源在客户端缓存时间为多久</strong>。</p>
<p>而比较特殊的 max-age=0 则相当于告知客户端：<strong>此资源刻意缓存在客户端，但每次重新请求都应该向服务器请求校验</strong>。</p>
<ol>
<li>服务器首次返回一个 max-age=0 的静态资源，客户端缓存到本地</li>
<li>客户端需要重新请求此静态资源时，发现本地有缓存，但是缓存已过期（因为 max-age=0）</li>
<li>客户端重新发送请求，携带 If-None-Match 头以及 max-age=0</li>
<li>服务端将收到的 If-None-Match 与文件的 ETag 比对</li>
<li>如果比对不一致，则下发静态资源，同时返回 Cache-Control 头和新的 ETag，客户端比对本地的 ETag 与返回的 ETag 后使用新的资源，并回到步骤 1</li>
<li>如果比对一致，则不下发返回静态资源，同时返回 Cache-Control 头和没变的 ETag，客户端比对本地的 ETag 与返回的 ETag 后直接使用缓存</li>
</ol>
<h3 id="no-cache">no-cache</h3>
<p>Response Header 的 no-cache 和 max-age=0 作用你可以将其等同起来。</p>
<p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#no-cacheno-store" target="_blank" rel="external">链接1</a><br>
<a href="https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">链接2</a></p>
<ol>
<li>no-cache 不代表禁止客户端缓存</li>
<li>no-cache 不是不缓存，而是不直接使用缓存（需要验证）</li>
</ol>
<blockquote>
<p>I believe max-age=0 simply tells caches (and user agents) the response is stale from the get-go and so they SHOULD revalidate the response (eg. with the If-Not-Modified header) before using a cached copy, whereas, no-cache tells them they MUST revalidate before using a cached copy.</p>
</blockquote>
<p><code>Cache-Control: max-age=0</code> 与 <code>Cache-Control: no-cache</code> 可能存在的不同点是：可能在点击浏览器的前进后退按钮时会存在差异。<code>Cache-Control: max-age=0</code> 可以直接使用，而 <code>Cache-Control: no-cache</code> 则会验证。</p>
<p>还有一个问题时，在某些版本的浏览器下，客户端对 no-cache 与 no-store 的处理是一样的：都是直接不缓存。</p>
<p>no-cache 在 Request Header 的作用则比较简单：告诉服务器，本地没有缓存或不使用缓存，你需要给我最新的文件。Chrome 下的强制刷新以及 Disable Cache 采取的就是在 Request Header 使用 no-cache。</p>
<h3 id="no-store">no-store</h3>
<p><code>Cache-Control: no-store</code> 直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</p>
<h3 id="public-private">public &amp; private</h3>
<p>服务器返回的 Cache-Control Header 如果有 public 字段，则表示可以多级缓存（用户代理、CDN、服务提供商）。</p>
<p>private 则表示单用户缓存，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是中间服务商不能缓存。</p>
<h2 id="实例：express-req-fresh-的判定机制">实例：Express req.fresh 的判定机制</h2>
<p>Express 中 req.fresh 用于判定客户端的请求是否是“新鲜”的请求（而不是对已缓存资源的请求），只有当请求头的 <code>cache-control</code> 不等于 <code>no-cache</code> 并且满足以下任意一条才表示客户端的请求是“新鲜”的（即服务器需要提供新资源）：</p>
<blockquote>
<ul>
<li>指定了 <code>if-modified-since</code> 请求头并且 <code>last-modified</code> 请求头等于或时间上早于 <code>modified</code> 响应头</li>
<li><code>if-none-match</code> 请求头是 <code>*</code></li>
<li><code>if-none-match</code> 请求头无法匹配响应头的 <code>etag</code></li>
</ul>
</blockquote>
<h2 id="http-caching-最佳实践">HTTP Caching 最佳实践</h2>
<p><img src="http://static.zybuluo.com/yangfch3/jwinkxrha3w4bkgq59kgr89f/image_1b1ciceslctp1ho2ib1rvf1evj2n.png" alt="image_1b1ciceslctp1ho2ib1rvf1evj2n.png-47.8kB"></p>
<h2 id="缓存与频繁更新的矛盾">缓存与频繁更新的矛盾</h2>
<p>有些资源是需要频繁更新的，但是我们又确实希望客户端对其进行缓存。此时我们就需要<strong>针对我们资源的特性制定不同的缓存策略与缓存级别</strong>，并使用<strong>资源指纹 URL</strong>搭配实现资源的随意更新。</p>
<p>于是我们可以看回本文开始部分介绍的几个典型网站静态资源的指纹URL案例：</p>
<ol>
<li>index.xxxxxxx.js</li>
<li>index$xxxxxx.js</li>
<li>index-xxxxxxx.js</li>
<li>/index.js?x.x.x</li>
</ol>
<p>上面的 <code>x</code> 即为指纹区，选择何种指纹视项目与团队规范而定。</p>
<p><strong>指纹 URL + Cache-Control</strong> 实现缓存与更新的精细控制案例：<br>
<img src="http://static.zybuluo.com/yangfch3/0achbqbncuy3hdfar6l5thm7/image_1b1cj198v4itmue1ishdsecbj34.png" alt="image_1b1cj198v4itmue1ishdsecbj34.png-29.7kB"></p>
<p>分析一下上面的例子：</p>
<ul>
<li>HTML 被标记成 <code>no-cache</code>（或 <code>max-age=0</code>），这意味着浏览器在每次请求时都会重新验证文档，如果内容更改，会获取最新版本。同时，在 HTML 标记中，我们<strong>在 CSS 和 JavaScript 资源的网址中嵌入指纹码</strong>：如果这些文件的内容更改，网页的 HTML 也会随之更改，并将下载 HTML 响应的新副本。</li>
<li>允许浏览器和中继缓存（例如 CDN）缓存 CSS，过期时间设置为 1 年。注意，我们可以放心地使用 1 年的“远期过期”，因为我们在文件名中嵌入了文件指纹码：如果 CSS 更新，网址也会随之更改。</li>
<li>JavaScript 过期时间也设置为 1 年，但是被标记为 private，<strong>也许是因为包含了 CDN 不应缓存的一些用户私人数据</strong>。</li>
<li>缓存图片时不包含版本或唯一指纹码（一般项目中也会包含指纹码），过期时间设置为 1 天。</li>
</ul>
<p>组合使用 <code>ETag</code>、<code>Cache-Control</code> 和唯一网址（指纹 URL），我们可以提供最佳的方案：<strong>较长的过期时间，控制可以缓存响应的位置，以及按需更新。</strong></p>
<h2 id="注意点">注意点</h2>
<ol>
<li>
<p>网址区分大小写</p>
</li>
<li>
<p>除了文中提到的这些 Header 字段，服务器还可以自己制定与实现一些辅助缓存机制的字段。如：<code>X-Cache</code> 这样。</p>
</li>
<li>
<p>如果在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保启用了 HTTP 缓存，并根据用途设置了合理的缓存大小，同时，确保缓存持久化。查看平台文档并确认您的设置！</p>
<blockquote>
<p>例如在微信内 Webview 的缓存就有一些比较特殊的地方，具体可阅读开发文档。</p>
</blockquote>
</li>
<li>
<p>在很多情况下我们还会在响应 Header 内遇到 Expires 字段，这是 HTTP 1.0 时的标准，主要是为了兼容较为老旧的浏览器。在 HTTP 1.1 中定义了 Cache-Control 代替 Expires。</p>
</li>
</ol>
<hr>
<p>参考资料：<br>
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">Google: Web Fundamentals - HTTP Caching</a><br>
<a href="http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">What’s the difference between Cache-Control: max-age=0 and no-cache?</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于被删的旧文章]]></title>
      <url>/2017/09/21/new-beginning/</url>
      <content type="html"><![CDATA[<p>受限于以前知识深度与广度，博客旧文章存在诸多谬误，在此为以前传播过错误的知识致歉。如果你是通过搜索引擎或其他文章的引用来到本站进入了 404 页面，而你又对已经删除的文章内容感兴趣，你可以与我联系（yangfch3#<a href="http://gmail.com" target="_blank" rel="external">gmail.com</a>）索要旧稿，我会修正旧稿错误后回复给你。</p>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Others </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器内核、引擎、页面呈现原理及其优化]]></title>
      <url>/2017/03/04/browser-core-and-engine/</url>
      <content type="html"><![CDATA[<p>介绍浏览器内核、JavaScript 引擎以及页面呈现原理等基础知识，同时根据原理提出页面呈现优化方案。</p>
<a id="more"></a>
<h2 id="浏览器内核">浏览器内核</h2>
<p>浏览器内核又叫渲染引擎，主要负责 HTML、CSS 的解析，页面布局、渲染与复合层合成。浏览器内核的不同带来的主要问题是对 CSS 的支持度与属性表现差异。</p>
<p>现在主流的内核有：Blink、Webkit、Gecko、EdgeHTML、Trident，这里面有几个需要注意的地方：</p>
<ol>
<li>
<p>Blink 是在 Webkit 的基础上的改进，是现在对新特性支持度最好的内核</p>
</li>
<li>
<p>移动端基本上全部是 Webkit 或 Blink 内核（除去 Android 上腾讯家的 X5），这两个内核对新特性的支持度较高，所以新特性可以在移动端大展身手。</p>
</li>
<li>
<p>Trident 是 IE4+ 的内核，一直持续到 IE11，EdgeHTML 是微软抛弃 IE 后开发的全新内核</p>
</li>
<li>
<p>更多资料请看附录表格</p>
</li>
</ol>
<h3 id="几种渲染模式">几种渲染模式</h3>
<p>一般现代浏览器都会有以下几种渲染模式：</p>
<ol>
<li>标准模式</li>
<li>接近标准模式（又称有限怪异模式）</li>
<li>怪异模式</li>
</ol>
<h3 id="不同渲染模式出现的原因">不同渲染模式出现的原因</h3>
<p>在 IE5 与 NS4 那个年代，浏览器大战，标准未立，Web 则在经历早期快速地发展。</p>
<p>后来标准逐步建立，新标准的规范与以前 IE5、NS4 的实现存在着不可避免的差异差异，但是此时的网络世界许许多多旧时的页面正在运行，如果按照新标准的实现来渲染的话会有大量的问题出现。</p>
<p>所以此时大部分现代浏览器厂商想到了区别性地使用<strong>不同渲染模式</strong>来对待这些 Web 页面。</p>
<p>而 IE 随着升级，对现代标准的支持也越来越完善，所以 IE 为了正常渲染旧时页面，<strong>支持我们指定哪个版本的 IE 模式来渲染页面</strong>。</p>
<p>总结就是：</p>
<ol>
<li>怪异模式是 IE5 与 NS4 年代遗留问题的回退方案</li>
<li>怪异模式在大部分浏览器都有部署，并且能在一定的机制下触发</li>
</ol>
<h3 id="不同渲染模式的触发">不同渲染模式的触发</h3>
<p>标准未立之前，HTML 文档是没有文档头的，同时在 HTML5 之前的 HTML4/3 的文档头都有各自的特征，所以在大部分现代浏览器下触发的机制如下：</p>
<ol>
<li>
<p>无 <code>DOCTYPE</code> 头触发<strong>怪异模式</strong></p>
</li>
<li>
<p><code>DOCTYPE</code> 头不正确（不是 html）也触发<strong>怪异模式</strong></p>
<blockquote>
<p>如：<code>&lt;!DOCTYPE svg&gt;</code></p>
</blockquote>
</li>
<li>
<p><code>DOCTYPE</code> 头为 HTML3 头触发<strong>怪异模式</strong></p>
</li>
<li>
<p><code>DOCTYPE</code> 头为 HTML4 头则触发<strong>接近标准模式</strong>（或称<strong>有限怪异模式</strong>）</p>
</li>
<li>
<p>常见的 HTML5 DOCTYPE 声明则使用<strong>标准模式</strong></p>
</li>
</ol>
<p>在 IE 下，除了文档头的差异可以自动触发渲染模式的选择，我们还能手动指定（在 IE8+ 适用）使用哪个版本的 IE 渲染模式来渲染我们的页面（<a href="http://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do" target="_blank" rel="external">扩展阅读</a>）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用当前操作系统已装的最新的 IE --&gt;</span></div><div class="line"><span class="comment">&lt;!-- chrome=1 是针对双核浏览器使优先使用 Chrome --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge,chrome=1"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用 IE9 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=9"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果你需要使用 IE5 的怪异模式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=5"</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="不同渲染模式的表现差异">不同渲染模式的表现差异</h3>
<p><strong>怪异模式与标准模式</strong></p>
<blockquote>
<ol>
<li>怪异模式使用不同于标准的盒模型（也就相当于 IE8+ 下的：<code>box-sizing: border-box</code>）</li>
<li>怪异模式下某些行内（inline）元素的垂直对齐行为表现怪异：<strong>怪异模式下对齐图片至包含它们的盒子的下边框</strong>，而 <strong>标准模式图片对其到父盒的 baseline</strong></li>
</ol>
</blockquote>
<p><strong>接近标准模式（有限怪异模式）与标准模式</strong></p>
<blockquote>
<p>主要区别即为上面的第 2 点</p>
</blockquote>
<h2 id="javascript-引擎">JavaScript 引擎</h2>
<p>JavaScript 负责 JavaScript 代码的解释与执行，主流的 JavaScript 引擎有：V8、SpiderMonkey、JavaScriptCore、Chakra。</p>
<p>浏览器与引擎详情见附录表格。</p>
<h2 id="页面呈现原理">页面呈现原理</h2>
<p>当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后是如何一步步将页面呈现出来的呢？这里面浏览器需要做哪些工作？如何优化呈现的过程提升 Web 应用质量？</p>
<h3 id="六部曲">六部曲</h3>
<p>一个页面的呈现，粗略的说会经过以下这些步骤：</p>
<ol>
<li>
<p>DOM 树的构建（Parse HTML）</p>
</li>
<li>
<p>构建 CSSOM 树（Recaculate Style）</p>
<blockquote>
<p>为什么是 <strong>Re</strong>-caculate Style 呢？这是因为浏览器本身有 <code>User Agent StyleSheet</code>，所以最终的样式是我们的样式代码样式与用户代理默认样式<strong>覆盖/重新计算</strong>得到的。</p>
</blockquote>
</li>
<li>
<p>合并 DOM 树与 CSSOM 树为 Render 树</p>
</li>
<li>
<p>布局（Layout）</p>
</li>
<li>
<p>绘制（Paint）</p>
</li>
<li>
<p>复合图层化（Composite）</p>
<blockquote>
<p>图层化是自己理解后形象的意译</p>
</blockquote>
</li>
</ol>
<p>其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。</p>
<h3 id="六部曲中的阻塞">六部曲中的阻塞</h3>
<p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p>
<p>我们来分析这六部曲中存在的阻塞问题：</p>
<ol>
<li>
<p>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（<strong>阻塞 1</strong>）</p>
<blockquote>
<p>那是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定，见 2</p>
</blockquote>
</li>
<li>
<p>当遇到 <code>&lt;script&gt;</code> 标签需要执行脚本代码时，浏览器会检查是否这个 <code>&lt;script&gt;</code> 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 <code>&lt;script&gt;</code> 上部还有 CSS 样式没加载，则浏览器会等待 <code>&lt;script&gt;</code> 上方样式的加载完成才会执行该 <code>&lt;script&gt;</code> 内的脚本（<strong>阻塞 2</strong>）</p>
</li>
<li>
<p>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（<strong>同步阻塞</strong>）</p>
</li>
<li>
<p>同时外部脚本、外部样式表的下载也是耗费时间较多的点</p>
</li>
</ol>
<h3 id="六部曲之-dom-树的构建">六部曲之 DOM 树的构建</h3>
<p><img src="http://static.zybuluo.com/yangfch3/ob8y6inhvvmg6rl9z4vn43fq/image_1ba5aftnnm7i11t8kl716c2164o9.png" alt="image_1ba5aftnnm7i11t8kl716c2164o9.png-96.9kB"><br>
浏览器构建 DOM 树可以简单的总结为以下几步：</p>
<ol>
<li>
<p><strong>转码（Bytes -&gt; Characters）</strong>—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</p>
</li>
<li>
<p><strong>Tokens 化（Characters -&gt; Tokens）</strong>—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</p>
</li>
<li>
<p><strong>构建 Nodes（Tokens -&gt; Nodes）</strong>—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br>
<img src="http://static.zybuluo.com/yangfch3/hfa6bzlsczzalvk5t89aa56f/image_1ba5an0vmfsn1kb928a1lv8vkpm.png" alt="image_1ba5an0vmfsn1kb928a1lv8vkpm.png-49.2kB"></p>
</li>
<li>
<p><strong>构建 DOM 树（Nodes -&gt; DOM Tree）</strong>—— 最重要的工作是建立起每个结点的父子兄弟关系</p>
</li>
</ol>
<blockquote>
<p><strong>在 Chrome 开发者工具下 Timeline 面板的 <code>Parse HTML</code> 阶段对应着 DOM 树的构建</strong>。</p>
</blockquote>
<br>
扩展阅读：[从Chrome源码看浏览器如何构建DOM树
](https://zhuanlan.zhihu.com/p/24911872?refer=dreawer)
> 留意这篇文章的这些点：
>
> 1. DOM 构建时对 DOCType 处理
> 2. DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响
> 3. 处理开标签与闭标签的压栈、弹栈处理
> 4. Chromium 对待自定义标签的处理
> 5. JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比
<h3 id="六部曲之-cssom-树的构建">六部曲之 CSSOM 树的构建</h3>
<p>CSSOM 树的构建 “原料” 的来源有：<strong>外部 CSS 文件、内部样式、内联样式</strong>。</p>
<p>CSSOM 树的构建其实是一个 <strong>样式的重新计算</strong> 的过程，为什么是重新计算呢？</p>
<blockquote>
<p>用户代理（即浏览器）本身有一套内置样式表，<strong>所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算</strong>。</p>
<p>所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 <code>Recalculate Style</code> 阶段</p>
</blockquote>
<p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br>
<img src="http://static.zybuluo.com/yangfch3/brh4juu5r4r8f7oh9jrekcle/image_1ba7m6adr1h52bm2mblup214t59.png" alt="image_1ba7m6adr1h52bm2mblup214t59.png-10.3kB"></p>
<p>最终构建的 CSSOM 树大致如下：<br>
<img src="http://static.zybuluo.com/yangfch3/yes5apeozng4x0j3xpjj3ubi/image_1ba7m7h67t731ikr1461topakgm.png" alt="image_1ba7m7h67t731ikr1461topakgm.png-42.2kB"></p>
<h3 id="六部曲之渲染树的构建">六部曲之渲染树的构建</h3>
<ol>
<li>
<p>DOM 树与 CSSOM 树融合成渲染树</p>
</li>
<li>
<p>渲染树只包括渲染页面需要的节点</p>
<blockquote>
<p>排除 <code>&lt;script&gt;</code> <code>&lt;meta&gt;</code> 等功能化、非视觉节点<br>
排除 <code>display: none</code> 的节点</p>
</blockquote>
</li>
</ol>
<p><img src="http://static.zybuluo.com/yangfch3/27ik5bf4rguih1mrpi112opo/image_1ba7mjun4h4l123b1smn13indhg13.png" alt="image_1ba7mjun4h4l123b1smn13indhg13.png-116.2kB"></p>
<h3 id="六部曲之布局">六部曲之布局</h3>
<p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。</p>
<blockquote>
<p><strong>Layout 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</strong></p>
</blockquote>
<p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 <code>Layout trashing</code>，又叫做回流（Reflow）。</p>
<h3 id="六部曲之绘制">六部曲之绘制</h3>
<p>一旦布局（Layout）步骤完成，浏览器便触发 “Paint Setup” 与 “Paint” 事件（渲染引擎底层概念），执行 <code>paint</code> 操作，<strong>结合渲染树与布局信息绘制实际像素</strong>。</p>
<blockquote>
<p>注：在 Timeline 工具内，<code>Layout</code> 与 <code>Paint</code> 两个过程被统一归并到 <code>Paint</code> 阶段。</p>
</blockquote>
<h3 id="六部曲之复合图层化">六部曲之复合图层化</h3>
<p>在很多情况下，我们<strong>不会将复合图层化</strong>归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p>
<p>见 <a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="external">链接</a></p>
<h2 id="页面性能优化">页面性能优化</h2>
<p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p>
<h3 id="优化不可避免的阻塞：优化关键呈现路径">优化不可避免的阻塞：优化关键呈现路径</h3>
<p><strong>关键呈现路径里的一些概念</strong>：</p>
<ul>
<li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li>
<li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li>
<li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li>
</ul>
<p><strong>优化关键呈现路径的指导原则</strong>：</p>
<ul>
<li>尽量减少关键资源数量。</li>
<li>尽量减少关键字节数。</li>
<li>尽量缩短关键路径的长度。</li>
</ul>
<p><strong>优化关键呈现路径常规步骤</strong>：</p>
<ol>
<li>分析和描述关键路径：资源数量、字节数、长度。</li>
<li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li>
<li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li>
<li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li>
</ol>
<p><strong>优化关键呈现路径的具体建议</strong>：</p>
<ol>
<li>
<p>文件合并、压缩</p>
</li>
<li>
<p>推荐使用异步（<code>async</code>） JavaScript 资源，或使用延迟（<code>defer</code>）执行的 JavaScript</p>
</li>
<li>
<p>一般 <code>&lt;script&gt;</code> 脚本的靠后书写</p>
</li>
<li>
<p>避免运行时间长的 JavaScript，<strong>耗时任务的拆分，chunk 化运行</strong></p>
<blockquote>
<p>例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</p>
</blockquote>
</li>
<li>
<p>避免使用 CSS import</p>
</li>
<li>
<p>内联、内部化阻止呈现的 CSS</p>
<blockquote>
<p>一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</p>
</blockquote>
</li>
</ol>
<h3 id="针对复合图层化的优化">针对复合图层化的优化</h3>
<p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p>
<h4 id="复合图层化机制">复合图层化机制</h4>
<p>某些属性的变更（<code>transform</code>、<code>opacity</code>）满足以下条件：</p>
<ul>
<li>不影响文档流。</li>
<li>不依赖文档流。</li>
<li>不会造成重绘。</li>
</ul>
<p>那么这些属性变更时就需要一种机制：机制需要能将属性变更的部分与页面其他部分隔离开来，其他部分已经渲染完好进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。</p>
<p>所以图层化的关键字：<strong>缓存</strong>、<strong>隔离</strong>、<strong>图层合成</strong></p>
<p>使用 <code>transform</code> 与 <code>opacity</code> 进行属性变更是经典的符合图层化方法，以下是其他会<strong>提升元素为复合图层的场景</strong>：</p>
<ol>
<li>3d 或透视变换 CSS 属性，例如 <code>translate3d</code>, <code>translateZ</code> 等等（JS 一般通过这种方式，使元素获得复合图层）</li>
<li><code>&lt;video&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;canvas&gt;</code> <code>&lt;webgl&gt;</code> 等元素。</li>
<li>混合插件（如flash）。</li>
<li>元素自身的 <code>opacity</code> 和 <code>transform</code> 做 CSS 动画。</li>
<li>拥有 CSS Filter 的元素。</li>
<li>使用 <code>will-change</code> 属性。</li>
<li><code>position:fixed</code>。</li>
<li>元素有一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</li>
</ol>
<h4 id="图层化的优势">图层化的优势</h4>
<p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来动画性能的提升。</p>
<h4 id="图层化的潜在问题-内存开销">图层化的潜在问题 —— 内存开销</h4>
<p>那么图层化的弊端在哪里呢？</p>
<p>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况（如下图）。</p>
<center>![image_1baah8s0vcol3464t21foe1sb91g.png-31.3kB][7]</center>
<center>同样表现的页面，单图层与多图层的内存开销</center>
<h4 id="因为开销-所以节制">因为开销，所以节制</h4>
<p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p>
<h3 id="针对回流的优化">针对回流的优化</h3>
<ol>
<li>
<p><a href="https://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a></p>
<ol>
<li>CSS3 &gt; JavaScript</li>
<li>属性变更优先考虑顺序（性能表现排序）
<ol>
<li><code>transfrom</code>, <code>opacity</code></li>
<li><code>background-color</code> 等</li>
<li><code>position</code> - <code>top</code> <code>bottom</code> <code>left</code> <code>right</code></li>
<li><code>width</code> <code>height</code> 等</li>
<li><code>margin</code>, <code>padding</code>, <code>border</code></li>
</ol>
</li>
</ol>
</li>
<li>
<p><a href="https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9" target="_blank" rel="external">What forces layout</a></p>
<blockquote>
<p>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。</p>
<p>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</p>
</blockquote>
</li>
</ol>
<h3 id="其他优化技巧">其他优化技巧</h3>
<h4 id="节流函数">节流函数</h4>
<p>已经比较明白了，那就略吧</p>
<h4 id="惰性载入函数">惰性载入函数</h4>
<p>也已经比较明白，也略吧</p>
<h4 id="重任务分片多帧">重任务分片多帧</h4>
<p><a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="external">实例讲解</a></p>
<h2 id="timeline-工具">Timeline 工具</h2>
<p>使用 Timeline 工具我们能做以下事：</p>
<ol>
<li>页面渲染帧率分析，得到异常帧信息</li>
<li>各类文件执行耗时/耗资源分析</li>
<li>文件等待 - 下载时间</li>
<li>页面呈现期间的事件列表</li>
<li>某个帧/某个事件的详细信息分析</li>
</ol>
<p><img src="http://static.zybuluo.com/yangfch3/xrxcqw4c0ignhkxgsfiqssrk/image_1ba7qi29r1b5f12c7tvh1muh9rm.png" alt="image_1ba7qi29r1b5f12c7tvh1muh9rm.png-524.5kB"></p>
<center>理解 Timeline 工具使用，读懂这图就够了</center>
<p><img src="http://static.zybuluo.com/yangfch3/vrr16pctepw9uct9raq881ps/image_1ba7rnvjs4gb1l35b6a1d9r3db34.png" alt="image_1ba7rnvjs4gb1l35b6a1d9r3db34.png-28.7kB"></p>
<center>常用事件，更多事件见[扩展阅读](#扩展阅读)</center>
<p>而我们在日常开发中，用 Timeline 最多的场景是：</p>
<ol>
<li>编写动画，Debug 不流畅的异常帧，针对性优化（见本章<a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a>一节）</li>
<li>侦测 <strong>重新计算样式</strong>、<strong>重新布局</strong>、<strong>重绘</strong>、<strong>重新合成</strong> 等事件，针对性优化</li>
<li>了解 JavaScript 函数调用栈以及函数调用带来的回流/重绘事件信息</li>
<li>查看在某个事件中代码的执行耗时（点击上图 Main 部分，点击下方常驻 Panel 内与文件相关的可点击链接）<br>
<img src="http://static.zybuluo.com/yangfch3/zhuzgdlqafnkjjzqwin1883w/image_1ba7rah2h136v1keujkjbn7pmv2a.png" alt="image_1ba7rah2h136v1keujkjbn7pmv2a.png-152.8kB"></li>
</ol>
<h3 id="让你的-timeline-调试更强大">让你的 Timeline 调试更强大</h3>
<ol>
<li>
<p>选择性地开启以下开关<br>
<img src="http://static.zybuluo.com/yangfch3/xnq7wto8jihkkkr6yhfiuppx/image_1ba7qso561sv3ep6lur1civ1vba13.png" alt="image_1ba7qso561sv3ep6lur1civ1vba13.png-49.2kB"></p>
</li>
<li>
<p>开启开发者工具实验性特性开关<br>
<img src="http://static.zybuluo.com/yangfch3/yii0ycjbnmixc2hzgt87w064/image_1ba7r0k4u12du17j819kkvcqgfv1t.png" alt="image_1ba7r0k4u12du17j819kkvcqgfv1t.png-405.1kB"></p>
<p><img src="http://static.zybuluo.com/yangfch3/akltusf3gvtzafsrg212ot82/image_1ba7r0cuochpk331s6810jq1t8n1g.png" alt="image_1ba7r0cuochpk331s6810jq1t8n1g.png-60.6kB"></p>
</li>
</ol>
<h3 id="扩展阅读">扩展阅读</h3>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool" target="_blank" rel="external">Timeline 官方简介</a><br>
<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference" target="_blank" rel="external">Timeline 事件参考</a><br>
<a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="external">推荐：Timeline 进行帧分析，避免页面卡顿</a></p>
<h2 id="附录">附录</h2>
<h3 id="浏览器内核与-js-引擎一览">浏览器内核与 JS 引擎一览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器/RunTime</th>
<th style="text-align:center">内核（渲染引擎）</th>
<th style="text-align:center">JavaScript 引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Chrome</td>
<td style="text-align:center">Blink（28~）<br>Webkit（Chrome 27）</td>
<td style="text-align:center">V8</td>
</tr>
<tr>
<td style="text-align:center">FireFox</td>
<td style="text-align:center">Gecko</td>
<td style="text-align:center">SpiderMonkey</td>
</tr>
<tr>
<td style="text-align:center">Safari</td>
<td style="text-align:center">Webkit</td>
<td style="text-align:center">JavaScriptCore</td>
</tr>
<tr>
<td style="text-align:center">Edge</td>
<td style="text-align:center">EdgeHTML</td>
<td style="text-align:center">Chakra(for JavaScript)</td>
</tr>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:center">Trident</td>
<td style="text-align:center">Chakra(for JScript)</td>
</tr>
<tr>
<td style="text-align:center">PhantomJS</td>
<td style="text-align:center">Webkit</td>
<td style="text-align:center">JavaScriptCore</td>
</tr>
<tr>
<td style="text-align:center">Node.js</td>
<td style="text-align:center">-</td>
<td style="text-align:center">V8</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> Browser </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
