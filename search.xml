<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【译】Node.js的事件循环（Event loop）、定时器（Timers）和 process.nextTick()]]></title>
      <url>/2018/11/01/event-loop-timers-and-nexttick-cn/</url>
      <content type="html"><![CDATA[<p>翻译自 Node.js 官方文档：<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="external">The Node.js Event Loop, Timers, and process.nextTick()</a></p>
<a id="more"></a>
<h2 id="什么是事件循环？">什么是事件循环？</h2>
<p>事件循环是一种允许 Node.js 实现无阻塞的 IO 操作 —— 尽管 JavaScript 是单线程的 —— 通过尽可能将操作卸到系统内核的机制。</p>
<p>因为大部分现代内核都是多线程的，他们可以在后台执行多个操作。当这些操作的其中一个完成后，内核告知 Node.js 以便对应的回调能添加到 <strong>poll</strong> 队列以最终执行。下面我们将深入这个主题的细节。</p>
<h2 id="事件循环解析">事件循环解析</h2>
<p>当 Node.js 启动，它初始化事件循环，处理提供的输入脚本（或将脚本放到 <code>REPL</code> 内，不再本文的讨论范围内），脚本可能做了异步 API 调用、定时器或者调用 <code>process.nextTick()</code>。然后开始处理事件循环。</p>
<blockquote>
<p>换句话说，先执行完脚本中同步的代码。</p>
</blockquote>
<p>下面的图表展示了事件循环操作顺序的简单概览：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   ┌───────────────────────────┐</div><div class="line">┌─&gt;│           timers          │</div><div class="line">│  └─────────────┬─────────────┘</div><div class="line">│  ┌─────────────┴─────────────┐</div><div class="line">│  │     pending callbacks     │</div><div class="line">│  └─────────────┬─────────────┘</div><div class="line">│  ┌─────────────┴─────────────┐</div><div class="line">│  │       idle, prepare       │</div><div class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</div><div class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</div><div class="line">│  │           poll            │&lt;─────┤  connections, │</div><div class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</div><div class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</div><div class="line">│  │          <span class="built_in"> check </span>          │</div><div class="line">│  └─────────────┬─────────────┘</div><div class="line">│  ┌─────────────┴─────────────┐</div><div class="line">└──┤      close callbacks      │</div><div class="line">   └───────────────────────────┘</div></pre></td></tr></table></figure>
<blockquote>
<p><em>注：左边每个块在事件循环中被称为 “阶段”</em></p>
</blockquote>
<p>每个阶段有一个 FIFO（先进先出）的将要执行的回调函数的队列。虽然每个阶段都有自己独特运行的地方，但通常来说，当事件循环进入一个指定的阶段，它将执行特定于该阶段的任何操作，然后执行该阶段的队列中的回调函数直到队列消耗完毕或执行函数的数量达到了最大值。当回调函数队列被耗尽或达到了回调极限，事件循环将进入下一个阶段，下一个阶段如是。</p>
<p>由于这些操作中的任何一个可以规划更多操作并且在 <code>poll</code> 阶段中处理的新事件（例如新的连接来了，新的数据来了的回调）由内核排队，因此新的 <code>poll</code> 事件可以在处理 <code>poll</code> 事件时继续加入队列。因此，长时间运行的回调可以允许轮询阶段运行的时间比计时器的阈值长得多。有关详细信息，请参阅下面的 <code>timers</code> 和 <code>poll</code> 章节。</p>
<blockquote>
<p><em>注：Windows 和 Unix/Linux 实现之间存在轻微差异，但对于本文这个并不重要。</em><br>
<em>这里讲的是最重要的部分，实际上有 7,8 个步骤，但我们关心的，Node.js 实际上使用的就是上面这些</em></p>
</blockquote>
<h2 id="阶段概览">阶段概览</h2>
<ul>
<li><strong>timers</strong>: 这个阶段执行由 <code>setTimeout()</code> 和 <code>setInterval()</code> 规划的回调</li>
<li><strong>pending callbacks</strong>: 执行延迟到下一个循环迭代的 I/O 回调</li>
<li><strong>idle, prepare</strong>: 只在内部使用</li>
<li><strong>poll</strong>: 检索新的 I/O 事件，执行 I/O 相关回调（除了 <code>close callback</code>，定时器和 <code>setImmediate()</code> 规划之外的几乎所有回调），节点将在适当的时候阻塞</li>
<li><strong>check</strong>: <code>setImmediate()</code>回调在这里执行</li>
<li><strong>close callbacks</strong>: 一些 <code>close callbacks</code>，例如 <code>socket.on ('close', fn)</code> 的 <code>fn</code></li>
</ul>
<p>在事件循环的每次运行之间，Node.js 检查它是否在等待任何异步 I/O 或定时器，如果没有，则关闭事件循环，进程退出。</p>
<h2 id="阶段细节">阶段细节</h2>
<h3 id="timers">timers</h3>
<p>一个定时器指定了阈值，阈值是指之后被提供的回调函数<strong>可能</strong>被执行，而不是我们希望他被执行的确切时间。定时器回调在给定的时间过完后尽可能早地执行，然而，操作系统规划或运行其他回调可能延迟定时器回调的执行。</p>
<blockquote>
<p><em>注：技术上 <code>poll</code> 阶段控制了定时器的回调什么时候执行</em></p>
</blockquote>
<p>一个例子，你规划了一个 timeout 在 100ms 的阈值后执行回调，然后你的脚本开始一个花费 95ms 异步文件读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// Assume this takes 95ms to complete</span></div><div class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</div><div class="line">&#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></div><div class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">  <span class="comment">// do something that will take 10ms...</span></div><div class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当事件循环进入 <code>poll</code> 阶段，它的队列为空（<code>fs.readFile()</code> 还没有完成），所以它将等待剩余的毫秒数，直到最快的定时器阈值到达。然而，等待 95ms 后，<code>fs.readFile()</code> 结束了文件的读取，它的需要花费 10ms 才能完成的回调将加入 <code>poll</code> 队列，此时 <code>poll</code> 队列为非空，开始遍历队列以执行。当该回调结束，队列里没有了其他回调函数，于是事件循环将看到最快的定时器到达了阈值，然后折返回 <code>timers</code> 阶段去执行定时器回调。在上面的例子里，你将看到定时器从规划到它的回调被执行总共延时了 105ms（而不是预期的 100ms）。</p>
<blockquote>
<p><em>注：为了防止 <code>poll</code> 阶段“饿死”事件循环，<code>libuv</code>（实现了 Node.js 所有异步行为及事件循环的 C 库）有一个强制的最大值，到达最大值将会停止 <code>polling</code> 更多事件</em></p>
</blockquote>
<h3 id="pending-callbacks">pending callbacks</h3>
<p>此阶段执行某些系统操作（例如TCP错误类型）的回调。例如，如果 TCP 套接字在尝试连接时收到 ECONNREFUSED，则某些 <code>*nix</code> 系统希望等待报告错误。这将加入到 <code>pending callbacks</code> 的执行队列。</p>
<h3 id="poll">poll</h3>
<p><code>poll</code> 阶段有两个主要的功能</p>
<ol>
<li>计算 <code>poll</code> 阶段应该阻塞和轮询 I/O 多久，然后</li>
<li>处理 <code>poll</code> 队列里的事件代码</li>
</ol>
<p>当事件循环进入 <code>poll</code> 阶段，开始轮询，会按照下面的规则运行：</p>
<ol>
<li>
<p>如果 <code>poll</code> 队列不为空，事件循环将遍历回调队列同步执行直到队列耗尽或达到了系统强制的极限</p>
</li>
<li>
<p>如果 <code>poll</code> 队列为空，又分为以下两种情况</p>
<ol>
<li>如果脚本出现了 <code>setImmediate()</code> 规划（<code>setImmediate()</code> 的回调将加入 <code>check</code> 阶段的队列），事件循环将结束 <code>poll</code> 阶段，然后进入 <code>check</code> 阶段以执行 <code>setImmediate()</code> 的回调</li>
<li>如果脚本没有出现 <code>setImmediate()</code> 规划，事件循环将检查是否有定时器达到了阈值，根据是否有一个或多个 <code>timer</code> 达到了阈值，又可以分为以下两种情况：
<ol>
<li>没有 <code>timer</code> 达到了阈值，事件循环将等待新的回调加到 <code>poll</code> 队列（incoming connection, request 等）</li>
<li>有一个或多个 <code>timer</code> 达到了阈值，事件循环将折回到 <code>timer</code> 阶段执行定时器的回调</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">poll -----&gt; &lt;circle wait&gt;</div><div class="line">  |</div><div class="line">  |--------</div><div class="line">  |       |</div><div class="line">  v       v</div><div class="line">check    timer</div></pre></td></tr></table></figure>
<h3 id="check">check</h3>
<p>这个阶段允许我们<strong>在 <code>poll</code> 阶段完成后立即执行回调</strong>，如果 <code>poll</code> 阶段空闲（idle）并且脚本调用了 <code>setImmediate()</code>，事件循环将进入 <code>check</code> 阶段而不是等待。</p>
<p><code>setImmediate()</code> 实际上是一个特殊的定时器，它在事件循环的一个单独阶段运行。它使用 <code>libuv</code> API 来调度在 <code>poll</code> 阶段完成后执行的回调。</p>
<h3 id="close-callbacks">close callbacks</h3>
<p>如果一个 <code>socket</code> 或 <code>handle</code> 突然被关闭（例如：<code>socket.destroy()</code>，<code>close</code> 事件将会在这个阶段触发）。否则它将通过 <code>process.nextTick()</code> 来触发</p>
<h2 id="setimmediate-vs-settimeout">setImmediate() vs setTimeout()</h2>
<p><code>setImmediate()</code> 和 <code>setTimeout()</code> 相似，但是行为上的差异决定于它们合适被调用</p>
<ul>
<li><code>setImmediate()</code> 被设计用于一旦当前 <code>poll</code> 阶段完成后便执行其回调</li>
<li><code>setTimeout()</code> 规划在经过最小阈值（以 ms 为单位）后运行的脚本</li>
</ul>
<p>执行上面两个定时器的顺序将根据调用它们的上下文而有所不同。如果从主模块中调用两者，则时间将受到进程性能的限制（可能受到计算机上运行的其他应用程序的影响）。</p>
<p>例如，如果我们运行不在 I/O 周期内的以下脚本（即主模块中调用），则执行两个定时器的顺序是不确定的，因为它受到进程性能的约束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// timeout_vs_immediate.js</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node timeout_vs_immediate.js</div><div class="line">timeout</div><div class="line">immediate</div><div class="line"></div><div class="line">$ node timeout_vs_immediate.js</div><div class="line">immediate</div><div class="line">timeout</div></pre></td></tr></table></figure>
<p>但是，如果移动到 I/O 周期内对两个进行调用，则始终首先执行 <code>setImmediate()</code> 的回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// timeout_vs_immediate.js</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.readFile(__filename, () =&gt; &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node timeout_vs_immediate.js</div><div class="line">immediate</div><div class="line">timeout</div><div class="line"></div><div class="line">$ node timeout_vs_immediate.js</div><div class="line">immediate</div><div class="line">timeout</div></pre></td></tr></table></figure>
<p>使用 <code>setImmediate()</code> 而不是 <code>setTimeout()</code> 的主要优点是 <code>setImmediate()</code> 将始终在任何定时器之前执行（如果在相同的 I/O 周期内调度），与存在多少定时器无关。</p>
<h2 id="process-nexttick">process.nextTick()</h2>
<h3 id="理解-process-nexttick">理解 process.nextTick()</h3>
<p>你可能注意到了 <code>process.nextTick()</code> 不在上面的示意图表里，尽管它也是异步 API 的一部分。这是因为从技术上来说，<code>process.nextTick()</code> 不是事件循环的一部分。<code>process.nextTick()</code> 将会在当前操作（当前正在运行的队列中的某个回调）完成后马上被执行，不论当前处于事件循环处于哪个阶段。</p>
<p>回看之前的示意图，在给定阶段的任何时间调用 <code>process.nextTick()</code>，在继续事件循环之前，所有传入 <code>process.nextTick()</code> 的回调函数将会被执行。通过递归的 <code>process.nextTick</code>，会“饿死”你的 I/O，阻止事件循环到达 <code>poll</code> 阶段，导致出现一些糟糕的场景。</p>
<h3 id="为什么我们会这样做？">为什么我们会这样做？</h3>
<p>为什么 Node.js 中会出现 <code>process.nextTick()</code> 这样的东西？**有一部分原因是 Node.js 的设计理念：当某个 API 应该始终是异步的，即使在某些地方使用时不是必须的（这个时候 <code>process.nextTick()</code> 可以实现这种同步 API 向异步 API 的转化）**它不是必须的。以此代码段为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiCall</span>(<span class="params">arg, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'string'</span>)</div><div class="line">    <span class="keyword">return</span> process.nextTick(callback,</div><div class="line">                            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument should be string'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码片段进行参数检查，如果不正确，它会将错误传递给回调。最近更新的 API 允许将参数传递给 <code>process.nextTick()</code>，允许它将回调后传递的任何参数作为参数传播到回调，因此您不必嵌套函数。</p>
<p>我们上面做的是将错误传回给用户，但只有在我们允许其余的用户代码（同步代码）执行之后。通过使用 <code>process.nextTick()</code>，我们保证 <code>apiCall()</code> 始终<strong>在用户代码的其余部分之后</strong>（即当前的所有同步代码执行之后）和<strong>允许事件循环继续之前</strong>运行其回调。为了实现这个，JS 调用栈允许被展开，然后立即执行传入的回调函数，回调函数允许我们继续递归调用 <code>process.nextTick()</code> 而不会触发 <code>RangeError: Maximum call stack size exceeded from v8.</code></p>
<blockquote>
<p><em>笔者注：调用栈展开又可成为调用栈释放</em></p>
</blockquote>
<blockquote>
<p><em>笔者注：此处的意思是指 <code>process.nextTick(() =&gt; {})</code> 的方式会导致函数调用栈溢出的问题，而 <code>process.nextTick(fn, args)</code> 则可以防止函数调用栈溢出</em></p>
<p><em>笔者注：类似尾递归优化的原理</em></p>
</blockquote>
<p>（如果没有 <code>process.nextTick()</code> 来转化为异步 API）这种理念（即某些 API 必须是异步的）可能会导致一些潜在的问题。以此片段为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bar;</div><div class="line"></div><div class="line"><span class="comment">// this has an asynchronous signature, but calls callback synchronously</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123; callback(); &#125;</div><div class="line"></div><div class="line"><span class="comment">// the callback is called before `someAsyncApiCall` completes.</span></div><div class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// since someAsyncApiCall has completed, bar hasn't been assigned any value</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// undefined</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bar = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>用户将 <code>someAsyncApiCall()</code> 定义为具有异步签名（函数名中体现了），但它实际上是同步操作。调用它时，在事件循环的同一阶段调用提供给 <code>someAsyncApiCall()</code> 的回调，因为 <code>someAsyncApiCall()</code> 实际上不会异步执行任何操作。因此，回调尝试引用变量 <code>bar</code>，尽管它在范围内可能没有该变量，因为该脚本还没有运行完成。</p>
<p>通过将回调函数放置在 <code>process.nextTick()</code>，脚本便能够运行完整（同步代码能全部执行完），允许在调用回调之前初始化所有变量，函数等。它还具有暂时跳出事件循环继续的优点。<strong>在允许事件循环继续之前，向用户警告错误可能是有用的</strong>。以下前一个示例使用 <code>process.nextTick()</code> 的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bar;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  process.nextTick(callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bar = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这是一个实际的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</div><div class="line"></div><div class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当只有一个端口作为参数传入，端口立即被绑定。所以注册的 <code>listening</code> 回调可以设置为立即被调用。问题是：<code>on('listening')</code> 回调在那时可能还没被注册。</p>
<p>为了解决这个问题，<code>listening</code> 事件通过 <code>nextTick()</code> 被入队（nextTick Queue）以允许脚本先执行完（同步代码）。这允许用户（在同步代码中）设置任何他们需要的事件处理函数。</p>
<h2 id="process-nexttick-vs-setimmediate">process.nextTick() vs setImmediate()</h2>
<p>就用户而言，我们有两个类似的呼叫，但它们的名称令人困惑。</p>
<ul>
<li><code>process.nextTick()</code> 在当前阶段<strong>立即</strong>被触发</li>
<li><code>setImmediate()</code> 在事件循环的下一趟迭代或称之为 <code>tick</code> 触发</li>
</ul>
<blockquote>
<p><em>注：这里的一个一趟迭代指的是一个阶段队列的遍历执行</em></p>
</blockquote>
<p>实质上，应该交换名称。 <code>process.nextTick()</code> 比 <code>setImmediate()</code> 更 ‘immediate’，但这是过去已经定好的，不太可能改变。做出这个交换会破坏 <code>npm</code> 上的大部分包。每天都会产生更多新模块，这意味着我们多等待一天，做出交换会带来更多的潜在的破损。尽管这两个的名称造成了困惑，但它们的名字不会改变。</p>
<p>我们推荐开发者在所有情景下都使用 <code>setImmediate()</code>，因为它更容易被理解（并且它有着更广泛的环境兼容性，例如在浏览器的 JS 里）。</p>
<h2 id="为什么要使用-process-nexttick">为什么要使用 process.nextTick()</h2>
<p>两个理由：</p>
<ol>
<li>
<p>允许用户处理错误（将错误通过 <code>process.nextTick(fn, error)</code> 传递给 <code>fn</code>），清除任何不需要的资源（例如在 <code>nextTick</code> 手动解除同步代码中的内存引用），或者在事件循环继续之前再次尝试请求</p>
</li>
<li>
<p>有时需要允许回调在调用栈展开之后但在事件循环继续之前运行。</p>
</li>
</ol>
<p>一个例子是为了匹配用户的期望：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> server = net.createServer();</div><div class="line">server.on(<span class="string">'connection'</span>, (conn) =&gt; &#123; &#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>);</div><div class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123; &#125;);</div></pre></td></tr></table></figure>
<p>假设 <code>listen()</code> 在事件循环开始时运行，但是 <code>listening</code> 回调用 <code>setImmediate()</code> 包裹。除非传递 <code>hostname</code>，否则将立即绑定到端口（并立即触发 <code>listening</code> 事件）。要想事件循环继续，它必须先达到轮询阶段，这意味着存在一个可能的空窗期：在 <code>listening</code> 事件的代码（用 <code>setImmediate()</code> 包裹的）执行前就收到了一个连接，也就是相当于先于 <code>listening</code> 触发了 <code>connection</code> 事件。</p>
<blockquote>
<p><em>注：使用 <code>process.nextTick()</code> 可以规避这个问题，保证 <code>listening</code> 的回调先触发</em></p>
</blockquote>
<p>另一个例子是运行一个函数构造函数，比如继承自 <code>EventEmitter</code>，它想在构造函数中调用一个事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  EventEmitter.call(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</div><div class="line">&#125;</div><div class="line">util.inherits(MyEmitter, EventEmitter);</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>您无法立即从构造函数中真正触发事件，因为脚本还没有运行到用户为该事件分配回调的位置。因此，在构造函数本身中，您可以使用 <code>process.nextTick()</code> 来设置回调以在构造函数完成后发出事件，从而提供预期的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  EventEmitter.call(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="comment">// use nextTick to emit the event once a handler is assigned</span></div><div class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">util.inherits(MyEmitter, EventEmitter);</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Node </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node </tag>
            
            <tag> 异步 </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用白鹭引擎开发微信小游戏的一些流程改进]]></title>
      <url>/2018/10/24/wx-minigame-dev-using-egret/</url>
      <content type="html"><![CDATA[<p>微信小游戏是运行在微信环境下的类 HTML5 游戏，可以使用诸如 Laya, cocos2d, egret 等 HTML5 游戏引擎来进行开发。笔者最近使用 egret engine（白鹭引擎）开发了两款微信小游戏，一款单机，另一款支持联机对战，下文是在这两个项目中使用 egret 总结出的个人最佳实践。</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/ctg.jpg" alt="插糖果" title="插糖果">
<img src="/2018/10/24/wx-minigame-dev-using-egret/tty.jpg" alt="来追我鸭" title="来追我鸭">
<a id="more"></a>
<h2 id="原理">原理</h2>
<p>将 egret 发布为微信小游戏后会发现导出的目录 <code>xxx-wxgame</code> 下有以下文件和目录：</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/output-dir.jpg" alt="导出目录" title="导出目录">
<p>图中标注的部分就是 egret 为生成微信小游戏做的工作。其中 <code>egret.wxgame.js</code>, <code>weapp-adapter.js</code> 和 <code>library</code> 是 DOM/BOM API 及白鹭 API 向微信小游戏适配的代码，使得我们面向 egret 编写的特异代码能无缝迁移到微信小游戏环境下运行，<code>openDataContext</code> 是开放数据域代码目录。</p>
<h2 id="问题1：platform-ts-与-platform-js">问题1：Platform.ts 与 platform.js</h2>
<p>按照 egret 给的工作流，源码里的 <code>Platform.ts</code> 只是用于 egret 自带的调试工具调试时使用，使用假数据模拟微信平台接口的返回值，编译之后生成的是对应的 <code>platform.js</code>。</p>
<p>这里存在两个问题：</p>
<ol>
<li><code>Platform.ts</code> 不会（也不应该）直接同步编译到 <code>platform.js</code> 中，所以这部分代码得编写/修改两次</li>
<li><code>platform.js</code> 无法从 <code>Platform.ts</code> 直接编译得到，所以项目源码与导出的微信小游戏代码都得加入代码库进行管理</li>
</ol>
<p>我的解决方案：基本抛弃白鹭工作流里的 <code>Platform.ts</code>，实现自己 <code>Platfrom</code> 处理模式。</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/platform.jpg" alt="platform改良机制后目录" title="platform改良机制后目录">
<p>在 <code>src</code> 源码里实现 <code>Platform</code> 机制，最终平台代码直接打包到我们的输出的 <code>main.min.js</code> 中，对于 <code>wx</code> 对象不存在无法通过编译的问题使用 <code>src/global.d.ts</code> 编写类型声明来解决。</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/platform-code.jpg" alt="具体代码方案" title="具体代码方案">
<p>这样平台代码只需要在一处进行编写，而不需要向之前一样：在 <code>wing</code>（egret 提供的基于 VS Code 改造的编辑器）编写/修改完平台代码后，还需要在微信开发者工具内编写/改写 <code>platform.js</code>。</p>
<p>其实包括下面的问题 2 都是围绕着一个核心思路来改造工作流：一处编辑，无需切换到微信开发者工具去修改代码。</p>
<h2 id="问题2：开放数据域">问题2：开放数据域</h2>
<p>egret 在导出微信小游戏时，会生成一个比较简单的 <code>openDataContext</code> 目录到输出目录，最终开放数据域代码的编写需要切换到微信开发者工具去编写。</p>
<p>所以对于开放数据域，也会存在与 <code>Platform</code> 相类似的问题1，解决思路是利用 egret 编译任务定制功能。</p>
<p>首先我们直接在项目下自己新增 <code>openDataContext</code> 目录，里面放置的全部是开放数据域相关的代码。</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/openDataContext.jpg" alt="openDataContext改进后目录" title="openDataContext改进后目录">
<p>然后我们修改 <code>scripts/wxgame/wxgame.ts</code> 中的任务代码，实现我们的需求：<strong>最终直接使用源码目录的 <code>openDataContext</code>，而不使用白鹭帮忙生成的 <code>openDataContext</code></strong></p>
<p>思路是：删除 egret 生成的 <code>openDataContext</code>（可选），递归复制源码目录的 <code>openDataContext</code> 到微信小游戏导出目录下，（可选）也可以先进行代码打包、压缩再复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cp <span class="keyword">from</span> <span class="string">'child_process'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFileSync</span>(<span class="params">source, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> targetFile = target</div><div class="line">    <span class="keyword">if</span> (fs.existsSync(target)) &#123;</div><div class="line">        <span class="keyword">if</span> (fs.lstatSync(target).isDirectory()) &#123;</div><div class="line">            targetFile = path.join(target, path.basename(source))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    fs.writeFileSync(targetFile, fs.readFileSync(source))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFolderRecursiveSync</span>(<span class="params">source, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> files = []</div><div class="line"></div><div class="line">    <span class="keyword">let</span> targetFolder = path.join(target, path.basename(source));</div><div class="line">    <span class="keyword">if</span> (!fs.existsSync(targetFolder)) &#123;</div><div class="line">        fs.mkdirSync(targetFolder)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fs.lstatSync(source).isDirectory()) &#123;</div><div class="line">        files = fs.readdirSync(source)</div><div class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> curSource = path.join(source, file)</div><div class="line">            <span class="keyword">if</span> (fs.lstatSync(curSource).isDirectory()) &#123;</div><div class="line">                copyFolderRecursiveSync(curSource, targetFolder)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                copyFileSync(curSource, targetFolder)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFolderRecursive</span>(<span class="params">folder: string</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> files = [];</div><div class="line">    <span class="keyword">if</span> (fs.existsSync(folder)) &#123;</div><div class="line">        files = fs.readdirSync(folder)</div><div class="line">        files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file, index</span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> curPath = folder + <span class="string">"/"</span> + file</div><div class="line">            <span class="keyword">if</span> (fs.lstatSync(curPath).isDirectory()) &#123;</div><div class="line">                deleteFolderRecursive(curPath);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                fs.unlinkSync(curPath);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        fs.rmdirSync(folder);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WxgamePlugin</span> <span class="title">implements</span> <span class="title">plugins</span>.<span class="title">Command</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">async</span> onFile(file: plugins.File) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">async</span> onFinish(pluginContext: plugins.CommandContext) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        <span class="comment">// 其他定制任务</span></div><div class="line">        copyFileSync(<span class="string">`<span class="subst">$&#123;pluginContext.projectRoot&#125;</span>/platform.js`</span>, <span class="string">`<span class="subst">$&#123;pluginContext.outputDir&#125;</span>/platform.js`</span>)</div><div class="line"></div><div class="line">        <span class="comment">// 开放数据域</span></div><div class="line">        <span class="keyword">const</span> openDataContextTargetPath = path.join(pluginContext.outputDir, <span class="string">'openDataContext'</span>)</div><div class="line">        <span class="keyword">const</span> openDataContextSrcPath = path.join(pluginContext.projectRoot, <span class="string">'openDataContext'</span>)</div><div class="line"></div><div class="line">        <span class="comment">// 删除输出目录的 `openDataContext`，再复制 `openDataContext` 目录到输出目录</span></div><div class="line">        <span class="comment">// deleteFolderRecursive(openDataContextTargetPath)</span></div><div class="line">        <span class="comment">// copyFolderRecursiveSync(openDataContextSrcPath, pluginContext.outputDir)</span></div><div class="line"></div><div class="line">        <span class="comment">// 打包压缩输出</span></div><div class="line">        cp.exec(<span class="string">`webpack --entry <span class="subst">$&#123;openDataContextSrcPath&#125;</span>/index.js -o <span class="subst">$&#123;openDataContextTargetPath&#125;</span>/index.js`</span>)</div><div class="line"></div><div class="line">        <span class="comment">// 可以自己再进行特异化订制</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们每次点击发布或执行 <code>egret publish</code> 时便会同步源码目录的 <code>openDataContext</code> 到输出目录，也达到了我们只需要在 <code>wing</code> 这一处编写所有代码的需求。</p>
<h2 id="问题3：代码的压缩与二次混淆">问题3：代码的压缩与二次混淆</h2>
<p>在未对白鹭工作流作任何修改的情况下，白鹭输出时会进行编译、打包和简单的压缩混淆，但是混淆的还是不够，且开放数据域的代码无法被打包，尤其是当两款游戏用到了一些公用组件时，直接用白鹭输出的代码包去微信那边提审有可能会因为代码包查重通不过而被拒。</p>
<p>对于开放数据域来说，代码的压缩已经在问题2中顺便给解决了。</p>
<p>而游戏逻辑代码输出的文件是 <code>main.min.js</code>，这样混淆的方案就随你选择了，你可以使用 <code>uglifyjs</code> 来对输出的 <code>main.min.js</code> 来进行压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 替换 $&#123;...&#125; 为你对应源码目录和发布目录</span></div><div class="line">uglifyjs -o <span class="variable">$&#123;pluginContext.outputDir&#125;</span>/js/main.min.js <span class="variable">$&#123;pluginContext.outputDir&#125;</span>/js/main.min.js --toplevel -c</div></pre></td></tr></table></figure>
<h2 id="其他小问题">其他小问题</h2>
<h3 id="微信开发者工具经常黑屏">微信开发者工具经常黑屏</h3>
<p>解决方案：关掉微信开发者工具的文件变动时自动编译可以缓解</p>
<h3 id="第三方模块">第三方模块</h3>
<p>笔者是在源码目录新建一个 <code>3rd</code> 的目录放置第三方模块</p>
<img src="/2018/10/24/wx-minigame-dev-using-egret/3rd.jpg" alt="第三方模块" title="第三方模块">
<br>
<br>
下一篇笔者将继续分享游戏代码层面遇到的问题和解决方案。
]]></content>
      
        <categories>
            
            <category> 游戏 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 微信开发 </tag>
            
            <tag> 微信小游戏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web 排版中的 vertical-align]]></title>
      <url>/2018/05/05/vertical-align-and-web-typography/</url>
      <content type="html"><![CDATA[<p>如果你对 Web 排版中的 <code>vertical-align</code> 一直捉摸不透，那么这篇文章可能便是你一直想要寻找的资料了。</p>
<a id="more"></a>
<h2 id="基本概念">基本概念</h2>
<p><img src="http://static.zybuluo.com/yangfch3/mkpa9vcl1km2hv4uvkygjj3m/image_1bafbonhdkmunvt10s2a232b61g.png" alt="image_1bafbonhdkmunvt10s2a232b61g.png-23.9kB"></p>
<center>浏览器中的大小写字母、中文混排</center>
<h3 id="基线与行高">基线与行高</h3>
<p>基线：<code>baseline</code><br>
行高：<code>line-height</code></p>
<p>为了表述的方便，我们首先回到小时候看看曾经使用过的拼音线格：<br>
<img src="http://static.zybuluo.com/yangfch3/cqadi1c1y1oko5yjufygku54/image_1bafau0ji1nb01oea1h1012icqks13.png" alt="image_1bafau0ji1nb01oea1h1012icqks13.png-329.5kB"></p>
<p>从上图我们基本就能明确基线与行高两个概念了：</p>
<ol>
<li>基线：多数字母排列的基准线</li>
<li>段落中连续行的基线间的垂直距离称为行高（Line Height）或行距（Leading）</li>
</ol>
<p>思考与扩展：当我们没有指定确定的行高时，浏览器给予行内元素的行高是多少？</p>
<blockquote>
<ol>
<li>没有确定行高时，其 <code>line-height</code> 的值默认为 <code>normal</code></li>
<li>对于没有使用行内元素包裹的文字（如：<code>&lt;div&gt;abc&lt;/div&gt;</code>），浏览器在底层的处理相当于为这些文字包上一层行内元素（相当于 <code>&lt;div&gt;&lt;span&gt;abc&lt;/span&gt;&lt;/div&gt;</code>）</li>
<li>浏览器为行内元素设置的默认行高 <code>normal</code> 取值随着字体大小、字体类型的变化而变化</li>
</ol>
</blockquote>
<h3 id="x-height">x-height</h3>
<p><code>x</code> 这个字母在排版中具有不俗的地位，下面来看看如何个不俗法。</p>
<p><img src="http://static.zybuluo.com/yangfch3/u6xpmwsuni6y75kkkteixe7z/image_1bafc7uglqo61ote1j521flct511t.png" alt="image_1bafc7uglqo61ote1j521flct511t.png-30kB"></p>
<p><code>x-height</code> 指的便是小写字母 <code>x</code> 字母的实际物理高度。为什么会选择 <code>x</code> 呢，可能是因为其良好的对称性、上下边缘平整才成为这个天选之子吧。</p>
<p>这里为什么会莫名其妙地说起 <code>x-height</code> 这个概念呢？在前端有什么用呢？</p>
<p>请继续往下阅读吧，可以预告一下：<code>x-height</code> 与我们今天的主角 <code>vertical-align</code> 有联系。</p>
<h3 id="小写字母的-下沉">小写字母的“下沉”</h3>
<p>首先上一段代码：<br>
<img src="http://static.zybuluo.com/yangfch3/ebqehj53esh0opdhgb873q8o/image_1bafdkra71u6dotkkub17l8cpt2a.png" alt="image_1bafdkra71u6dotkkub17l8cpt2a.png-33.3kB"></p>
<p>看看实际效果：<br>
<img src="http://static.zybuluo.com/yangfch3/c80337hz0ibfj8qfouqfkthw/image_1bafdn8011bb71ogq1eaecdo1o0a34.png" alt="image_1bafdn8011bb71ogq1eaecdo1o0a34.png-31.3kB"></p>
<p>然后我们来<strong>局部放大小写字母</strong>部分，通过对角线找到 <strong>行盒</strong> 的垂直中线（图中竖直方向中间的红线），与 <code>x</code> 的中心位置进行对比便能发现：<strong>行盒垂直方向的中线高于小写的 <code>x</code> 的中心点</strong>。<br>
<img src="http://static.zybuluo.com/yangfch3/aj7g136ex9a7sizpm210w7p9/image_1bafdmmadvrc19dqur71927q732n.png" alt="image_1bafdmmadvrc19dqur71927q732n.png-142.9kB"></p>
<p>这个情况，可以形象地记忆为小写字母的 <strong>下沉</strong>。</p>
<h3 id="文本排版参考线">文本排版参考线</h3>
<p><img src="http://static.zybuluo.com/yangfch3/wxwyxkakjmqqr1luakis57s1/image_1bafetjs27d11udtiu94c11o279.png" alt="image_1bafetjs27d11udtiu94c11o279.png-30.4kB"></p>
<center>一图看懂</center>
<h2 id="进阶">进阶</h2>
<h3 id="关于网页中的图片">关于网页中的图片</h3>
<p>图片做为网页中特殊的行内元素，但是图片又不是文字，为了更好阐述下文图文混排的知识，根据经验我做出如下阐述：</p>
<ol>
<li>图片的 <code>baseline</code>、<code>bottom</code> 可以认为位置相同，都是图片的底边位置</li>
<li>图片的 <code>top</code> 可以认为是图片的上边位置</li>
<li>图片不是文本，所以我们可以认为图片没有所谓的 <code>text-top</code>、<code>text-bottom</code>、<code>sub</code>、<code>sup</code> 概念</li>
</ol>
<h3 id="莫名出现的空白">莫名出现的空白</h3>
<p>源码：<br>
<img src="http://static.zybuluo.com/yangfch3/y34n1nb1b6gpb9yt3b4b0ui3/image_1bafhcotm12m338av3o15cj1nul13.png" alt="image_1bafhcotm12m338av3o15cj1nul13.png-25.9kB"></p>
<p>效果：<br>
<img src="http://static.zybuluo.com/yangfch3/p5186vgoyogkpkecn921ugll/image_1bafhd8nsmj31vj71mcdjkjc831g.png" alt="image_1bafhd8nsmj31vj71mcdjkjc831g.png-12.6kB"></p>
<p>嗯，出现了莫名的空白，其实这也是我们经常遇到的问题，这个空白出现的原因是什么呢？</p>
<blockquote>
<p>想通这个问题很简单，你只要先假设图片的相邻处有文字，思考图片文字的对齐方案，单后再把文字去掉就能想通了。</p>
</blockquote>
<p>值得注意的是这个空白只有在标准模式下渲染才会出现，在接近标准模式（HTML 4.0）、怪异模式（HTML 3.0、IE5-）下渲染不会有。</p>
<p>那么我们如何消除这个空白呢？</p>
<ol>
<li>外层块盒设置 <code>font-size: 0</code></li>
<li>外层块盒 <code>line-height</code> 设置得足够小（在 Chrome 下设置要小于 12px）</li>
</ol>
<h3 id="合成行盒的各排版参考线">合成行盒的各排版参考线</h3>
<p>合成行盒就是类似下面这种情况，简单点说便是图片文字混排的情况</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>XYZ<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
<p>经过测试，我们能得到以下结果：合成行盒各排版参考线情况<br>
<img src="http://static.zybuluo.com/yangfch3/n4d9u34113xwte420m2wasc4/image_1bafi8hrat54ob91c9l1fch14br9.png" alt="image_1bafi8hrat54ob91c9l1fch14br9.png-110.1kB"></p>
<blockquote>
<p>修正：图中的 <code>x-height</code> 应为 <strong>半<code>x-height</code></strong></p>
</blockquote>
<p>总结的几个原则：</p>
<ol>
<li>大部分排版参考线只由这里面字体最小的那部分确定</li>
<li>大图能决定合成行盒的 <code>top</code></li>
</ol>
<h2 id="vertical-align-详解">vertical-align 详解</h2>
<p>请认认真真地咀嚼下面的结论，遇到具体情境时再结合上文的手段进行分析，你就能得出正确的对齐手段。</p>
<blockquote>
<p><strong>baseline</strong>：把当前盒的基线与父盒的基线对齐。如果该盒没有基线（如图片），就将底部外边距的边界和父盒的基线对齐<br>
<strong>sub</strong>：把当前盒的基线降低到合适的位置作为父盒的下标（该值不影响该元素文本的字体大小）<br>
<strong>super</strong>：把当前盒的基线提升到合适的位置作为父盒的上标（该值不影响该元素文本的字体大小）<br>
<strong>text-top</strong>：把当前盒的 top 和**父盒的内容区的 top（即父盒的 text-top）<strong>对齐<br>
<strong>text-bottom</strong>：把当前盒的 bottom 和</strong>父盒的内容区的 bottom （即父盒的 text-bottom）<strong>对齐<br>
<strong>middle</strong>：把当前盒的垂直中心和父盒的基线加上父盒的半 x-height 对齐<br>
<strong>top</strong>：把当前盒的 top 与</strong>行盒的 top（父盒下合成行盒的 top）<strong>对齐<br>
<strong>bottom</strong>：把当前盒的 bottom 与</strong>行盒的 bottom（父盒下合成行盒的 bottom）**对齐<br>
<strong><code>&lt;percentage&gt;</code></strong>：把当前盒提升（正值）或者降低（负值）这个距离，百分比是相对元素自身 line-height 计算。当值为 0% 时等同于 baseline。<br>
<strong><code>&lt;length&gt;</code></strong>：把当前盒提升（正值）或者降低（负值）这个距离。当值为 0 时等同于 baseline。（CSS2）</p>
</blockquote>
<hr>
<h2 id="附录">附录</h2>
<p>一个用于测试的简单的、经典的页面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cmn-Hans"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1,user-scalable=no,width=device-width,shrink-to-fit=no"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>vertical-align demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">几个可以尝试的扩展练习：</span></div><div class="line"><span class="comment">1. 尝试先将图片确定为某个 vertical-align 值，再来变更两个 span 的 vertical-align 值，查看效果，分析原理</span></div><div class="line"><span class="comment">2. 尝试随意地为两个 span 和一个 img 分配 vertical-align 值，查看效果，分析原理</span></div><div class="line"><span class="comment">3. 如果 span 内文字多行会怎么样？</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:#E5EDFF;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff;font-size: 40px;"</span>&gt;</span>ZXXXxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://dummyimage.com/300x200/000/fff"</span> <span class="attr">style</span>=<span class="string">"width: 300px; height: 200px;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 23px;"</span>&gt;</span>zxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">可以尝试的扩展练习：为最外层 div 内的各个元素随机设置 vertical-align，查看效果，分析原理</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: #ccc"</span>&gt;</span>zxxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:#E5EDFF; display: inline-block"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 40px;"</span>&gt;</span>ZXXXxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://dummyimage.com/300x200/000/fff"</span> <span class="attr">style</span>=<span class="string">"width: 300px; height: 200px;"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color:#fff; font-size: 23px;"</span>&gt;</span>zxxf<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> 排版 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pm2 与 log4js 混用指南]]></title>
      <url>/2018/04/22/log4js-with-pm2/</url>
      <content type="html"><![CDATA[<p>我相信你是在使用 <code>pm2</code> 和 <code>log4js</code> 中踩到了坑才会搜素到这篇文章，我便假定你已经对二者都有了基本的了解，遂不再赘述二者的介绍。</p>
<p><code>pm2</code> 在使用 <code>cluster</code> 模式部署应用时，服务都通过 <code>worker</code> 进程提供，<code>pm2</code> 做为 <code>master</code> 进行监控管理。</p>
<img src="/2018/04/22/log4js-with-pm2/pm2.png" alt="pm2" title="pm2">
<p>由于存在多个 <code>worker</code> 进程，那么我们在使用 <code>log4js</code> 进行日志记录时会有下列疑问：</p>
<ol>
<li>多个 <code>worker</code> 进程能否正常写入同一个日志文件</li>
<li>要实现 1，<code>pm2</code> 需要作何处理，<code>log4js</code> 需要作何处理</li>
</ol>
<a id="more"></a>
<h2 id="退而求其次：多进程分日志？">退而求其次：多进程分日志？</h2>
<p>首先来尝试“逃避”上面的两个问题。</p>
<p>要“逃避”上面疑问最简易的方案就是：每个进程写入自己的日志文件（例如：<code>robotService-worker&lt;id&gt;.log</code>）。只需要对 <code>log4js</code> 做一下简易的设置即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    disableClustering: <span class="literal">true</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方案带来了<strong>日志分散、查阅与处理不方便</strong>的问题，一般情况下不采用。此方案较为经典的使用场景是 <code>pomelo</code> 的多进程游戏日志采集（但 <code>pomelo</code> 不是使用 <code>cluster</code> 来搭建集群）。</p>
<h2 id="log4js-与-pm2-相关源码">log4js 与 pm2 相关源码</h2>
<p><code>lib/log4js</code> 下的 <code>getLogger</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Get a logger instance.</span></div><div class="line"><span class="comment"> * <span class="doctag">@static</span></span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> loggerCategoryName</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;Logger&#125; instance of logger for the category</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLogger</span><span class="params">(category)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) &#123;</div><div class="line">    configure(process.env.LOG4JS_CONFIG || defaultConfig);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> cat = category || <span class="string">'default'</span>;</div><div class="line">  debug(`creating logger <span class="keyword">as</span> $&#123;isMaster() ? <span class="string">'master'</span> : <span class="string">'worker'</span>&#125;`);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Logger((isMaster() ? sendLogEventToAppender : workerDispatch), cat);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明 <code>log4js</code> 在 <code>cluster</code> 集群模式下与单进程模式（<strong><code>isMaster</code> 方法来区分</strong>）下获取 <code>logger</code> 的存在差异。我们关注到 <code>log4js</code> 在 <code>worker</code> 进程下执行的是 <strong><code>workerDispatch</code></strong>。</p>
<p>下面是 <code>isMaster</code> 的源码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPM2Master</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.pm2 &amp;&amp; process.env[<span class="built_in">config</span>.pm2InstanceVar] === <span class="string">'0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMaster</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">config</span>.disableClustering || cluster.isMaster || isPM2Master();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明 <code>log4js</code> 对普通的 <code>cluster</code> 模式和 <code>pm2</code> 的 <code>cluster</code> 模式又做了区分。我们留意到有两个可配置项：<code>pm2</code> <code>pm2InstanceVar</code>，可以查看 <code>log4js</code> 的<a href="https://log4js-node.github.io/log4js-node/api.html" target="_blank" rel="external">文档</a>了解这两个配置项。</p>
<p>继续看 <code>workerDispatch</code> 的源码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">function</span> <span class="selector-tag">workerDispatch</span>(logEvent) &#123;</div><div class="line">  <span class="selector-tag">debug</span>(<span class="built_in">`sending message to master from worker $&#123;process.pid&#125;`</span>);</div><div class="line">  <span class="selector-tag">process</span><span class="selector-class">.send</span>(&#123; <span class="attribute">topic</span>: <span class="string">'log4js:message'</span>, <span class="attribute">data</span>: serialise(logEvent) &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以得知：<strong>在 pm2 cluster 模式下，<code>log4js</code> 不在 worker 进程直接记录日志，而是将需要记录日志的消息发送给 <code>master</code> 进程。</strong></p>
<p><code>log4js</code> 既然有发送消息的代码，那肯定有接收消息的代码，下面是接收消息的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">configurationFileOrObject</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> configObject = configurationFileOrObject;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> configObject === <span class="string">'string'</span>) &#123;</div><div class="line">    configObject = loadConfigurationFile(configurationFileOrObject);</div><div class="line">  &#125;</div><div class="line">  debug(<span class="string">`Configuration is <span class="subst">$&#123;configObject&#125;</span>`</span>);</div><div class="line">  config = <span class="keyword">new</span> Configuration(configObject);</div><div class="line">  <span class="built_in">module</span>.exports.levels = config.levels;</div><div class="line">  <span class="keyword">const</span> loggerModule = logger(config.levels, levelForCategory, setLevelForCategory);</div><div class="line">  Logger = loggerModule.Logger;</div><div class="line">  LoggingEvent = loggerModule.LoggingEvent;</div><div class="line">  <span class="built_in">module</span>.exports.connectLogger = connectModule(config.levels).connectLogger;</div><div class="line"></div><div class="line">  <span class="comment">// just in case configure is called after shutdown</span></div><div class="line">  process.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  <span class="keyword">if</span> (cluster) &#123;</div><div class="line">    cluster.removeListener(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (config.disableClustering) &#123;</div><div class="line">    debug(<span class="string">'Not listening for cluster messages, because clustering disabled.'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPM2Master()) &#123;</div><div class="line">    <span class="comment">// PM2 cluster support</span></div><div class="line">    <span class="comment">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></div><div class="line">    <span class="comment">// we only want one of the app instances to write logs</span></div><div class="line">    debug(<span class="string">'listening for PM2 broadcast messages'</span>);</div><div class="line">    process.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isMaster) &#123;</div><div class="line">    debug(<span class="string">'listening for cluster messages'</span>);</div><div class="line">    cluster.on(<span class="string">'message'</span>, receiver);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    debug(<span class="string">'not listening for messages, because we are not a master process'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  enabled = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> log4js;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// in a multi-process node environment, worker loggers will use</span></div><div class="line"><span class="comment">// process.send</span></div><div class="line"><span class="keyword">const</span> receiver = <span class="function">(<span class="params">worker, message</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// prior to node v6, the worker parameter was not passed (args were message, handle)</span></div><div class="line">  debug(<span class="string">'cluster message received from worker '</span>, worker, <span class="string">': '</span>, message);</div><div class="line">  <span class="keyword">if</span> (worker.topic &amp;&amp; worker.data) &#123;</div><div class="line">    message = worker;</div><div class="line">    worker = <span class="literal">undefined</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (message &amp;&amp; message.topic &amp;&amp; message.topic === <span class="string">'log4js:message'</span>) &#123;</div><div class="line">    debug(<span class="string">'received message: '</span>, message.data);</div><div class="line">    sendLogEventToAppender(deserialise(message.data));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendLogEventToAppender</span>(<span class="params">logEvent</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span>;</div><div class="line">  debug(<span class="string">'Received log event '</span>, logEvent);</div><div class="line">  <span class="keyword">const</span> appenders = appendersForCategory(logEvent.categoryName);</div><div class="line">  appenders.forEach(<span class="function">(<span class="params">appender</span>) =&gt;</span> &#123;</div><div class="line">    appender(logEvent);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是日志是由 <code>worker</code> --①–&gt; pm2 <code>master</code> --②–&gt; <code>worker</code> 进行的传递，其思路就是日志只由一个 <code>worker</code> 去记录。<strong>而 ② 处的转发以及选择哪一个 <code>worker</code> 去接收就需要 <code>pm2-intercom</code> 这个 pm2 的 module 来处理了。</strong></p>
<h2 id="结论">结论</h2>
<p>要解决前言中的两个疑问，可以这样做：</p>
<ol>
<li><code>pm2</code> 安装 <code>pm2 install pm2-intercom</code></li>
<li><code>log4js</code> 启用以下配置： <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    pm2: <span class="literal">true</span></div><div class="line">    <span class="string">//</span> <span class="string">...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="结束了？">结束了？</h2>
<p>没有。</p>
<p>在上面的代码中我们发现 <code>isPM2Master</code> 的判断中有这样一句代码：<code>process.env[config.pm2InstanceVar] === '0'</code>。</p>
<p>我们查阅 <code>pm2</code> 的<a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="external">文档</a>发现，<code>pm2</code> 的进程都是有编号的，默认使用 <code>NODE_APP_INSTANCE</code> 环境变量（<strong>可以自己配置指定</strong>）上标识是 <code>master</code>（=== ‘0’） 还是 <code>worker</code>。<code>log4js</code> 也是根据这个特征来实现 <code>isPM2Master</code> 检测。</p>
<p>但是 <code>pm2</code> 不一定使用默认的 <code>NODE_APP_INSTANCE</code> 环境变量来编号，可能会变化——可能是用户自己定义了其他名称（例如<code>node-config</code> 将这个环境变量字段占用了，<code>pm2</code> 只能改用其他的），所以当 <code>pm2</code> 改变了字段名时，<code>log4js</code> 要做相应的配置：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attribute">pm2InstanceVar</span>: <span class="string">'INSTANCE_ID'</span>; <span class="comment">// 默认 NODE_APP_INSTANCE，与 pm2 的配置保持一致即可</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附赠：单机多-pm2-实例">附赠：单机多 pm2 实例</h2>
<p>一台机器上可以部署多个 pm2 实例，这在我们需要再一台机器上部署多个不同的服务时可以用到，例如我们可能同时在一台机器上部署 <code>web-server</code> 和 <code>api-server</code>（因为机器紧张等原因）。</p>
<p>当我们第一次调用 <code>pm2</code> 时，我们会发现 <code>$HOME/.pm2</code> 目录被创建，里面存储着**（该）<code>pm2</code> 实例**的运行信息和日志输出。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm2 start app<span class="selector-class">.js</span> -<span class="selector-tag">i</span> <span class="number">3</span> --name=web-server</div></pre></td></tr></table></figure>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># pwd</span></div><div class="line">/home/admin/.pm2</div><div class="line"></div><div class="line">[admin@sypt_web-test_10.0.3.188 .pm2]<span class="comment"># ls -a -l</span></div><div class="line">total 72</div><div class="line">drwxrwxr-x  <span class="number"> 5 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:19 .</div><div class="line">drwx------.<span class="number"> 12 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 11 </span>09:53 ..</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 29 </span>17:20 logs</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin  <span class="number"> 127 </span>Mar<span class="number"> 28 </span>20:58 module_conf.json</div><div class="line">drwxrwxr-x  <span class="number"> 3 </span>admin admin <span class="number"> 4096 </span>Mar<span class="number"> 28 </span>20:55 modules</div><div class="line">drwxrwxr-x  <span class="number"> 2 </span>admin admin <span class="number"> 4096 </span>Apr<span class="number"> 16 </span>15:24 pids</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin<span class="number"> 34054 </span>Apr<span class="number"> 16 </span>15:24 pm2.log</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin    <span class="number"> 4 </span>Mar<span class="number"> 29 </span>17:19 pm2.pid</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 pub.sock</div><div class="line">srwxrwxr-x  <span class="number"> 1 </span>admin admin    <span class="number"> 0 </span>Mar<span class="number"> 29 </span>17:19 rpc.sock</div><div class="line">-rw-rw-r--  <span class="number"> 1 </span>admin admin   <span class="number"> 13 </span>Mar<span class="number"> 24 </span>15:12 touch</div></pre></td></tr></table></figure>
<p>所以要创建多个 <code>pm2</code> 实例就需要每个实例使用不同的目录来存储运行信息。<code>pm2</code> 使用 <code>PM2_HOME</code> 环境变量来识别存储运行信息的目录：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 start app.js -i --name=web-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 web-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 list</div></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 start app.js -i --name=api-server</div><div class="line"></div><div class="line"><span class="comment"># 所有和 api-server 集群相关的 pm2 命令都加上 PM2_HOME</span></div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 list</div></pre></td></tr></table></figure>
<p>为特定的 <code>pm2</code> 实例安装模块：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/web-server/'</span> pm2 install pm2-intercom</div><div class="line"><span class="attr">PM2_HOME</span>=<span class="string">'/path/to/pm2/api-server/'</span> pm2 install pm2-intercom</div></pre></td></tr></table></figure>
<p>Tip：pm2 模块的安装可以不使用线上下载安装的方式（例如不方便执行 <code>pm2 install</code> 操作时），你只需要将模块放到 <code>modules</code> 目录下，然后修改 <code>module_conf.json</code> 注册模块即可。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dump.pm2</div><div class="line">├── dump<span class="selector-class">.pm2</span><span class="selector-class">.bak</span></div><div class="line">├── logs</div><div class="line">├── module_conf.json</div><div class="line">├── modules</div><div class="line">│   └── pm2-intercom</div><div class="line">│       ├── etc</div><div class="line">│       ├── node_modules</div><div class="line">│       └── package-lock.json</div><div class="line">├── pids</div><div class="line">├── pm2.log</div><div class="line">├── pm2.pid</div><div class="line">├── pub.sock</div><div class="line">├── rpc.sock</div><div class="line">└── touch</div></pre></td></tr></table></figure>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// module_conf.json</div><div class="line">&#123;</div><div class="line">    <span class="string">"pm2-intercom"</span>: &#123;</div><div class="line">        <span class="string">"default-strategy"</span>: <span class="string">"broadcast"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"module-db-v2"</span>: &#123;</div><div class="line">        <span class="string">"pm2-intercom"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Node </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pm2 </tag>
            
            <tag> log4js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[细说 S.O.L.I.D]]></title>
      <url>/2017/11/05/SOLID/</url>
      <content type="html"><![CDATA[<p><code>S.O.L.I.D</code> 五原则（以下简称五原则）：</p>
<ul>
<li><strong>单一功能原则</strong></li>
<li><strong>开放封闭原则</strong></li>
<li><strong>里氏替换原则</strong></li>
<li><strong>接口隔离原则</strong></li>
<li><strong>依赖反转原则</strong>。</li>
</ul>
<a id="more"></a>
<p><img src="http://static.zybuluo.com/yangfch3/1vhmouqgjzw983ftbiuqlyoi/image_1bqcv642t1bj01a041g0udcae4l9.png" alt="image_1bqcv642t1bj01a041g0udcae4l9.png-40kB"></p>
<p><code>S.O.L.I.D</code> 做为面向对象编程和面向对象设计的五个基本原则，在面向对象的软件开发史上做为“最佳实践”指导着人们开发出代码清晰可读、容易维护和扩展的系统。</p>
<p><code>S.O.L.I.D</code> 由 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="external">Robert C. Martin (Uncle Bob)</a> 总结提出。</p>
<h2 id="code-rot">Code rot</h2>
<p><img src="http://static.zybuluo.com/yangfch3/1dl9j3ppshabajdnq3ujua8k/image_1bu3f0pemstn1htf3bl1v9l157719.png" alt="image_1bu3f0pemstn1htf3bl1v9l157719.png-257.2kB"><br>
什么样的代码是烂代码呢？如何识别将来可能会演变成烂代码的代码呢？</p>
<ol>
<li><strong>刚性</strong>：小改变导致整个系统重写</li>
<li><strong>脆弱性</strong>：一个模块的改变导致其他不相关模块行为变得不当，想象一下一台汽车因为电台的变动影响到了车窗的使用</li>
<li><strong>不可迁移性</strong>：一个模块的内部组件不能提取到新环境使用，原因是组件间的耦合与强依赖。规避策略是将中央抽象与 low-level 细节分离</li>
<li><strong>粘性</strong>：当构建和测试难以进行，需要花费大量的时间执行（例如：在充值处做了小改动，也需要花费时间去测试游戏各个环节能否正常运行）</li>
</ol>
<p>人们主要能体会到软件中的两类价值：</p>
<ol>
<li>帮助人们更好地做某件事，提高生产力，降低时间与金钱支出</li>
<li><strong>软件的行为表现</strong>：满足现阶段的用户需求，同时能频繁地变动以满足用户的需求变更，且没有 Bug 与崩溃。</li>
</ol>
<p>第一类价值的保证靠的的团队的产品等角色的发挥，而第二类价值的保证则需要工程师的软件架构设计来保证了，而 S.O.L.I.D 是应用最为广泛也最为基础的设计指导原则。</p>
<hr>
<h2 id="单一功能原则-rsp">单一功能原则 - RSP</h2>
<h3 id="解释">解释</h3>
<p>一个类或类似的结构只做一件事，只因为一个原因而发生变动</p>
<h3 id="详细阐述">详细阐述</h3>
<p>类的一切数据与方法都应该与这个单一的职责有关，即凝聚力。但这并不意味着你的类只能包含一个方法或属性。</p>
<h3 id="优点">优点</h3>
<ol>
<li>降低类的复杂度</li>
<li>提高可维护性</li>
<li>提高可读性</li>
<li>降低需求变化带来的风险</li>
</ol>
<h3 id="示例">示例</h3>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// <span class="type">Not</span> good, **<span class="number">3</span>** responsibility</div><div class="line">class <span class="type">Employee</span> &#123;</div><div class="line">    public <span class="type">Pay</span> calculatePay() <span class="meta">&#123;...&#125;</span> <span class="comment"># 1) calculation logic</span></div><div class="line">    public <span class="built_in">void</span> save() <span class="meta">&#123;...&#125;</span> <span class="comment"># 2) database logic</span></div><div class="line">    public <span class="type">String</span> describeEmployee() <span class="meta">&#123;...&#125;</span> <span class="comment"># 3) reporting logic</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Modem 类的设计改进：<br>
<img src="http://static.zybuluo.com/yangfch3/fhc0rg3c34qz6utayxdxgdsx/image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png" alt="image_1bu4tvefb1bf415tk15pf1ufd18eq1m.png-9.4kB"> =&gt; <img src="http://static.zybuluo.com/yangfch3/op876brznpgc56yawj4dsu1f/image_1bu4tvpgf1nfi2giv6bqjd1apb23.png" alt="image_1bu4tvpgf1nfi2giv6bqjd1apb23.png-28.1kB"></p>
<hr>
<h2 id="开放封闭原则-ocp">开放封闭原则 - OCP</h2>
<h3 id="解释-v2">解释</h3>
<p>软件中的对象（类，模块，函数等等）对扩展开放，对修改封闭。</p>
<h3 id="详细阐述-v2">详细阐述</h3>
<p>现有代码应该只在下面三种情况进行 <strong>修改</strong>：</p>
<ol>
<li>现有代码里有 Bug 或错误</li>
<li>现有代码实现的需求发生了变动（例如之前确定的算法或逻辑发生了改变）</li>
</ol>
<p>下面情况不应该需要改变现有代码，而能通过<strong>继承</strong>、<strong>多态</strong>来进行 <strong>扩展</strong> 即可变更软件的行为：</p>
<ol>
<li>以前做过可预测的同类需求。例如在员工管理系统中需要新增一个员工类型，支付系统需要新增一种支付方式</li>
</ol>
<p>通常的实现方法：<strong>对抽象编程，而不对具体编程；使用抽象类或接口，而不是使用具体的类；新功能的的增加通过实现继承抽象类或实现接口，而非改变已有代码来完成。</strong></p>
<p><strong>只有在将会发生的变化是可预测的情况下，OCP 才会有所帮助，所以你应当只有在类似的变化已经发生过的情况下使用它。</strong></p>
<h3 id="优点-v2">优点</h3>
<ol>
<li>扩展新功能时不容易引入新 Bug</li>
<li>新的功能添加无需对全部代码进行代码审查、单元测试</li>
<li>代码稳定性</li>
<li>解耦，增加弹性</li>
</ol>
<h3 id="实例">实例</h3>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 不难预料，将来可能支持除现金之外的收款方式</span></div><div class="line"><span class="comment"> * 这里直接写死成 acceptCash</span></div><div class="line"><span class="comment"> */</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将来需要新增一种收款方式，可能会被改成这样</span></div><div class="line">void checkOut(Receipt receipt) &#123;</div><div class="line">  Money <span class="keyword">total</span> = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    <span class="keyword">total</span> += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p;</div><div class="line">  <span class="keyword">if</span> (credit)</div><div class="line">    p = acceptCredit(<span class="keyword">total</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    p = acceptCash(<span class="keyword">total</span>);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PaymentMethod</span> &#123;<span class="function"><span class="keyword">void</span> <span class="title">acceptPayment</span>(<span class="params">Money total</span>)</span>;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkOut</span>(<span class="params">Receipt receipt, PaymentMethod pm</span>) </span>&#123;</div><div class="line">  Money total = Money.zero;</div><div class="line">  <span class="keyword">for</span> (item : items) &#123;</div><div class="line">    total += item.getPrice();</div><div class="line">    receipt.addItem(item);</div><div class="line">  &#125;</div><div class="line">  Payment p = pm.acceptPayment(total);</div><div class="line">  receipt.addPayment(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="里氏替换原则-lsp">里氏替换原则 - LSP</h2>
<h3 id="解释-v3">解释</h3>
<p>任何基类可以出现的地方，子类一定可以出现。所有子类需要按照其基本类别的方式进行操作。子类可以扩展父类的功能，但不能改变父类原有的行为预期。</p>
<h3 id="详细阐述-v3">详细阐述</h3>
<p>Liskov 提出的关于继承的原则：<strong>继承必须确保超类中所拥有的属性与方法在子类中仍然拥有</strong>。</p>
<p>Robert C. Martin 提出了更抽象的简化：<strong>子类必须能够替换成他们的基类</strong>。这也是里氏替换原则的精髓。</p>
<p>LSP 是继承复用的基石，只有当子类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而子类也可以在基类的基础上增加新的行为。</p>
<p>一般来说，如果超类的子类型做了超类的客户端所不期望的事情，那么这违背了 LSP。设想一个派生类抛出一个异常，超类不抛出，或者如果一个派生类有一些意想不到的副作用。</p>
<p>更具有指导意义的详细规范：</p>
<ol>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ol>
<h3 id="优点-v3">优点</h3>
<ol>
<li>里氏替换原则是实现开放封闭原则的具体规范</li>
<li>见开放封闭原则的优缺点</li>
</ol>
<h3 id="示例-v2">示例</h3>
<p>见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html" target="_blank" rel="external">链接</a></p>
<hr>
<h2 id="接口隔离原则-isp">接口隔离原则 - ISP</h2>
<h3 id="解释-v4">解释</h3>
<p>一个类不应该被强制依赖它不需要的接口成员。多个小的、特定的、具有内聚性的客户端接口要好于单个宽泛用途的、内聚性差的接口。</p>
<h3 id="详细阐述-v4">详细阐述</h3>
<p>与单一职责原则的不同点：</p>
<ol>
<li>单一职责原则注重的是对象的职责；而接口隔离原则注重对接口依赖的隔离</li>
<li>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</li>
</ol>
<p>接口的粒度需要我们自己去把控，接口的粒度过小会造成接口数量过多，设计复杂化；接口粒度过大，就很容易违背接口隔离原则。</p>
<p>另见下方示例</p>
<h3 id="优点-v4">优点</h3>
<ol>
<li>灵活性</li>
<li>避免接口臃肿</li>
</ol>
<h3 id="示例-v3">示例</h3>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Not Good</span></div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">Messenger</span> &#123;</div><div class="line">  <span class="selector-tag">askForCard</span>();</div><div class="line">  <span class="selector-tag">tellInvalidCard</span>();</div><div class="line">  <span class="selector-tag">askForPin</span>();</div><div class="line">  <span class="selector-tag">tellInvalidPin</span>();</div><div class="line">  <span class="selector-tag">tellCardWasSiezed</span>();</div><div class="line">  <span class="selector-tag">askForAccount</span>();</div><div class="line">  <span class="selector-tag">tellNotEnoughMoneyInAccount</span>();</div><div class="line">  <span class="selector-tag">tellAmountDeposited</span>();</div><div class="line">  <span class="selector-tag">tellBalance</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginMessenger</span> </span>&#123;</div><div class="line">  askForCard();</div><div class="line">  tellInvalidCard();</div><div class="line">  askForPin();</div><div class="line">  tellInvalidPin();	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  tellNotEnoughMoneyInAccount();</div><div class="line">  askForFeeConfirmation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">publc <span class="class"><span class="keyword">class</span> <span class="title">EnglishMessenger</span> <span class="keyword">implements</span> <span class="title">LoginMessenger</span>, <span class="title">WithdrawalMessenger</span> </span>&#123;</div><div class="line">  ...	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="依赖反转原则-dip">依赖反转原则 - DIP</h2>
<h3 id="解释-v5">解释</h3>
<ol>
<li>高层模块不应该依赖低层模块，所有模块都应该依赖抽象</li>
<li>抽象不应该依赖细节/具体</li>
<li>细节/具体应该依赖抽象</li>
</ol>
<h3 id="详细阐述-v5">详细阐述</h3>
<p>什么是依赖？</p>
<blockquote>
<p>不是我自身的，却是我需要的，都是我所依赖的。<br>
我若依赖你，我就不能离开你。</p>
</blockquote>
<p>什么是高层模块？什么是低层模块？</p>
<blockquote>
<p>类 A 直接依赖于类 B，假如要将类 A 修改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑。类 B 和 C 是底层模块，负责基本的原子操作。</p>
</blockquote>
<p>什么是抽象？什么是细节？</p>
<blockquote>
<p>抽象：抽象类或接口<br>
细节：具体的实现类或实现方法</p>
</blockquote>
<p>这里的依赖是什么？反转后的依赖变成了什么？</p>
<blockquote>
<p>这里的依赖原本指高层模块对低层模块的依赖，倒置的依赖演变成实现类对接口或抽象类的依赖</p>
</blockquote>
<p>反转怎么理解？</p>
<blockquote>
<p>由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。</p>
</blockquote>
<p><img src="http://static.zybuluo.com/yangfch3/dmo4sdqgvlw6uaa0a1eljgjm/image_1bu57m1gtbj8122q11etnn75gm2g.png" alt=""></p>
<h3 id="优点-v5">优点</h3>
<ol>
<li>松散耦合</li>
<li>多人开发，提取模块的抽象，可以进行多人并行开发</li>
<li>违背了依赖反转原则，那么开放封闭原则也就无法实行</li>
</ol>
<h3 id="示例-v4">示例</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块 A</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> &#123;</span> <span class="keyword">char</span> getchar(); &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> &#123;</span> <span class="keyword">void</span> putchar(<span class="keyword">char</span> c)&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharCopier</span> &#123;</span></div><div class="line">  <span class="keyword">void</span> copy(Reader reader, Writer writer) &#123;</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">while</span> ((c = reader.getchar()) != EOF) &#123;</div><div class="line">      writer.putchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模块 B</span></div><div class="line"><span class="keyword">public</span> Keyboard <span class="keyword">implements</span> Reader &#123;...&#125;</div><div class="line"><span class="keyword">public</span> Printer <span class="keyword">implements</span> Writer &#123;…&#125;</div><div class="line"></div><div class="line"><span class="comment">// 应用</span></div><div class="line">...</div><div class="line"><span class="keyword">new</span> CharCopier(<span class="keyword">new</span> Keyboard(), <span class="keyword">new</span> Writer());</div></pre></td></tr></table></figure>
<p>或见 <a href="http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html" target="_blank" rel="external">链接</a></p>
<h3 id="说明">说明</h3>
<p>依赖倒置原则的核心就是 <strong>面向接口编程的思想</strong>，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。但是这个原则也是 5 个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p>
<p>依赖倒置原则或者说面向接口编程的思想催生了许多经典的设计模式，欲细究可自行深入研究面向接口编程。</p>
<hr>
<p>参考资料：<br>
<a href="https://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/" target="_blank" rel="external">Object-oriented design principles and the 5 ways of creating SOLID applications</a><br>
<a href="http://www.cnblogs.com/hellojava/category/431379.html" target="_blank" rel="external">http://www.cnblogs.com/hellojava/category/431379.html</a></p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Design Patterns </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web 缓存及策略制定]]></title>
      <url>/2017/10/19/HTTP-Cache/</url>
      <content type="html"><![CDATA[<p>我们常常会注意到静态资源后面都跟着一串指纹码：<br>
<img src="http://static.zybuluo.com/yangfch3/8m3e3wnqpmxwhztq755quy1w/image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png" alt="image_1b1c9hn2rcdv1jn7pav1gdtjs6m.png-20.6kB"><br>
<img src="http://static.zybuluo.com/yangfch3/kp4cmtg8o50i34lh501vlhf3/image_1b1c9gujm10snq8f947iv5t49.png" alt="image_1b1c9gujm10snq8f947iv5t49.png-28.4kB"><br>
<img src="http://static.zybuluo.com/yangfch3/s3aubu6l1ylr6igytpuv18y6/image_1b1c9jtvr1aogmd0seg1o0714lu13.png" alt="image_1b1c9jtvr1aogmd0seg1o0714lu13.png-15.8kB"><br>
<img src="http://static.zybuluo.com/yangfch3/44bhvo0c8c89lggd60uyyhqn/image_1b1c9of7qf6b1abfvmp1er12801g.png" alt="image_1b1c9of7qf6b1abfvmp1er12801g.png-17.2kB"></p>
<p>同时我们在进行网络请求分析时会遇到 Cache-Control、Last-Modified 等这些 Header 字段。</p>
<p>在冥冥中，我们知道这些肯定与缓存有着重大的关系。缓存机制中有哪些关键的东西在起作用，如何制定最优的 <strong>缓存-更新</strong> 机制就是本文需要研究的问题。</p>
<a id="more"></a>
<h2 id="前言">前言</h2>
<p>首先让我们来看一次经典的 <strong>请求-响应</strong> 过程，以 <a href="https://zhihu.com" target="_blank" rel="external">zhihu.com</a> 登录页的某个 JavaScript 资源为例：<br>
<img src="http://static.zybuluo.com/yangfch3/0gotv3wpms8o77advh2x4jqn/image_1b1cacu1n1b4019s61jo816fj5ud1t.png" alt="image_1b1cacu1n1b4019s61jo816fj5ud1t.png-586.8kB"></p>
<p>我们从这次连接中看到以下与缓存相关的 HTTP(s) 请求头/响应头：</p>
<ul>
<li>Request Header
<ol>
<li>Cache-Control</li>
<li>If-Modified-Since</li>
<li>If-None-Match</li>
</ol>
</li>
<li>Response Header
<ol>
<li>Cache-Control（图上没有体现）</li>
<li>Last-Modified</li>
<li>ETag</li>
</ol>
</li>
</ul>
<p>一般，我们请求的缓存就是由上述 HTTP Header 进行<strong>校验</strong>与<strong>控制</strong>。是否需要缓存？缓存层级？缓存多久？缓存到期后如何处理？这些问题就是接下来的文章需要解决的。</p>
<h2 id="etag-if-none-match">ETag &amp; If-None-Match</h2>
<p>ETag 我们可以很形象地称之为<strong>验证令牌</strong>，这个令牌在<strong>缓存不符合我们的 Cache-Control 指定的规则</strong> 时起作用。</p>
<p>ETag 由服务器生成，由 Response Header 携带传送给客户端进行保存，客户端请求 Request Header 通过 If-None-Match 携带缓存的 ETag 值给服务器进行校验。</p>
<blockquote>
<p>ETag 是 Response Header 的字段，If-None-Match 是 Request Header 的字段，因为二者功能协作且字段值一致，下面统一用 ETag 代替。</p>
</blockquote>
<p>假如我们有如下静态资源，请求细节如下：<br>
<img src="http://static.zybuluo.com/yangfch3/95pdeafw683dqhtwj8ymhnpp/image_1b1cbv67c17de1kdb16rce9mtk2a.png" alt="image_1b1cbv67c17de1kdb16rce9mtk2a.png-18.4kB"></p>
<p>现在过了 120 秒，浏览器又对该资源发起了请求。</p>
<p>首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应缓存的文件现在已经“过期”，不能直接使用。此时，浏览器可以直接发出新请求，获取新的完整响应，<strong>但是这样做效率较低，因为如果本地缓存已过期，但服务器上资源在此期间未被更改过，我们就没有理由再去下载一遍</strong>。</p>
<p>这就是 ETag 头中指定的验证令牌所要解决的<em>问题</em><sup>1</sup>：服务器会生成并返回一个随机令牌，通常是文件内容的哈希值或者某个其他指纹码（具体实现细节由服务器决定）。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其（通过 If-None-Match 携带）发送给服务器：如果指纹码仍然一致，说明资源未被修改，我们就可以跳过下载，继续延长 Cache-Control（120s）。</p>
<blockquote>
<p>1：如果资源未被更改过，我们就没有理由再去下载与客户端缓存中已有的完全相同的资源。</p>
</blockquote>
<p>总结以上内容就是：</p>
<ol>
<li>ETag 在缓存过期（过了 Cache-Control 指定期限）之后起作用的</li>
<li>ETag 在缓存过期后判定是对缓存<strong>续命</strong>还是<strong>更新</strong></li>
</ol>
<h2 id="last-modified-if-modified-since">Last-Modified &amp; If-Modified-Since</h2>
<p>其实在 ETag 出现之前，就有了 Last-Modified/If-Modified-Since 验证机制。使用资源的最近一次更新时间（Last-Modified）进行校验是最符合我们日常认知的，也是最容易想到的一种方式。</p>
<blockquote>
<p>Last-Modified 是 Response Header 的字段<br>
If-Modified-Since 是 Request Header 的字段</p>
</blockquote>
<p>ETag 的出现是对 Last-Modified 机制的补充与严谨化。</p>
<ul>
<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存（而 ETag 是依据文件内容特征生成的指纹，能更精确地表示文件有无变化）</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Last-Modified 与 ETag 一起使用时，服务器会<strong>优先验证 ETag</strong>，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p>
<h2 id="cache-control">Cache-Control</h2>
<p><code>Cache-Control</code> 有一个比较特殊的点：Request Header 有此字段，Response Header 也有这个字段。</p>
<h3 id="max-age-num">max-age=[num]</h3>
<p>服务器返回头 Cache-Control 的 max-age 告诉客户端：<strong>此资源在客户端缓存时间为多久</strong>。</p>
<p>而比较特殊的 max-age=0 则相当于告知客户端：<strong>此资源刻意缓存在客户端，但每次重新请求都应该向服务器请求校验</strong>。</p>
<ol>
<li>服务器首次返回一个 max-age=0 的静态资源，客户端缓存到本地</li>
<li>客户端需要重新请求此静态资源时，发现本地有缓存，但是缓存已过期（因为 max-age=0）</li>
<li>客户端重新发送请求，携带 If-None-Match 头以及 max-age=0</li>
<li>服务端将收到的 If-None-Match 与文件的 ETag 比对</li>
<li>如果比对不一致，则下发静态资源，同时返回 Cache-Control 头和新的 ETag，客户端比对本地的 ETag 与返回的 ETag 后使用新的资源，并回到步骤 1</li>
<li>如果比对一致，则不下发返回静态资源，同时返回 Cache-Control 头和没变的 ETag，客户端比对本地的 ETag 与返回的 ETag 后直接使用缓存</li>
</ol>
<h3 id="no-cache">no-cache</h3>
<p>Response Header 的 no-cache 和 max-age=0 作用你可以将其等同起来。</p>
<p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#no-cacheno-store" target="_blank" rel="external">链接1</a><br>
<a href="https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">链接2</a></p>
<ol>
<li>no-cache 不代表禁止客户端缓存</li>
<li>no-cache 不是不缓存，而是不直接使用缓存（需要验证）</li>
</ol>
<blockquote>
<p>I believe max-age=0 simply tells caches (and user agents) the response is stale from the get-go and so they SHOULD revalidate the response (eg. with the If-Not-Modified header) before using a cached copy, whereas, no-cache tells them they MUST revalidate before using a cached copy.</p>
</blockquote>
<p><code>Cache-Control: max-age=0</code> 与 <code>Cache-Control: no-cache</code> 可能存在的不同点是：可能在点击浏览器的前进后退按钮时会存在差异。<code>Cache-Control: max-age=0</code> 可以直接使用，而 <code>Cache-Control: no-cache</code> 则会验证。</p>
<p>还有一个问题时，在某些版本的浏览器下，客户端对 no-cache 与 no-store 的处理是一样的：都是直接不缓存。</p>
<p>no-cache 在 Request Header 的作用则比较简单：告诉服务器，本地没有缓存或不使用缓存，你需要给我最新的文件。Chrome 下的强制刷新以及 Disable Cache 采取的就是在 Request Header 使用 no-cache。</p>
<h3 id="no-store">no-store</h3>
<p><code>Cache-Control: no-store</code> 直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</p>
<h3 id="public-private">public &amp; private</h3>
<p>服务器返回的 Cache-Control Header 如果有 public 字段，则表示可以多级缓存（用户代理、CDN、服务提供商）。</p>
<p>private 则表示单用户缓存，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是中间服务商不能缓存。</p>
<h2 id="实例：express-req-fresh-的判定机制">实例：Express req.fresh 的判定机制</h2>
<p>Express 中 req.fresh 用于判定客户端的请求是否是“新鲜”的请求（而不是对已缓存资源的请求），只有当请求头的 <code>cache-control</code> 不等于 <code>no-cache</code> 并且满足以下任意一条才表示客户端的请求是“新鲜”的（即服务器需要提供新资源）：</p>
<blockquote>
<ul>
<li>指定了 <code>if-modified-since</code> 请求头并且 <code>last-modified</code> 请求头等于或时间上早于 <code>modified</code> 响应头</li>
<li><code>if-none-match</code> 请求头是 <code>*</code></li>
<li><code>if-none-match</code> 请求头无法匹配响应头的 <code>etag</code></li>
</ul>
</blockquote>
<h2 id="http-caching-最佳实践">HTTP Caching 最佳实践</h2>
<p><img src="http://static.zybuluo.com/yangfch3/jwinkxrha3w4bkgq59kgr89f/image_1b1ciceslctp1ho2ib1rvf1evj2n.png" alt="image_1b1ciceslctp1ho2ib1rvf1evj2n.png-47.8kB"></p>
<h2 id="缓存与频繁更新的矛盾">缓存与频繁更新的矛盾</h2>
<p>有些资源是需要频繁更新的，但是我们又确实希望客户端对其进行缓存。此时我们就需要<strong>针对我们资源的特性制定不同的缓存策略与缓存级别</strong>，并使用<strong>资源指纹 URL</strong>搭配实现资源的随意更新。</p>
<p>于是我们可以看回本文开始部分介绍的几个典型网站静态资源的指纹URL案例：</p>
<ol>
<li>index.xxxxxxx.js</li>
<li>index$xxxxxx.js</li>
<li>index-xxxxxxx.js</li>
<li>/index.js?x.x.x</li>
</ol>
<p>上面的 <code>x</code> 即为指纹区，选择何种指纹视项目与团队规范而定。</p>
<p><strong>指纹 URL + Cache-Control</strong> 实现缓存与更新的精细控制案例：<br>
<img src="http://static.zybuluo.com/yangfch3/0achbqbncuy3hdfar6l5thm7/image_1b1cj198v4itmue1ishdsecbj34.png" alt="image_1b1cj198v4itmue1ishdsecbj34.png-29.7kB"></p>
<p>分析一下上面的例子：</p>
<ul>
<li>HTML 被标记成 <code>no-cache</code>（或 <code>max-age=0</code>），这意味着浏览器在每次请求时都会重新验证文档，如果内容更改，会获取最新版本。同时，在 HTML 标记中，我们<strong>在 CSS 和 JavaScript 资源的网址中嵌入指纹码</strong>：如果这些文件的内容更改，网页的 HTML 也会随之更改，并将下载 HTML 响应的新副本。</li>
<li>允许浏览器和中继缓存（例如 CDN）缓存 CSS，过期时间设置为 1 年。注意，我们可以放心地使用 1 年的“远期过期”，因为我们在文件名中嵌入了文件指纹码：如果 CSS 更新，网址也会随之更改。</li>
<li>JavaScript 过期时间也设置为 1 年，但是被标记为 private，<strong>也许是因为包含了 CDN 不应缓存的一些用户私人数据</strong>。</li>
<li>缓存图片时不包含版本或唯一指纹码（一般项目中也会包含指纹码），过期时间设置为 1 天。</li>
</ul>
<p>组合使用 <code>ETag</code>、<code>Cache-Control</code> 和唯一网址（指纹 URL），我们可以提供最佳的方案：<strong>较长的过期时间，控制可以缓存响应的位置，以及按需更新。</strong></p>
<h2 id="注意点">注意点</h2>
<ol>
<li>
<p>网址区分大小写</p>
</li>
<li>
<p>除了文中提到的这些 Header 字段，服务器还可以自己制定与实现一些辅助缓存机制的字段。如：<code>X-Cache</code> 这样。</p>
</li>
<li>
<p>如果在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保启用了 HTTP 缓存，并根据用途设置了合理的缓存大小，同时，确保缓存持久化。查看平台文档并确认您的设置！</p>
<blockquote>
<p>例如在微信内 Webview 的缓存就有一些比较特殊的地方，具体可阅读开发文档。</p>
</blockquote>
</li>
<li>
<p>在很多情况下我们还会在响应 Header 内遇到 Expires 字段，这是 HTTP 1.0 时的标准，主要是为了兼容较为老旧的浏览器。在 HTTP 1.1 中定义了 Cache-Control 代替 Expires。</p>
</li>
</ol>
<hr>
<p>参考资料：<br>
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">Google: Web Fundamentals - HTTP Caching</a><br>
<a href="http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="external">What’s the difference between Cache-Control: max-age=0 and no-cache?</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTTP </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器内核、引擎、页面呈现原理及其优化]]></title>
      <url>/2017/03/04/browser-core-and-engine/</url>
      <content type="html"><![CDATA[<p>介绍浏览器内核、JavaScript 引擎以及页面呈现原理等基础知识，同时根据原理提出页面呈现优化方案。</p>
<a id="more"></a>
<h2 id="浏览器内核">浏览器内核</h2>
<p>浏览器内核又叫渲染引擎，主要负责 HTML、CSS 的解析，页面布局、渲染与复合层合成。浏览器内核的不同带来的主要问题是对 CSS 的支持度与属性表现差异。</p>
<p>现在主流的内核有：Blink、Webkit、Gecko、EdgeHTML、Trident，这里面有几个需要注意的地方：</p>
<ol>
<li>
<p>Blink 是在 Webkit 的基础上的改进，是现在对新特性支持度最好的内核</p>
</li>
<li>
<p>移动端基本上全部是 Webkit 或 Blink 内核（除去 Android 上腾讯家的 X5），这两个内核对新特性的支持度较高，所以新特性可以在移动端大展身手。</p>
</li>
<li>
<p>Trident 是 IE4+ 的内核，一直持续到 IE11，EdgeHTML 是微软抛弃 IE 后开发的全新内核</p>
</li>
<li>
<p>更多资料请看附录表格</p>
</li>
</ol>
<h3 id="几种渲染模式">几种渲染模式</h3>
<p>一般现代浏览器都会有以下几种渲染模式：</p>
<ol>
<li>标准模式</li>
<li>接近标准模式（又称有限怪异模式）</li>
<li>怪异模式</li>
</ol>
<h3 id="不同渲染模式出现的原因">不同渲染模式出现的原因</h3>
<p>在 IE5 与 NS4 那个年代，浏览器大战，标准未立，Web 则在经历早期快速地发展。</p>
<p>后来标准逐步建立，新标准的规范与以前 IE5、NS4 的实现存在着不可避免的差异差异，但是此时的网络世界许许多多旧时的页面正在运行，如果按照新标准的实现来渲染的话会有大量的问题出现。</p>
<p>所以此时大部分现代浏览器厂商想到了区别性地使用<strong>不同渲染模式</strong>来对待这些 Web 页面。</p>
<p>而 IE 随着升级，对现代标准的支持也越来越完善，所以 IE 为了正常渲染旧时页面，<strong>支持我们指定哪个版本的 IE 模式来渲染页面</strong>。</p>
<p>总结就是：</p>
<ol>
<li>怪异模式是 IE5 与 NS4 年代遗留问题的回退方案</li>
<li>怪异模式在大部分浏览器都有部署，并且能在一定的机制下触发</li>
</ol>
<h3 id="不同渲染模式的触发">不同渲染模式的触发</h3>
<p>标准未立之前，HTML 文档是没有文档头的，同时在 HTML5 之前的 HTML4/3 的文档头都有各自的特征，所以在大部分现代浏览器下触发的机制如下：</p>
<ol>
<li>
<p>无 <code>DOCTYPE</code> 头触发<strong>怪异模式</strong></p>
</li>
<li>
<p><code>DOCTYPE</code> 头不正确（不是 html）也触发<strong>怪异模式</strong></p>
<blockquote>
<p>如：<code>&lt;!DOCTYPE svg&gt;</code></p>
</blockquote>
</li>
<li>
<p><code>DOCTYPE</code> 头为 HTML3 头触发<strong>怪异模式</strong></p>
</li>
<li>
<p><code>DOCTYPE</code> 头为 HTML4 头则触发<strong>接近标准模式</strong>（或称<strong>有限怪异模式</strong>）</p>
</li>
<li>
<p>常见的 HTML5 DOCTYPE 声明则使用<strong>标准模式</strong></p>
</li>
</ol>
<p>在 IE 下，除了文档头的差异可以自动触发渲染模式的选择，我们还能手动指定（在 IE8+ 适用）使用哪个版本的 IE 渲染模式来渲染我们的页面（<a href="http://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do" target="_blank" rel="external">扩展阅读</a>）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用当前操作系统已装的最新的 IE --&gt;</span></div><div class="line"><span class="comment">&lt;!-- chrome=1 是针对双核浏览器使优先使用 Chrome --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge,chrome=1"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用 IE9 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=9"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果你需要使用 IE5 的怪异模式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=5"</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="不同渲染模式的表现差异">不同渲染模式的表现差异</h3>
<p><strong>怪异模式与标准模式</strong></p>
<blockquote>
<ol>
<li>怪异模式使用不同于标准的盒模型（也就相当于 IE8+ 下的：<code>box-sizing: border-box</code>）</li>
<li>怪异模式下某些行内（inline）元素的垂直对齐行为表现怪异：<strong>怪异模式下对齐图片至包含它们的盒子的下边框</strong>，而 <strong>标准模式图片对其到父盒的 baseline</strong></li>
</ol>
</blockquote>
<p><strong>接近标准模式（有限怪异模式）与标准模式</strong></p>
<blockquote>
<p>主要区别即为上面的第 2 点</p>
</blockquote>
<h2 id="javascript-引擎">JavaScript 引擎</h2>
<p>JavaScript 负责 JavaScript 代码的解释与执行，主流的 JavaScript 引擎有：V8、SpiderMonkey、JavaScriptCore、Chakra。</p>
<p>浏览器与引擎详情见附录表格。</p>
<h2 id="页面呈现原理">页面呈现原理</h2>
<p>当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后是如何一步步将页面呈现出来的呢？这里面浏览器需要做哪些工作？如何优化呈现的过程提升 Web 应用质量？</p>
<h3 id="六部曲">六部曲</h3>
<p>一个页面的呈现，粗略的说会经过以下这些步骤：</p>
<ol>
<li>
<p>DOM 树的构建（Parse HTML）</p>
</li>
<li>
<p>构建 CSSOM 树（Recaculate Style）</p>
<blockquote>
<p>为什么是 <strong>Re</strong>-caculate Style 呢？这是因为浏览器本身有 <code>User Agent StyleSheet</code>，所以最终的样式是我们的样式代码样式与用户代理默认样式<strong>覆盖/重新计算</strong>得到的。</p>
</blockquote>
</li>
<li>
<p>合并 DOM 树与 CSSOM 树为 Render 树</p>
</li>
<li>
<p>布局（Layout）</p>
</li>
<li>
<p>绘制（Paint）</p>
</li>
<li>
<p>复合图层化（Composite）</p>
<blockquote>
<p>图层化是自己理解后形象的意译</p>
</blockquote>
</li>
</ol>
<p>其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。</p>
<h3 id="六部曲中的阻塞">六部曲中的阻塞</h3>
<p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p>
<p>我们来分析这六部曲中存在的阻塞问题：</p>
<ol>
<li>
<p>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（<strong>阻塞 1</strong>）</p>
<blockquote>
<p>那是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定，见 2</p>
</blockquote>
</li>
<li>
<p>当遇到 <code>&lt;script&gt;</code> 标签需要执行脚本代码时，浏览器会检查是否这个 <code>&lt;script&gt;</code> 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 <code>&lt;script&gt;</code> 上部还有 CSS 样式没加载，则浏览器会等待 <code>&lt;script&gt;</code> 上方样式的加载完成才会执行该 <code>&lt;script&gt;</code> 内的脚本（<strong>阻塞 2</strong>）</p>
</li>
<li>
<p>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（<strong>同步阻塞</strong>）</p>
</li>
<li>
<p>同时外部脚本、外部样式表的下载也是耗费时间较多的点</p>
</li>
</ol>
<h3 id="六部曲之-dom-树的构建">六部曲之 DOM 树的构建</h3>
<p><img src="http://static.zybuluo.com/yangfch3/ob8y6inhvvmg6rl9z4vn43fq/image_1ba5aftnnm7i11t8kl716c2164o9.png" alt="image_1ba5aftnnm7i11t8kl716c2164o9.png-96.9kB"><br>
浏览器构建 DOM 树可以简单的总结为以下几步：</p>
<ol>
<li>
<p><strong>转码（Bytes -&gt; Characters）</strong>—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</p>
</li>
<li>
<p><strong>Tokens 化（Characters -&gt; Tokens）</strong>—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</p>
</li>
<li>
<p><strong>构建 Nodes（Tokens -&gt; Nodes）</strong>—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br>
<img src="http://static.zybuluo.com/yangfch3/hfa6bzlsczzalvk5t89aa56f/image_1ba5an0vmfsn1kb928a1lv8vkpm.png" alt="image_1ba5an0vmfsn1kb928a1lv8vkpm.png-49.2kB"></p>
</li>
<li>
<p><strong>构建 DOM 树（Nodes -&gt; DOM Tree）</strong>—— 最重要的工作是建立起每个结点的父子兄弟关系</p>
</li>
</ol>
<blockquote>
<p><strong>在 Chrome 开发者工具下 Timeline 面板的 <code>Parse HTML</code> 阶段对应着 DOM 树的构建</strong>。<br>
<br></p>
</blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/24911872?refer=dreawer" target="_blank" rel="external">从Chrome源码看浏览器如何构建DOM树</a></p>
<blockquote>
<p>留意这篇文章的这些点：</p>
<ol>
<li>DOM 构建时对 DOCType 处理</li>
<li>DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响</li>
<li>处理开标签与闭标签的压栈、弹栈处理</li>
<li>Chromium 对待自定义标签的处理</li>
<li>JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比</li>
</ol>
</blockquote>
<h3 id="六部曲之-cssom-树的构建">六部曲之 CSSOM 树的构建</h3>
<p>CSSOM 树的构建 “原料” 的来源有：<strong>外部 CSS 文件、内部样式、内联样式</strong>。</p>
<p>CSSOM 树的构建其实是一个 <strong>样式的重新计算</strong> 的过程，为什么是重新计算呢？</p>
<blockquote>
<p>用户代理（即浏览器）本身有一套内置样式表，<strong>所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算</strong>。</p>
<p>所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 <code>Recalculate Style</code> 阶段</p>
</blockquote>
<p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br>
<img src="http://static.zybuluo.com/yangfch3/brh4juu5r4r8f7oh9jrekcle/image_1ba7m6adr1h52bm2mblup214t59.png" alt="image_1ba7m6adr1h52bm2mblup214t59.png-10.3kB"></p>
<p>最终构建的 CSSOM 树大致如下：<br>
<img src="http://static.zybuluo.com/yangfch3/yes5apeozng4x0j3xpjj3ubi/image_1ba7m7h67t731ikr1461topakgm.png" alt="image_1ba7m7h67t731ikr1461topakgm.png-42.2kB"></p>
<h3 id="六部曲之渲染树的构建">六部曲之渲染树的构建</h3>
<ol>
<li>
<p>DOM 树与 CSSOM 树融合成渲染树</p>
</li>
<li>
<p>渲染树只包括渲染页面需要的节点</p>
<blockquote>
<p>排除 <code>&lt;script&gt;</code> <code>&lt;meta&gt;</code> 等功能化、非视觉节点<br>
排除 <code>display: none</code> 的节点</p>
</blockquote>
</li>
</ol>
<p><img src="http://static.zybuluo.com/yangfch3/27ik5bf4rguih1mrpi112opo/image_1ba7mjun4h4l123b1smn13indhg13.png" alt="image_1ba7mjun4h4l123b1smn13indhg13.png-116.2kB"></p>
<h3 id="六部曲之布局">六部曲之布局</h3>
<p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。</p>
<blockquote>
<p><strong>Layout 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</strong></p>
</blockquote>
<p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 <code>Layout trashing</code>，又叫做回流（Reflow）。</p>
<h3 id="六部曲之绘制">六部曲之绘制</h3>
<p>一旦布局（Layout）步骤完成，浏览器便触发 “Paint Setup” 与 “Paint” 事件（渲染引擎底层概念），执行 <code>paint</code> 操作，<strong>结合渲染树与布局信息绘制实际像素</strong>。</p>
<blockquote>
<p>注：在 Timeline 工具内，<code>Layout</code> 与 <code>Paint</code> 两个过程被统一归并到 <code>Paint</code> 阶段。</p>
</blockquote>
<h3 id="六部曲之复合图层化">六部曲之复合图层化</h3>
<p>在很多情况下，我们<strong>不会将复合图层化</strong>归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p>
<p>见 <a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="external">链接</a></p>
<h2 id="页面性能优化">页面性能优化</h2>
<p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p>
<h3 id="优化不可避免的阻塞：优化关键呈现路径">优化不可避免的阻塞：优化关键呈现路径</h3>
<p><strong>关键呈现路径里的一些概念</strong>：</p>
<ul>
<li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li>
<li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li>
<li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li>
</ul>
<p><strong>优化关键呈现路径的指导原则</strong>：</p>
<ul>
<li>尽量减少关键资源数量。</li>
<li>尽量减少关键字节数。</li>
<li>尽量缩短关键路径的长度。</li>
</ul>
<p><strong>优化关键呈现路径常规步骤</strong>：</p>
<ol>
<li>分析和描述关键路径：资源数量、字节数、长度。</li>
<li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li>
<li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li>
<li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li>
</ol>
<p><strong>优化关键呈现路径的具体建议</strong>：</p>
<ol>
<li>
<p>文件合并、压缩</p>
</li>
<li>
<p>推荐使用异步（<code>async</code>） JavaScript 资源，或使用延迟（<code>defer</code>）执行的 JavaScript</p>
</li>
<li>
<p>一般 <code>&lt;script&gt;</code> 脚本的靠后书写</p>
</li>
<li>
<p>避免运行时间长的 JavaScript，<strong>耗时任务的拆分，chunk 化运行</strong></p>
<blockquote>
<p>例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</p>
</blockquote>
</li>
<li>
<p>避免使用 CSS import</p>
</li>
<li>
<p>内联、内部化阻止呈现的 CSS</p>
<blockquote>
<p>一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</p>
</blockquote>
</li>
</ol>
<h3 id="针对复合图层化的优化">针对复合图层化的优化</h3>
<p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p>
<h4 id="复合图层化机制">复合图层化机制</h4>
<p>某些属性的变更（<code>transform</code>、<code>opacity</code>）满足以下条件：</p>
<ul>
<li>不影响文档流。</li>
<li>不依赖文档流。</li>
<li>不会造成重绘。</li>
</ul>
<p>那么这些属性变更时就需要一种机制：机制需要能将属性变更的部分与页面其他部分隔离开来，其他部分已经渲染完好进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。</p>
<p>所以图层化的关键字：<strong>缓存</strong>、<strong>隔离</strong>、<strong>图层合成</strong></p>
<p>使用 <code>transform</code> 与 <code>opacity</code> 进行属性变更是经典的符合图层化方法，以下是其他会<strong>提升元素为复合图层的场景</strong>：</p>
<ol>
<li>3d 或透视变换 CSS 属性，例如 <code>translate3d</code>, <code>translateZ</code> 等等（JS 一般通过这种方式，使元素获得复合图层）</li>
<li><code>&lt;video&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;canvas&gt;</code> <code>&lt;webgl&gt;</code> 等元素。</li>
<li>混合插件（如flash）。</li>
<li>元素自身的 <code>opacity</code> 和 <code>transform</code> 做 CSS 动画。</li>
<li>拥有 CSS Filter 的元素。</li>
<li>使用 <code>will-change</code> 属性。</li>
<li><code>position:fixed</code>。</li>
<li>元素有一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</li>
</ol>
<h4 id="图层化的优势">图层化的优势</h4>
<p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来动画性能的提升。</p>
<h4 id="图层化的潜在问题-内存开销">图层化的潜在问题 —— 内存开销</h4>
<p>那么图层化的弊端在哪里呢？</p>
<p>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况（如下图）。</p>
<p><img src="http://static.zybuluo.com/yangfch3/dphdmt262yimw0vwjl4nomk5/image_1baah8s0vcol3464t21foe1sb91g.png" alt="image_1baah8s0vcol3464t21foe1sb91g.png-31.3kB"></p>
<center>同样表现的页面，单图层与多图层的内存开销</center>
<h4 id="因为开销-所以节制">因为开销，所以节制</h4>
<p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p>
<h3 id="针对回流的优化">针对回流的优化</h3>
<ol>
<li>
<p><a href="https://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a></p>
<ol>
<li>CSS3 &gt; JavaScript</li>
<li>属性变更优先考虑顺序（性能表现排序）
<ol>
<li><code>transfrom</code>, <code>opacity</code></li>
<li><code>background-color</code> 等</li>
<li><code>position</code> - <code>top</code> <code>bottom</code> <code>left</code> <code>right</code></li>
<li><code>width</code> <code>height</code> 等</li>
<li><code>margin</code>, <code>padding</code>, <code>border</code></li>
</ol>
</li>
</ol>
</li>
<li>
<p><a href="https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9" target="_blank" rel="external">What forces layout</a></p>
<blockquote>
<p>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。</p>
<p>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</p>
</blockquote>
</li>
</ol>
<h3 id="其他优化技巧">其他优化技巧</h3>
<h4 id="节流函数">节流函数</h4>
<p>已经比较明白了，那就略吧</p>
<h4 id="惰性载入函数">惰性载入函数</h4>
<p>也已经比较明白，也略吧</p>
<h4 id="重任务分片多帧">重任务分片多帧</h4>
<p><a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="external">实例讲解</a></p>
<h2 id="timeline-工具">Timeline 工具</h2>
<p>使用 Timeline 工具我们能做以下事：</p>
<ol>
<li>页面渲染帧率分析，得到异常帧信息</li>
<li>各类文件执行耗时/耗资源分析</li>
<li>文件等待 - 下载时间</li>
<li>页面呈现期间的事件列表</li>
<li>某个帧/某个事件的详细信息分析</li>
</ol>
<p><img src="http://static.zybuluo.com/yangfch3/xrxcqw4c0ignhkxgsfiqssrk/image_1ba7qi29r1b5f12c7tvh1muh9rm.png" alt="image_1ba7qi29r1b5f12c7tvh1muh9rm.png-524.5kB"></p>
<center>理解 Timeline 工具使用，读懂这图就够了</center>
<p><img src="http://static.zybuluo.com/yangfch3/vrr16pctepw9uct9raq881ps/image_1ba7rnvjs4gb1l35b6a1d9r3db34.png" alt="image_1ba7rnvjs4gb1l35b6a1d9r3db34.png-28.7kB"></p>
<center>常用事件，更多事件见[扩展阅读](#扩展阅读)</center>
<p>而我们在日常开发中，用 Timeline 最多的场景是：</p>
<ol>
<li>编写动画，Debug 不流畅的异常帧，针对性优化（见本章<a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a>一节）</li>
<li>侦测 <strong>重新计算样式</strong>、<strong>重新布局</strong>、<strong>重绘</strong>、<strong>重新合成</strong> 等事件，针对性优化</li>
<li>了解 JavaScript 函数调用栈以及函数调用带来的回流/重绘事件信息</li>
<li>查看在某个事件中代码的执行耗时（点击上图 Main 部分，点击下方常驻 Panel 内与文件相关的可点击链接）<br>
<img src="http://static.zybuluo.com/yangfch3/zhuzgdlqafnkjjzqwin1883w/image_1ba7rah2h136v1keujkjbn7pmv2a.png" alt="image_1ba7rah2h136v1keujkjbn7pmv2a.png-152.8kB"></li>
</ol>
<h3 id="让你的-timeline-调试更强大">让你的 Timeline 调试更强大</h3>
<ol>
<li>
<p>选择性地开启以下开关<br>
<img src="http://static.zybuluo.com/yangfch3/xnq7wto8jihkkkr6yhfiuppx/image_1ba7qso561sv3ep6lur1civ1vba13.png" alt="image_1ba7qso561sv3ep6lur1civ1vba13.png-49.2kB"></p>
</li>
<li>
<p>开启开发者工具实验性特性开关<br>
<img src="http://static.zybuluo.com/yangfch3/yii0ycjbnmixc2hzgt87w064/image_1ba7r0k4u12du17j819kkvcqgfv1t.png" alt="image_1ba7r0k4u12du17j819kkvcqgfv1t.png-405.1kB"></p>
<p><img src="http://static.zybuluo.com/yangfch3/akltusf3gvtzafsrg212ot82/image_1ba7r0cuochpk331s6810jq1t8n1g.png" alt="image_1ba7r0cuochpk331s6810jq1t8n1g.png-60.6kB"></p>
</li>
</ol>
<h3 id="扩展阅读">扩展阅读</h3>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool" target="_blank" rel="external">Timeline 官方简介</a><br>
<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference" target="_blank" rel="external">Timeline 事件参考</a><br>
<a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="external">推荐：Timeline 进行帧分析，避免页面卡顿</a></p>
<h2 id="附录">附录</h2>
<h3 id="浏览器内核与-js-引擎一览">浏览器内核与 JS 引擎一览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器/RunTime</th>
<th style="text-align:center">内核（渲染引擎）</th>
<th style="text-align:center">JavaScript 引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Chrome</td>
<td style="text-align:center">Blink（28~）<br>Webkit（Chrome 27）</td>
<td style="text-align:center">V8</td>
</tr>
<tr>
<td style="text-align:center">FireFox</td>
<td style="text-align:center">Gecko</td>
<td style="text-align:center">SpiderMonkey</td>
</tr>
<tr>
<td style="text-align:center">Safari</td>
<td style="text-align:center">Webkit</td>
<td style="text-align:center">JavaScriptCore</td>
</tr>
<tr>
<td style="text-align:center">Edge</td>
<td style="text-align:center">EdgeHTML</td>
<td style="text-align:center">Chakra(for JavaScript)</td>
</tr>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:center">Trident</td>
<td style="text-align:center">Chakra(for JScript)</td>
</tr>
<tr>
<td style="text-align:center">PhantomJS</td>
<td style="text-align:center">Webkit</td>
<td style="text-align:center">JavaScriptCore</td>
</tr>
<tr>
<td style="text-align:center">Node.js</td>
<td style="text-align:center">-</td>
<td style="text-align:center">V8</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于被删的旧文章]]></title>
      <url>/2017/02/21/new-beginning/</url>
      <content type="html"><![CDATA[<p>受限于以前知识深度与广度，博客旧文章存在诸多谬误，在此为以前传播过错误的知识致歉。如果你是通过搜索引擎或其他文章的引用来到本站进入了 404 页面，而你又对已经删除的文章内容感兴趣，你可以与我联系（yangfch3#<a href="http://gmail.com" target="_blank" rel="external">gmail.com</a>）索要旧稿，我会修正旧稿错误后回复给你。</p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
